# 数据结构（8）：图的应用 - 最小生成树

## 最小生成树（MST）

**定义：**一个具有`n`个顶点的连通图，它的每条边都有一个权值，我们取`n`个顶点以及`n - 1`条边出来形成一颗树，这棵树的边权和最小，这个树就称为最小生成树

最小生成树涉及的是无向图

**唯一性的充分条件：**

最小生成树不一定唯一

假设我们根据图生成了一颗最小生成树，树中的边称为树边，图中剩余的边称为非树边，我们将任意一个非树边加入到树中一定可以形成一个环，如果这个环中的每个树边的权值都严格小于这个非树边，那么最小生成树就是唯一的

反之，如果这个环中有树边的权值等于非树边，那么我们去掉这个树边，用这个非树边代替，就会得到一个新的最小生成树，且权值不变，最小生成树就不唯一

## Prim算法（普利姆算法）

**朴素Prim算法：**时间复杂度`O(n^2)`，使用于稠密图

**堆优化Prim算法：**时间复杂度`O(mlogn)`，适用于稀疏图，在稠密图中如果`m ~ n^2`，那么复杂度反而比朴素版本的高

**基本思想：**

这是一个贪心思想，每次将离连通部分距离最近的点和点对应的边加入的连通部分`T`，连通部分`T`逐渐扩大，一直到所有的点都加入到了连通部分

这里的距离指的是点直接与连通部分相连

```cpp
假设初始时有T, S两个集合，图的所以顶点初始在S集合中
dist[N]表示每个点到连通部分T的距离，初始时为无穷
    
随机加入S中的一个点到T中，更新其余点到T中的距离
 for(i = 0; i < n; i++)
 {
     t <- 找到集合S距离集合T最近的点;
     t加入到集合T中，用t更新其他点到集合T的距离;
     从S中剔除点t
 }
```

**证明：**

假设在求解的过程中，顶点`A`到连通块的边`a`的权值最小，假设最后的最小生成树没有包含`a`，那么在最后的最小生成树中`A`一定通过其他的路径连接到连通块中，如下图所示，这个路径一定有一个顶点连通块直接相连，假设是`B`，`b `的权值大于`a`：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-02-15-16-59-30-923_com.jideos.jno.png" alt="Screenshot_2024-02-15-16-59-30-923_com.jideos.jno" style="zoom:50%;" />

我们把`b`替换成`a`，显然，树的权值会变小，`A`通过其他路径构成的最小生成树的权值不是最小的，矛盾，因此每次应该加入权值最小的边到连通块中

**代码实现：**

![image-20240215164529225](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240215164529225.png)

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 510, M = 100010, INF = 0x3f3f3f3f;

int n, m;
//用邻接矩阵来存储
// dist表示点到连通块的距离
int g[N][N],dist[N];

bool st[N];//st[i] = true表示点i已经在连通块T内

int prim(){
    // 先将距离初始化为正无穷
    memset(dist, 0x3f, sizeof dist);
    
    //先将第一个点加入到集合T中
    dist[1] = 0;
    int res = 0;
    
    //加入n个点
    for(int i = 1; i <= n; i ++){
        int t = -1;
        //找n个点中距离集合T距离最小的点,一开始是第一个点
        for(int j = 1; j <= n; j ++){
            // 如果当前点仍然在集合S中,且当前点是第一次选
            // 或者当前点仍然在集合S中,且当前点的距离小于上一次选的点
            // 此时选中这个点
            if(!st[j] && (t == -1 || dist[j] < dist[t]))
                t = j;
        }
        
        //如果最小的距离都为正无穷,说明不连通
        if(dist[t] == INF) return INF;
        st[t] = true;//当前这个点从集合S中剔除
        //生成树的权值加上这个边
        res += dist[t];
        //用这个点更新其他所有点到集合T的距离
        //对于已经在集合T中的点,不受影响
        // 对于直接与t相连的点会进行一次更新, 其余的点其实距离不变
        // 加入t进入集合T中后,只有与t直接相连的点的距离才会受影响
        for(int j = 1; j <= n; j ++){
            dist[j] = min(dist[j], g[t][j]);
        }
        
        //如果图不是连通的,那么始终有点的距离不会更新,dist[k]为INF
    }
    
    return res;
}


int main(){
    
    cin >> n >> m;
    
    //将所有的边的权值初始化为正无穷
    memset(g, 0x3f, sizeof g);
    
    //读入边
    while(m --){
        int a, b, c;
        cin >> a >> b >> c;
        //无向图读入边以及如果有重边的话取权值更小的一个
        //重边权值大的一个边根据最小生成树的定义,不会成为一条边,这里直接剔除即可
        g[a][b] = g[b][a] = min(g[a][b], c);
        
    }
    
    int res = prim();
    if(res == INF) cout << "impossible";
    else cout << res;
    return 0;
}
```

**关于重边：**

关于重边问题，假如两个顶点之间有重边，我们直接取重边中权值最小的那一个，这样存储的图进行算法求解得到的生成树与原来的图的生成树是完全等价的

因为假如最后的生成树中没有这两个顶点之间的边，那我们存储哪个边都无所谓，假如最后的生成树中有这两个顶点之间的边，显然生成树中的边应该是最小权值的那一个

## Kruskal算法（克鲁斯卡尔算法）

时间复杂度：`O(mlogm)`

克鲁斯卡尔是加边算法，先将所有的点加入到集合`T`中，然后将所有的边从小到大排序，遍历边，如果边对应的两个点此时在集合T中不连通，则将边加入集合`T`，否则不加入

**基本思想：**

1. 先将所有的边按权重从小到大排序（算法瓶颈，实现复杂度`O(mlogm)`，并且注意的是，`kmlogm`的常数部分`k`很小
2. 一开始是集合中只有点，没有边，所有的点都不连通
3. 然后枚举每条边`a - b(w:c)`
   1. 如果`a`，`b`不连通，就把这条边加入到集合里面去

他的证明方式与Prim很像，这里不再赘述了

**代码实现：**

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N = 510, M = 100010, INF = 0x3f3f3f3f;
int n, m;

struct Edge{
    int a, b, c;
    
    //重载小于号, 可以使用Edge[i] < Edge[j]这样的语句
    //小于号看作一个函数, 这里的参数t表示的就是语句中<右边的Edge[j]
    bool operator < (const Edge& t) const {
        return c < t.c;
    }
}e[M];

int p[N];

//并查集找祖宗元素, p[x] = k表示x的父节点是k
int find(int x){
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main(){
    cin >> n >> m;
    
    // 读入所有的边
    for(int i = 0; i < m; i ++){
        
        cin >> e[i].a >> e[i].b >> e[i].c;
    }
    
    // 将所有的边排序
    sort(e, e + m);
    
    //初始化并查集,初始时每个结点的父节点是自己
    
    for(int i = 1; i <= n; i ++) p[i] = i;
    
    // cnt是一开始n个块的数量,也就是n个点在连通块T中
    int res = 0, cnt = n;
    
    //从小到大枚举所有的边
    for(int i = 0; i < m; i ++){
        int a = e[i].a;
        int b = e[i].b;
        int c = e[i].c;
        // 如果两个点没有连通
        // 将这个边加入到T中
        if(find(a) != find(b)){
            res += c;
            cnt --;
            // a的祖宗结点的父节点指向b的祖宗结点，合并两个块，也就是连通两个结点
            // 所以到最后所有的连通结点都有一个公共的祖先
            p[find(a)] = find(b);
        }
        
    }
    
    //如果最后连通块的数量大于1，说明原来的图就不连通
    if(cnt > 1) cout << "impossible";
    else cout << res;
    
    return 0;
}
```

这里并查集主要是用来判断两个点是否连通的，经过几次`find()`函数之后后面的判断非常的快，近似于常数级别，这里的时间复杂度主要花在排序上面，并查集详情看下面的文章

[算法基础（七）：Trie树，并查集，堆 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/576366304)