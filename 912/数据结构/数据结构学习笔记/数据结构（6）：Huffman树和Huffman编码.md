# 数据结构（6）：Huffman树和Huffman编码

## 前缀编码

**定义：**

对某个字符集进行编码，要求字符集中任意字符的编码都不是其他字符的编码的前缀

比如字符串`aabccccdd`，可以用`a->01, b->10, c->110, d->0000`，因此这个字符串的编码就是：`01011011011011011000000000`，因为编码的方式是前缀编码，所以讲这个`01`串的解码过程就是唯一的

**编码长度：**

`a`出现的次数是`W1 = 2`，`a`的编码长度`L1 = 2`，所以`a`对应的字符串编码长度就是`W1 * L1 = 4`

`b`出现的次数是`W2 = 1`，`b`的编码长度`L2 = 2`，所以`b`对应的字符串编码长度就是`W2 * L2 = 2`

`c`出现的次数是`W3 = 4`，`c`的编码长度`L3 = 3`，所以`c`对应的字符串编码长度就是`W3 * L3 = 12`

`d`出现的次数是`W4 = 2`，`d`的编码长度`L4 = 4`，所以`d`对应的字符串编码长度就是`W4 * L4 = 8`

我们将`a, b, c, d`的编码构造一颗树（`0`往左，`1`往右），如下图所示，每一个字符的编码都是从根节点走到这个字符的路径：

![Screenshot_2024-02-04-19-35-12-852_com.jideos.jno](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-02-04-19-35-12-852_com.jideos.jno.png)

可以发现，如果一组字符集的编码是前缀编码`<=>`根据上述方法构造树的话每个字符都只会是叶结点，任意一套前缀编码都可以对应一颗二叉树

## **带权路径长度（WPL）**

一个叶结点的带权路径长度是这个节点的权值乘以根节点到这个叶结点的路径长度，一颗树的带权路径长度是所有叶结点的带权路径长度之和，我们把上述二叉树的叶结点的权定义为字符在原字符串中出现的次数，那么这棵树的带权路径长度就是原字符串编码后的编码长度

因此根据上述定义，这个二叉树就是与前缀编码完全等价的

我们需要找到一个前缀编码使得原字符串编码后的编码长度最小，也就是构造一颗带权路径长度最小的二叉树，我们随机给这棵树的边赋值`01`，每个叶结点的路径就是这个字符的编码，这个编码就是`Huffman`编码，这棵二叉树就是`Huffman`树，构造过程就是`Huffman`编码的过程

## Huffman树的证明与构造

假设我们找到了上述这棵树（作为一个解），那么这颗树有如下性质：

1. **这颗树的内部节点的度数一定是`2`**

假如有个节点的度数是`1`，那么这个内部节点一定可以被他的子节点代替，因此这个分支上的叶结点的带权路径长度会减小，整个树的带权路径长度变小，那么当前有度数为`1`的内部节点的这棵树就不是最小的带权路径长度的树，出现矛盾

2.  **一定存在一颗这样的树（一个解），使得权值最小的两个点互为兄弟节点**

先证明**权值最小的点B一定在最底层**：

假设它不再最底层，那么一定存在一个在最底层的节点`A`，其深度大于这个节点`B`，且权值大于这个节点`B`，此时的树是`T1`，那么此时我们交换节点`A,B`，形成新的树`T2`，那么`T2`的带权路径长度一定小于`T1`的带权路径长度，与`T1`是一个解矛盾，所以权值最小的节点一定在这棵树的最底层

假设一个可行解的权值最小的两个点`a, c`的结构如下图所示，权值最小的两个点没有互为兄弟节点：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-02-04-19-40-53-892_com.jideos.jno.png" alt="Screenshot_2024-02-04-19-40-53-892_com.jideos.jno" style="zoom:50%;" />

调整节点`c`和`b`，因为`c, b`两个节点的深度都是一样的，所以调整后的树的带权路径长度和原来的一样，因此调整后的树也是一个可行解，所以一定存在一个可行解使得权值最小的两个点互为兄弟节点，因此对于任意一个可行解（一颗这样的树），都可以转化为权值最小的两个点互为兄弟节点的解，权值最小的两个点互为兄弟节点的可行解构成的集合`[C]`就可以当做可行解集

3. **`n`个字符节点的可行解集`[C]`，对于其中的任意一个可行解`treeA`，合并权值最小的两个节点变成`z`，此时变成了`n-1`个节点，这`n－1`个节点对应的可行解集为`[C2]`；此时去掉`treeA`中的权值最小的两个节点，添加节点`z`保持结构不变形成`treeB`，`treeB`一定是`[C2]`中的元素**

如下图所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-02-04-19-46-40-926_com.jideos.jno.png" alt="Screenshot_2024-02-04-19-46-40-926_com.jideos.jno" style="zoom:50%;" />

这里用反证法证明为什么`treeB`一定是`[C2]`中的元素：

假设`treeB`此时的带权路径长度不是最小的，也就是`z*(hz) + other`（`other`是其他叶结点的带权路径长度，`hz`是此时`z`的路径长度）不是最小的，而`treeA`的路径长度是`a*(hz + 1) + b*(hz +1）+ other = (hz)*z + z + other`，`z`是定值，`z*(hz) + other`不是最小的，也就说明`(hz) * z + z + other`不是最小的，这与`treeA`是一个可行解矛盾，因此此时`treeB`的带权路径长度就应该是最小的，也应该是`[C2]`集合中的一个可行解

而对集合`[C2]`中的任意一个元素，同上面的证明方式，我们将`z`拆开，就对应了集合`[C]`中的一个元素，因此集合`[C2]`与`[C]`中的树的结构是一一对应，只是集合`[C]`中的树的带权路径长度比`[C2]`中多`z`，且多了两个儿子节点`a, c`

根据上面的性质，我们得到了求一个`n`个节点的可行解（也就是构造一个可行的二叉树）的算法，伪代码如下：

```cpp
Create(n):表示构造n个节点的可行解
1. 取出n个节点中的权值最小的两个节点a, b
2. 合并成一个节点z且a,b作为z的左右儿子节点
3. 去除a, b节点，加入节点z，变成n - 1个节点
4. 递归构造这n - 1个节点的可行解Create(n - 1)
```

通过以上算法得到的二叉树称为`Huffman`树，这个二叉树的编码称为`Huffman`编码

当然也可以从合并代价的角度来考虑证明，两种理解方式完全等价：

[算法基础（四十一）：贪心 - Huffman树 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/672520196?)

不过这里直接记住算法即可，不求掌握证明

另外`Huffman`树的分支其实可以随机指定节点，不用一定要保证所有分叉的左分支是0，右分支是1，只需保证某个分叉的所有分支的编码互不相同即可，这样就可以保证一定是前缀编码

可以用反证法证明一定是前缀编码：

假设某个字符`a`的编码是字符`b`的编码的前缀，假设`a = 00, b = 001`，由于每一个分叉的分支对应的编码都是不一样的，因此从编码的第一位开始可以唯一确定分支，`a = 00`就说明经过00分支后此处就是叶结点，但是b = 001, 就说明00处的节点还有分支，矛盾，因此一定是前缀编码

## 一个例子

![image-20240204202248784](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240204202248784.png)

![image-20240204202257947](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240204202257947.png)

合并两个子树的代价是两个子树的根节点的权值和，合并所有子树的代价之和就是合并这颗树的代价，同时也是这个树的所有非叶子结点的结点权值之和，一颗树的带权路径长度就是这颗树的所有叶子结点的带权路径长度之和，同时也是从所有零散的结点合并成这颗树的代价

**代码实现：**

```cpp
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;


int main(){
    int n;
    cin >> n;
    priority_queue<int, vector<int>, greater<int>> heap;//定义一个优先队列
    
    while(n --){
        int x;
        cin >> x;
        heap.push(x);//读入n个果子插入到堆里
    }
    
    int res = 0;
    
    while(heap.size() > 1){
        //取出最小权值的两个结点
        int x = heap.top();heap.pop();
        int y = heap.top();heap.pop();
        
        res += (x + y);
        heap.push(x + y);//加入到堆中
       // cout << x << "  " << y << endl;
    }
    
    cout << res;
    return 0;
    
}

```

## Huffman树的变形`k`叉树编码

看这个例子`(NOI2015)`：

![image-20240205194258350](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240205194258350.png)



![image-20240205194321085](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240205194321085.png)

**解题思路：**

类似于Huffman树，我们需要构造一颗k叉树，构造方式与Huffman完全一样，每次合并`k`个节点，在分支上用`0 ~ k － 1`进行编码，这里不再赘述，不过需要注意的是可能总的节点个数不满足`n = z * k + k - 1`，那最后一次合并的时候就不能保证有`k`个分支，这个时候我们需要添加`k - 1 - n % k  `个权值为`0`的节点，添加节点后构造的树的带权路径长度与原来的节点构造的树的带权路径长度完全相同，原来的节点构造的树添加这些节点之后可变成添加节点构成的树，添加了这些节点构造的树去掉这些节点之后就变成了原来的节点构造的树，因此两种不同节点数量构造的可行解集是完全等价的并且带权路径长度也是一一对应相等，我们只需找到添加节点之后的最优解（最小带权路径长度的树），也就找到了原来的最优解

另外我们需要注意的是最优解并不是唯一的，比如下面这种情况，最小的两个权值有多个的话不同的合并最后的结果叶结点的编码是不一样的，但是带权路径长度是一样的：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-02-05-19-46-10-965_com.jideos.jno.png" alt="Screenshot_2024-02-05-19-46-10-965_com.jideos.jno" style="zoom:50%;" />

这道题目的第二问就是这样，要找到不同最优解中的最长编码最短的长度，也就是找到不同最优解中树的高度最小的解，这里需要再使用一次贪心，我们需要将高度更小的节点安排到最底层，也就是先合并高度更小的节点

对于中间合并的某次过程，若有两个高度不同但权值相同的节点`a, b`，两者的高度分别是`ha, hb`，且`ha < hb`，不管怎么合并，由于要保证最优解，所以此中间过程形成的树的形态是不变的如下图所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-02-05-19-58-55-589_com.jideos.jno.png" alt="Screenshot_2024-02-05-19-58-55-589_com.jideos.jno" style="zoom:50%;" />

也就是此中间过程树的最底层的高度在最后的结果的中是一个定值，假设为`h`，若将`a`安排在最底层，`b`安排在别处假设`b`所处的位置的高度为`h'`，那么最终的最优解的树的高度就是`height1 = max(h + ha, h' + hb, H)`，`H`是其他的节点形成的树的高度；假设`b`安排在最底层，那么最优解的树的高度就是`height2 = max(h + hb, h' + ba, H)`，由于`h > h'`，所以`height2 >= height1`，因此对于中间过程的合并，对于权值相等的两个点**合并高度更小的点是当前过程所有合并方案中得到最终结果的树的高度最小的**

所以我们在保证得到最优解的情况下尽可能合并高度更小的点即可，因此排序的时候需要进行双关键字段排序，最后得到的树一定是最优方案中高度最小的树

**代码实现：**

```cpp
#include<iostream>
#include<queue>
#include<algorithm>
using namespace std;

typedef long long LL;
typedef pair<LL, int> PLI;



int main(){
    LL n, k;
    cin >> n >> k;
    priority_queue<PLI, vector<PLI>, greater<PLI>> heap;//定义一个堆
    while(n --){
        LL num;
        cin >> num;
        heap.push({num, 1});
    }
    
    while((heap.size() - 1) % (k - 1)) heap.push({0, 1});
    
    LL res = 0;
    //int height = 0;
    while(heap.size() > 1){
        LL s = 0;
        int height = 0;//这里必须设置为0，因为新加入节点的高度是合并节点的高度取大的结果
        for(int i = 1; i <= k; i ++){
            auto a = heap.top();
            s += a.first;
            height = max(height, a.second);
            heap.pop();
        }
        heap.push({s, height + 1});//加入新合并的高度和权值
        res += s;
    }
    
    cout << res << endl << heap.top().second - 1 << endl;//输出结果，总的合并代价和串的长度，也就是高度减一
    
    return 0;
}
```

不过这题只需要掌握`k`叉树的Huffman思想即可，第二问不需要掌握，证明也不需要掌握
