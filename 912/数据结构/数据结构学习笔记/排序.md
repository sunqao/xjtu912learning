# 各大排序算法

## 直接插入排序

插入排序就是从第二个元素`t`开始一个个与前面有序的元素进行比较

如果前面一个元素`j`比这个元素大，则需要将`j`后移一位将位置空出来

如果前面一个元素`j`比这个元素小或者相等，则元素t插入到`j`的后面一位即可，此时`j`的后面的位置原本是上一次比较的比`t`大的元素`l`，因为`l`已经往后移动了一位，所以这里`j`的后面一位是`l`的复制，可以直接放入`t`

### **代码实现：**

```cpp
//待排元素都存放在数组w中
void insert_sort(){
    //从下标1开始，即从第二个元素开始
    for(int i = 1; i < n; i ++){
        int t = q[i];//这个是待插入的元素
        int j = i;//j用来往前遍历找到位置
        //如果前面一位元素比当前待插入的元素大
        while(j && q[j - 1] > t){
            //此时将前面元素向后移动一位
            w[j] = q[j - 1];
            j --;//继续向前一位元素比较
        }
        //退出循环之后此时j要么指向了0，表示前面的所有元素都比t大，应该将t放在第一位
        //要么此时j是上一次循环比t大的元素向后移动一位空出的位置，然后j - 1即j指向的位置前一位元素小于或等于t，那么此时j就应该存放元素t
        //要么就没有进入循环，有序元素末尾元素比t小或等于，直接将t插入原位置
        
        //所以此时推出循环之后j一定指向t应该插入的位置
        q[j] = t;
    }
}
```

### 时间复杂度：

**最好情况：**

最好情况就是原本数组就是有序的，外层循环执行n次，内部循环直接不进入，因此就是`O(n)`

**平均情况：**

近似理解一下，内层循环平均遍历i/2次，因此总的时间复杂度是$O(n^2)$

**最坏情况：**

最坏情况，就是$O(n^2)$

### 辅助空间复杂度：

辅助空间复杂度，也就是除了数组本身的空间之外还需要什么空间，这里可以发现除了数组本身的空间不需要太多额外的空间

因此辅助空间复杂度就是$O(1)$

### 稳定性：

所谓排序稳定性就是数组中相等的两个元素在排序之后会不会改变在原来数组中的相对位置

显然这里后面的元素当遇到前面比自己小或者等于的元素的时候不会将前面的元素向后移动，**因此是稳定的**

## 折半(二分)插入排序

上文的插入排序是找到合适的位置之后将后面的所有元素统一后移，并且找位置的方式是一个个往前枚举，这里找位置和移动元素的复杂度都是O(n)的	

因为前面的数是有序的，因此我们在找这个合适的位置的时候可以用二分法找到第一个大于`t`的元素，这样找位置就是O(logn)的复杂度；然后再将后面的元素统一后移，这样移动的速度还是O(n)，但是优化了找位置的速度

### 代码实现：

```cpp
void binary_insert_sort(){
    for(int i = 1; i < n; i ++){
        if(q[i - 1] <= q[i]) continue;//这里进行特判，如果前面有序数组的所有元素都比当前元素小就不用进行二分浪费时间了
        //这样前面就必然存在一个比当前元素大的元素
        
        int t = q[i];//当前待排元素是t
        //我们的目的就是二分出第一个比当前元素大的元素
        //进行二分
        int l = 0, r = i - 1;
        while(l < r){
            int mid = l + r >> 1;
            if(q[mid] > t) r = mid;
            else l = mid + 1;
        }
        //此时l = r 指向第一个比t大的元素
        //将r后面的元素全部向后移动
        for(int j = i - 1; j >= r; j --){
            q[j + 1] = q[j];
         
        }
        //将t放到正确的位置上
        q[l] = t;
    }
}
```

折半插入排序的各种效率与直接插入排序完全一样

注意这里我们的二分操作是找到比当前元素大的最小元素，因此是区间右侧性质的左端点，所以用的二分模板是下面：

```cpp
bool check(int mid){
    ......
}

bsearch(int l, int r, int t){
    int mid = l + r >> 1;
    while(l < r){
        //找到区间中右侧性质的右端点，check函数必须满足右侧性质，本题中就是>t
        if(check(mid)) r = mid;
    	else l = mid + 1;
    }
    return l;
}
```



## 冒泡排序

冒泡排序可以迭代很多次，每次都会将一个元素放到正确的位置上，即每次迭代都会将剩下元素中最小的元素放到开头

执行第i次操作的时候0~i-1已经排好序了，因此每次迭代的操作就是在没有排好序的元素中从后往前依次比较相邻的两个元素，如果大的元素在小的元素前面那么就交换位置，这样每次迭代一定可以找到最小的元素放到第i个位置上

### 代码实现：

```cpp
void bubble_sort(){
    //这里外层进行n - 1次迭代即可，每次将第i个位置排上正确的元素
    //这里只要前n - 1个位置是正确元素了，最后一个位置当然就是正确的元素了
    for(int i = 0; i < n - 1; i ++){
        bool is_swap = false;//如果在某次迭代中发现没有交换操作，那就说明数组有序，不用排序了
        //从后面没有排好序的元素往前依次遍历比较
        //因为i-1位置已经是正确元素，并且我们循环中比较的是j - 1，所以这里j = i + 1进入循环时比较i和i + 1，得到位置i的正确元素
        for(int j = n - 1; j > i; j --){
            if(q[j] < q[j - 1]){
                swap(q[j], q[j - 1]);
                is_swap = true;
            }
        }
        //如果一次遍历中发现没有交换了，说明已经有序，直接退出
        if(is_swap == false) break;
    }
}
```

### 时间复杂度

**最好情况：**

整个有序就是最好情况，只会遍历一次：
$$
O(n)
$$
**平均情况：**
$$
O(n^2)
$$


**最坏情况：**
$$
O(n^2)
$$


### 辅助空间复杂度：

O（1）

### 稳定性：

可以看到，如果相邻两个元素相等的话是不会进行交换的，因此冒泡排序就是稳定的

## 简单选择排序（选择排序）

冒泡排序可以看作是简单选择排序的优化

简单选择排序就每次选择一个后面没有排序的元素中最小的元素，然后放在正确的位置上

比如`1 3 5 2 4`

第一次，找到1，放到第一个位置上

第二次，遍历除了1后面的所有元素，找到2，然后与3交换放到第二个位置上结果是`1 2 5 3 4`

第三次，遍历2后面的所有元素，找到3，3与5交换，然后将3放到正确的位置上

......

### 代码实现：

```cpp
select_sort(){
    //外层循环n - 1次，每次将第i个位置处放入正确的元素
    for(int i = 0; i < n - 1; i ++){
        int k = i;//从第i个位置处往后遍历找到正确的元素
        //找到最小的元素放到正确的位置上
        for(int j = i + 1; j < n; j ++){
            //每次都记录值最小的元素的下标
            if(q[j] < q[k])
                k = j;
        }
        //此时k记录的是值最小的元素的下标
        swap(q[j], q[i]);//将这个最小的元素放到第i个位置处
    }
}
```



可以看到选择排序不管什么数据两层循环都必须要执行完，时间复杂度妥妥n^2级别

所以冒泡排序其实是其优化版，多了一个break

### 时间复杂度

**最好情况：**


$$
O(n^2)
$$
**平均情况：**
$$
O(n^2)
$$


**最坏情况：**
$$
O(n^2)
$$


### 辅助空间复杂度：

O（1）

### 稳定性：

简单选择排序是不稳定的，比如数据`2 2 1`

第一次外层循环将0位置处放入1时第一个2会与1交换，这样相同元素的相对位置就发生了变化

这样就不稳定了

其实所有不稳定的排序都可以变成稳定的排序，只要再加一个关键字即可，变成双关键字排序：`(key, key2)`

一开始的key2都是从小到大按照原来数组中的顺序递增且不相等

先按照key比较，当key相同的时候key2小的在前面就行了

## 希尔排序（shell sort)

Shell排序的基本思想是，首先将整个数组划分为若干个组

每个组内元素的下标是一个等差数列，等差数列的增量称为公差

不同组的公差都是相同的

举一个例子，有下面8个元素，每组的公差定位n/2即4，这样可以划分四组，下图的两个连线就可以看作一组元素：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241126181629457.png" alt="image-20241126181629457" style="zoom:50%;" />

接着每个组内使用插入排序排好序

然后再缩小公差，这里的缩小方法是任意的，比如定为n/4，这样公差就变成2了，形成了下面两组：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241126181942493.png" alt="image-20241126181942493" style="zoom:67%;" />

这样组内进行插入排序，最后得到结果

再缩小公差，这里的公差缩小到1，所有的元素划分为一组

最后的公差一定是1

> 插入排序对于部分序列有序的序列效果很好，这也是希尔排序可以相对插入排序优化的原因

### 代码实现

这里的公差选择n/2，n/4，n/8

```cpp
void shell_sort(){
    //首先进行公差枚举
    for(int d = n / 2; d; d /= 2){
        //然后枚举每一组序列的起点
        //每组序列的起点都不会大于公差
        for(int start = 0; start < d; start ++){
            //对于每一组进行插入排序
            //这里无非是将插入排序的增量改成了d
            //还是从每组第二个元素开始
            for(int i = start + d; i < n; i += d){
                int t = q[i];//这个是需要插入的元素
                j = i;//变量j用来往前遍历有序部分
                //如果前一个元素大于后一个元素，则需要进行后移
                while(j < start && q[j - d] < t){
                    q[j] = q[j - d];//后移一位
                    j -= d;//j继续向前遍历
                }
                //结束循环之后j就指向元素t应该放入的位置
                q[j] = t;
            }
        }
    }
}
```

这里的公差选择的时间复杂度其实还是O(n^2)

只有当公差选择n/3，n/3^2，n/3^3的时候时间复杂度才是$O(n^{\frac{3}{2}})$，代码如下：

```cpp
void shell_sort(){
    //这里的d最后有可能是2，但是不行，我们必须保证最后一次公差是1，所以需要进行一次特判
    for(int d = n/3; d; d = (d == 2? 1 : d / 3)){
        for(int start = 0; start < d; start ++){
            for(int i = start + 1; i < n; i += d){
                int t = q[i];
                int j = i;
                while(j >= start && q[j - d] > t){
                    q[j - d] = q[j];
                    j -= d;
                }
                q[j] = t;
            }
        }
    }
}
```

### 时间复杂度

希尔排序比上面几种排序更快的原因就是插入排序对于部分有序的序列中效果更好

这里只做一个结论记住即可，希尔排序的复杂度就是：
$$
O(n^{\frac{3}{2}}) = O(n\sqrt{n})
$$

### 空间复杂度

$$
O(1)
$$



### 稳定性

因为有分组的处理，因此**希尔排序是不稳定的**

