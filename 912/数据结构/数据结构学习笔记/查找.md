# 查找 - 基本概念与顺序查找

## 基本概念

### 平均查找长度：

假设一个数组有`n`个元素`x1, x2, .... xn`，我们想要在其中查找元素`k`

**成功下的平均查找长度：**

其实也就是期望
$$
ASL(成功) = \Sigma_i (P_i * C_i)
$$
`Pi`是`k = xi`的概率，`Ci`是查找到`k`的比较次数，假设`k`与每个元素相等的概率相同的话，`Pi = 1 / n`

**失败下的平均查找长度：**

失败情况下的平均查找长度与成功不同，这里是根据区间来进行计算的，假设数组中有`n`个元素如下图所示，这`n`个数划分出来了`n + 1`个区间：

 ![Screenshot_2024-03-16-09-48-56-046_com.jideos.jno](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-03-16-09-48-56-046_com.jideos.jno.png)

对于元素`k`来讲，它查找不到必然落在上图中的`n + 1`个区间之中，因此失败下的平均查找长度就是：
$$
ASL(失败) = \Sigma_i(P_i * C_i)
$$
`Pi`是`k`落在区间`i`的概率，`Ci`是落在每个区间的查找次数，假设`k`落在每个区间的概率相等的话，`Pi = 1 / (n + 1)`

所以平均查找长度其实与查找什么元素无关，是查找方式数据结构本身的性质

### **决策树（判定树）：**

 决策树其实就是每次比较的时候会出现不同的结果，然后在结果上进行分支，比如在第一个结点的时候有`> = <`三种情况，`>`的时候进入一个分支，`=`进入一个分支，`<`进入一个分支，进入每个分支后在分支结点进一步比较判定：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-03-16-11-03-50-875_com.jideos.jno.png" alt="Screenshot_2024-03-16-11-03-50-875_com.jideos.jno" style="zoom:50%;" />

可以用决策树分析不同查找方式的平均查找长度

## 顺序查找法

### 一般的线性表顺序查找：

假设线性表的元素为`x1, x2, x3, ....xn`

从前往后一个个看，顺序查找的决策树如下图所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-03-16-11-10-09-132_com.jideos.jno.png" alt="Screenshot_2024-03-16-11-10-09-132_com.jideos.jno" style="zoom:50%;" />

进入红色的分支表示查找成功，进入蓝色的分支表示查找失败

**成功平均查找长度：**

元素`k`与顺序表中每个元素相等的概率都相同，进入第一个分支的概率是`1 / n`，查找次数是`1`，进入第`i`个分支的概率是`1 / n`，查找次数是`i`，因此平均查找长度为：

`1 / n * (1 + 2 + 3 + ... + n) = (n + 1) / 2`

**失败的平均查找长度：**

查找失败是一定会落入蓝色的分支的，因此这个区间概率是`1`，落入这个分支的查找次数就是`n`，因此失败的平均查找长度就是`n`(有的教材是`n + 1`，与代码的写法有关，不用纠结)

### 有序的线性表顺序查找：

假定所有的元素都是不一样的，线性表的元素为`x1 < x2 < x3 < ... < xn`

有序的线性表的决策树如下图所示，蓝色表示查找失败落入失败的区间，红色分支表示查找成功：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-03-16-11-26-37-680_com.jideos.jno.png" alt="Screenshot_2024-03-16-11-26-37-680_com.jideos.jno" style="zoom:50%;" />

**查找成功的平均查找长度：**

落入第一个红色的分支查找一次，落入第二个红色的的分支查找两次，。。。，查找元素`k`与每个元素相等的概率是一样的，因此平均查找长度就是：

`1 / n * (1 + 2 + 3 + ... + n) = (n + 1) / 2`

**查找失败的平均查找长度：**

一共有`n + 1`个区间，落入每个区间的概率是相同的是`1 / (n + 1)`，落入第一个区间的查找次数是一次，落入第二个区间的查找次数是两次，落入第`n`个区间的查找次数是`n`次，落入第`n + 1`个区间的查找次数是`n`次，因此失败的平均查找次数就是：

`1 / (n + 1) * (1 + 2 + 3 + ... + n + n) = (n^2 + 3n) / (n + 1)`



一般顺序表和有序顺序表的区别在于：一般顺序表 不能通过大小关系来直接判断是否查找成功或者失败，一般顺序表失败的情况下必须全部比较完才能知道查找失败

但是有序顺序表不一样，因为是有序的，所以通过前后两个元素的大小来直接判断整个表中是否含有这个元素

# 查找 - 折半和分块查找

## 折半查找法

**决策树构造：**

也就是二分查找，这里以下取整为例来说明决策树的构造过程，假设我们查找的数是`num`

一开始`low = 0`，`high = 5`，`mid = (low + high) / 2 = 2`，以`mid`对应的树为根结点构造树：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-03-25-18-03-03-899_com.jideos.jno.png" alt="Screenshot_2024-03-25-18-03-03-899_com.jideos.jno" style="zoom:50%;" />

如果此时`num < 30`，则有`high = mid - 1`，再进行`mid = (low + high) / 2`，将`mid`对应的数作为根结点

如果此时`num = 30`，找到结束

如果此时`num > 30`，则有`low = mid + 1`，再进行`mid = (low + high) / 2`，将`mid`对应的数作为根结点

此时构造的子树如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-03-25-18-32-40-369_com.jideos.jno.png" alt="Screenshot_2024-03-25-18-32-40-369_com.jideos.jno" style="zoom:50%;" />

按照这种思路继续构造下去，形成的二分查找的决策树如下图所示，红色表示查找失败落入的区间，蓝色表示查找成功：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-03-25-18-39-21-818_com.jideos.jno.png" alt="Screenshot_2024-03-25-18-39-21-818_com.jideos.jno" style="zoom:50%;" />

折半查找法的`ASL = log(n + 1) - 1`，一般考察的时候会让画出上面这颗树，这里的平均查找长度直接记住即可，`log`是以`2`为底

ASL就是平均查找长度

以上面为例，查找成功就是蓝色圈圈，每个点概率一样，都是1/6，比较次数就是从根结点一直到这个结点的比较次数，比如结点10就是比较2次，20就是比较3次

因此成功的ASL = (1 + 2 + 2 + 3 + 3  + 3) * 1/6 = 7/3

查找失败就是落入红色圈圈

因此失败的ASL = (2 + 3 + 3 + 3 + 3 + 3 + 3 ) * 1/7 = 20 / 7

## 分块查找法

假设有`n`个元素，分成若干个块，每个块中有`s`个元素，那么一共有`n/s`个块，这些块的块内元素无序，块间元素有序，也就是说前一块中的所有元素一定全部小于第二个块中的元素，如下图所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-03-28-16-27-03-751_com.jideos.jno.png" alt="Screenshot_2024-03-28-16-27-03-751_com.jideos.jno" style="zoom:50%;" />

分块查找元素有两种查找方式：

**顺序查找块：**

顺序查找成功的平均查找长度是`(n + 1) / 2`

查找在哪个块中，一个有`n / s`个元素，平均查找的次数是`((n / s) + 1) / 2`

在块中查找的时候只能用顺序查找法，平均查找的次数就是`(s + 1) / 2`

加起来得到：`(s^2 + 2s + n) / (2s)`

另外这个式子可以化为：`1 + (s + n/s) / 2`，在`s = sqrt(n)`的时候取到最小值`1 + sqrt(n)`

**折半查找块：**

折半查找的平均查找长度是`log(n + 1) - 1`，

折半查找块的时候的平均查找次数是`log(n/s + 1) - 1`

在块中的时候只能用顺序查找法，平均查找次数就是`(s + 1)  / 2`

加起来得到：`log(n/s + 1) - 1 + (s + 1) / 2`

# 查找 - B/B+树

`B/B+`树其实是对二叉搜索树(BST)的扩展，下面所有内容来自下面这个博客的整理（真的太详细了

[B树和B+树的插入、删除图文详解 - nullzx - 博客园 (cnblogs.com)](https://www.cnblogs.com/nullzx/p/8729425.html)

## B树（B-树）

它是一颗多路平衡查找树，我们描述一颗`B`树的时候应该指定阶数，阶数表示了一个结点最多有多少个孩子结点，阶数为`2`的就是常见的二叉搜索树

### **定义**

1. 每个结点最多有`m - 1`个关键字
2. 根结点最少有`1`个关键字
3. 非根结点最少有`math.ceil(m / 2) - 1`个关键字，`(Math.ceil指上取整)`
4. 每个结点的关键字都按照从小到大的顺序排列，每个关键字的左子树的关键字都小于它，右子树中的所有关键字都大于它
5. 所有叶子结点都位于同一层，根结点到任何叶子结点的长度相同

下面是一颗`m = 4`的`B`树，每个结点中存储了关键字`key`和关键字对应的数据`value`，以及孩子结点的指针，**我们将一个key和其对应的data称为一个记录**。**但为了方便描述，除非特别说明，后续文中就用key来代替（key, value）键值对这个整体**，在数据库中我们将B树（和B+树）作为索引结构，可以加快查询速速，此时B树中的key就表示键，而data表示了这个键对应的条目在硬盘上的逻辑地址。

![clip_image002](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/834468-20180406232634472-395289491.png)

### B树的插入操作

插入操作是指插入一条记录，即（key, value）的键值对。如果B树中已存在需要插入的键值对，则用需要插入的value替换旧的value。若B树不存在这个key,则一定是在叶子结点中进行插入操作。

1）根据要插入的key的值，找到叶子结点并插入。

2）判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。

3）以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第2步。

下面以5阶B树为例，介绍B树的插入操作，在5阶B树中，结点最多有4个key,最少有2个key

------

a）在空树中插入39

![clip_image002[4]](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/834468-20180406232637766-945625689.png)

此时根结点就一个key，此时根结点也是叶子结点

------

b）继续插入22，97和41

![clip_image004](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/834468-20180406232641280-907189483.png)

根结点此时有4个key

------

c）继续插入53

![clip_image006](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/834468-20180406232644645-1214967776.png)

插入后超过了最大允许的关键字个数4，所以以key值为41为中心进行分裂，结果如下图所示，分裂后当前结点指针指向父结点，满足B树条件，插入操作结束。当阶数m为偶数时，需要分裂时就不存在排序恰好在中间的key，那么我们选择中间位置的前一个key或中间位置的后一个key为中心进行分裂即可。

![clip_image008](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/834468-20180406232701452-1205325216.png)

这里的当前指针指向父节点的意思是分裂后`41`这个键值对插入到父节点中，此时考察父节点，如果父节点的键值对个数超过了`4`，那么重复上述操作，继续分裂，一直到满足`B`树的定义

------

d）依次插入13，21，40，同样会造成分裂，结果如下图所示。

![clip_image010](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/834468-20180406232716269-1873273300.png)

------

e）依次插入30，27, 33 ；36，35，34 ；24，29，结果如下图所示。

![clip_image012](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/834468-20180406232719931-1845157889.png)

-----

f）插入key值为26的记录，插入后的结果如下图所示。

[![clip_image014](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/834468-20180406232724001-1518264552.png)](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232722072-2101780219.png)

当前结点需要以27为中心分裂，并向父结点进位27，然后当前结点指向父结点，结果如下图所示。

[![clip_image016](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/834468-20180406232732844-330586131.png)](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232727483-1657363165.png)

进位后导致当前结点（即根结点）也需要分裂，分裂的结果如下图所示。

[![clip_image018](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/834468-20180406232737701-1115673096.png)](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232735788-403419538.png)

分裂后当前结点指向新的根，此时无需调整。

------

g）最后再依次插入key为17,28,29,31,32的记录，结果如下图所示。

[![clip_image020](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/834468-20180406232748270-1888091858.png)](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232742794-343445338.png)

------

在实现B树的代码中，为了使代码编写更加容易，我们可以将结点中存储记录的数组长度定义为m而非m-1，这样方便底层的结点由于分裂向上层插入一个记录时，上层有多余的位置存储这个记录。同时，每个结点还可以存储它的父结点的引用，这样就不必编写递归程序。

一般来说，对于确定的m和确定类型的记录，结点大小是固定的，无论它实际存储了多少个记录，因为类型确定的话插入记录只会插入到每个结点的空闲位置处。但是分配固定结点大小的方法会存在浪费的情况，比如key为28,29所在的结点，还有2个key的位置没有使用，但是已经不可能继续在插入任何值了，因为这个结点的前序key是27,后继key是30,所有整数值都用完了。所以如果记录先按key的大小排好序，再插入到B树中，结点的使用率就会很低，最差情况下使用率仅为50%，排好序后再插入记录，当结点满了之后进行分裂，分裂出去的新的结点的空间很容易浪费

### B树的删除操作

删除操作是指，根据key删除记录，如果B树中的记录中不存对应key的记录，则删除失败。

1）如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第2步

2）该结点key个数大于等于`Math.ceil(m/2)-1`，结束删除操作，否则执行第3步。

3）如果兄弟结点key个数大于`Math.ceil(m/2)-1`，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。

否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。

有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。

下面以5阶B树为例，介绍B树的删除操作，5阶B树中，结点最多有4个key,最少有2个key

# 查找 - 哈希表

## 基本概念

哈希表就是将一个集合映射到从零开始的一堆整数

这个集合可以是数的集合也可以是字符串

哈希的目的就是大大减少查找的速度，平均情况下就是O(1)的时间复杂度

### **负载因子（装填因子）：**

一般而言哈希表是不会被全部填满的，我们用已经有的元素数除以整个数组的长度，得到的就是负载因子，一般而言负载因子就是0.5左右，为了提高我们的查找效率，一般应该让哈希表中的元素尽可能稀疏，即负载因子尽可能少一些

不管是拉链法还是开放寻址法，装填因子的计算一律是：
$$
\alpha = \frac{关键字个数}{表长N}
$$
因此哈希表长就是关键字个数除以装填因子，并且上取整，即不小于结果的最小整数，这是因为尽可能想要表中的元素稀疏一些

## 常用的哈希函数

这里我们以数字映射到数字为例子来说明常用的哈希函数

d = H(key)

这里的key就是关键字，H(key)就是散列函数，其实就是形成的数组地址的值

### 直接定址

一个数`x`的哈希值是`x*a + b`

这种方式不会产生冲突，但是会造成空间浪费

### 除余法

一个数`x`其哈希值是`x % M`

这里的M选取一般是不大于表长的最大质数

### 平方取中法

先对一个数`x`平方一下，然后看看其二进制的一些位，然后用二进制位的十进制值表示这个数x的哈希值

## 冲突处理的方式

其实哈希表的思想就是将一些数映射到数组中

数组的下标即数的地址就是哈希值，数组的内容就是这些数

这样我们查找数的时候就可以直接根据哈希函数看看这个数的哈希值，也就是下标是什么，可以在常数时间复杂度中找到这个数了

但是很显然不同的数对应同一个哈希函数可能哈希值是一样的，那映射到数组中的时候地址就是一样的，这样存储的时候就产生了存储冲突，

下面就介绍解决这种存储冲突的方法

### 拉链法

就是如果数经过哈希函数只有产生了冲突，那么冲突的数就不存在数组中了，存在外面，因此就是开散列

这时我们在同一个位置处用一个链表存储，将所有映射到这个位置处的元素用一个链表来存储，因此也叫做拉链法

比如关键字序列是`19 14 23 01 68 20 84 27 55 11 10 79`，哈希函数是`%13`，我们存放的结构如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241125181216930.png" alt="image-20241125181216930" style="zoom:50%;" />

### 开放寻址法

这里的闭散列方法处理冲突的时候就不是将冲突的元素存放在外面了

这里的处理冲突方法是在数组中另外找一个坑位来存储冲突的元素，因为哈希表的装填因子一般是0.5左右，也就是哈希表的一半空间都是空的，所以当出现冲突的时候再找一个坑位存储时一般都可以容易找到，这样寻找元素遇到冲突的时候一般再找一或者两个位置就可以找到元素了

> 举一个例子，假如哈希函数是模3，那么关键字1和4模三之后的哈希值是一样的，都是1，那肯定是1先存放，然后4存放的时候遇到冲突：
>
> <img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241125182755057.png" alt="image-20241125182755057" style="zoom:50%;" />
>
> 我们直接将4的哈希值加一，看看此时有没有空位（数组地址就是哈希值），有空位就填上

很显然你遇到冲突之后重新给关键字设立哈希值也有不同的方法，这些方法就是开放寻址法中不同的解决冲突的方法，我们查找关键字的遇到冲突的时候也要用到这些方法取查找关键字的下一个哈希值，上面的例子其实就是线性探测方法

#### **聚集和二级聚集：**

**聚集现象：**

我们在处理冲突的时候其实本质是查找一系列的哈希序列的，比如上面的例子线性探测法

关键字1如果遇到冲突了，其查找的序列就是1，2，3，4....然后重复到0

关键字4如果遇到冲突了，其查找的序列就是1，2，3，4....然后重复到0

关键字2如果遇到冲突了，其查找的序列就是2，3，4，5....然后冲突到0，1

可以发现不同关键字的哈希查找序列其实重复很大，这样当关键字多了之后这些序列很容易被占满，别的关键字再来的时候也只能放在这些序列中，那这些重复的哈希序列总是被不同的元素映射，这就称为聚集现象

显然，当关键字多了之后聚集现象很容出现冲突，因为你关键字的哈希查找序列大部分都是重复的，前面的关键字将这些都填满了，后面关键字又映射到这些序列，那再填就会出现冲突

**二次聚集现象：**

二次聚集是针对经过第一次哈希映射后产生冲突的关键字的聚集现象

比如哈希函数是模三，解决冲突产生的哈希序列方法是d + 2, d + 4，d + 6

这样关键字1的序列是3，5，7......

关键字2的序列是2，6，8......

这样关键字1，2因为哈希值不一样，所以产生的哈希序列也就不一样，这样就避免了哈希值是1和2的关键字的聚集

但是关键字1和4的序列是3，5，7是一样的，因此原本就产生冲突的关键字当数量多了之后仍然会在这些序列中聚集，仍然会有冲突发生

这种聚集就是二次聚集现象



为了解决聚集问题，我们对于每个元素在出现冲突的时候再形成的哈希值，也就是形成哈希序列的方法会有所改进，尽量减少不同的关键字形成的哈希序列的重复性

下面来介绍几种形成哈希序列的方法

#### 线性探测方法

上文中的例子是关键字`x`形成哈希值d之后通过d + 1 , d + 2,....来形成解决冲突的哈希序列

其实我们可以通过d + c, d + 2c来形成序列

当c = 2的时候

这样关键字1的哈希查找序列就是1，3，5

关键字2的哈希查找序列就是2，4，6

这样就错开了这两个关键字的哈希值，跟d + 1这种解决冲突的方法相比就减少了不同关键字在相同哈希序列中的聚集现象

但是如果关键字是1，4，7的话模三之后根据这种解决冲突形成的哈希序列其实还是相同的，而且你关键字3的哈希序列也是0，2，4，6.....因此还是会有相当多的聚集现象，因此**线性探测法就是容易产生聚集问题**

#### 二次探测方法

如果一个关键字是`x`，其哈希值是`d`，那这种方式形成的哈希序列是：
$$
d + 1^2, d - 1^2, d + 2^2,d - 2^2, d +3^2, d - 3^2.....
$$
也就是我们以平方左右摇摆来产生哈希序列

这样可以很好解决聚集

但是对于哈希值相同关键字冲突而产生的哈希序列相同的**二次聚集现象无法避免**

#### 随机探查方法

如果一个关键字是`x`，其哈希值是`d`，那这种方式形成的哈希序列是：
$$
d + p_i
$$
其中pi是一个随机数，其实是伪随机数，这里的随机数不是关键字映射一次就产生一个随机数，而是哈希表创建一次就给每个坑位生产一个随机数，一次哈希映射到相同位置处的关键字其形成的哈希序列还是一样的，**无法避免二次聚集现象**

这里随机数肯定不能随便随机，否则后面查找的时候就不能查找了

#### 双散列探查方法

散列其实就是两次哈希

如果一个关键字是`x`，其哈希值是`d`，那么其形成的探查序列不仅和d有关还和x有关

也就是说关键字`x`第一次哈希找到坑位是一次哈希

后面冲突了形成的哈希序列是根据一个跟`x`和`d`有关的二次哈希函数产生的，这样不同关键字形成的哈希序列就不仅与一次哈希的d有关，还和自己本身的值有关，这样就很好地**解决了二次聚集问题**

## 成功查找次数和失败查找次数的计算

**散列表的成功查找次数比较好算：**

概率一般都是等概率的，是关键字的个数分之一

然后散列表构造好了之后就看每个关键字的查找次数了，按照解决冲突的方法直接观察计算即可

**散列表的失败查找次数：**

概率一般也是等概率的，首先看失败的可能

其实这里的失败可能次数与**散列函数的取值可能一样**，而不是散列表的大小一样

比如散列函数是%11的，那么失败次数就可能有11种结果，概率就是1/11

比如散列函数是(key * 3) % 7，那么取值就只有7种情况

然后看每种失败结果查找的次数，这里还是得先根据题目构建散列表，比如下面的散列表，散列函数就是模11，解决冲突的方法是线性探测法：

![image-20241125194509105](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241125194509105.png)

当查找到数组地址中的元素是空的时候就失败了，以H(key) = 1这种为例

第一次哈希地址是1，比较一次

然后由于是线性探测，因此下一次哈希地址时2，再比较一次

下一次哈希地址3，下一次是4，下一次是5，下一次是6，7，然后到8，发现为空，失败

因此比较次数就是8次

H(key) = 8这种情况，此时哈希地址中的元素就是空，直接就失败，因此比较次数就是1次

所以失败的查找次数平均就是：

![image-20241125194752791](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241125194752791.png)

> 注意无论是拉链法还是开放寻址法，失败的时候，如果题目条件没有特殊说明，为空的地方也要比较一次
