# 图的基本概念

## 大题

### （1）完全图

**完全图：**对于一个无向图来说，每个顶点都与其他顶点之间有一条边的图称为完全图，如果一个完全图有n个顶点，那么边的个数就是$\frac{n(n- 1)}{2}$

> 对于一个无向图来说，如果是非联通图，那么n - 1个顶点组成完全图，剩下一个顶点加入图变成一个非连通图，这时的边最多

**有向完全图：**在有向图中任意两个顶点之间都存在两条方向相反的弧，因此边的个数就是$n(n - 1)$

这道题目，对于固定的边，所对应图的顶点个数要最少

换个说法对于两个非连通子图V1 + V2是两个图的顶点之和，其中V2最少，那必然是1个顶点，下面看V1最少是多少

V1的所有顶点贡献了题中的28条边，对于$n(n-1)/2$条边，其可以对应n个顶点，但是不能对应n - 1个顶点，所以n是$n(n-1)/2$所对应的最小顶点，这里就是8

因此加起来就是9

### （2）图的邻接矩阵存储 + 拓扑排序（序列）

**图的邻接矩阵：**

其实就是用一个二维数据`A[][]`来存放图，如果顶点i, j之间有一条边i -> j，那`A[i][j] = 1`，如果没有边，那就是`A[i][j] = 0`

如果边带权值的话，如果ij有边那就是：`A[i][j] = w`没有边那就是正无穷

这道题目要求这个图的邻接矩阵的1全部在对角线上方，也就是得保证所有的边都是结点小的指向结点大的，也就是对于每条边的顶点(x, y)保证x编号 < y编号

**拓扑序列：**

那这个图就存在一个顶点拓扑序列，我们直接得到这个图的拓扑顶点序列，然后从小到大编号即可

> 若一个由图中所有顶点构成的序列`A`满足：对于图中的每条边的两个顶点 `(x,y)`，`x` 顶点在 `A`序列中都出现在 `y`顶点之前，则称 `A` 是该图的一个拓扑序列，另外一个图的拓扑排序是不唯一的，不一定所有的图都有拓扑排序，如果图中有环则不存在拓扑排序
>
> **拓扑序列是顶点的序列，跟编号无关**

每次将入度为`0`的顶点加入到序列中，并将这个点从图中去除，如下所示，下面是顶点编号已经实现的图，其实初始的顶点编号无所谓，按照这种算法直接得到一个拓扑顶点序列，我们直接从小到大重新编号即可：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-02-13-16-31-36-188_com.jideos.jno.png" alt="Screenshot_2024-02-13-16-31-36-188_com.jideos.jno" style="zoom:50%;" />

可以用一个队列来维护当前入度为`0`的点，然后将这个点去除，它的临接点的入度都减一，加入下一个入度为0的点，不断迭代

# 图的存储和基本操作

## 大题

### （2）图的邻接链表存储

（1）每个图的顶点都对应一个链表，这个链表存放的是这个顶点可以到达的所有顶点

（2）无向图的一条边看作两条有向弧边

一个邻接表包括两类结点，其结构定义如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241110124639502.png" alt="image-20241110124639502" style="zoom:50%;" />

存储举例如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241110124704654.png" alt="image-20241110124704654" style="zoom:50%;" />

### （3）图的邻接矩阵的乘法性质

如果一个图的邻接矩阵为A，顶点编号从0开始

则$A^m$的第`i`行第`j`列即`A[i][j] = k`表示从顶点i到顶点j的路径长度为`m`的路有`k`条

# 图的遍历

## 大题

### （1）图的邻接表存储和构造代码 + 图的dfs和bfs代码 + 图的dfs和bfs生成树

**图的邻接表存储数据结构：**

```cpp
struct Node{
    
    int id;//当前顶点的编号
    Node* next;//当前顶点指向下一个顶点的指针
    Node(int _id): id(_id), next(NULL){}
}*head[N];//定义一个所有图的结点的指针链表头结点, N是图的顶点的个数

//这里形成的链表以head[i]中的顶点i区分这个链表是谁的链表，比如在图中有i -> 1, i -> 4这两条边
//那么head[i]中存放的其实是1这个结点，1这个结点指向4
```

**图的构造（头插法插入结点）：**

```cpp
void add(int a, int b){
    //这个函数传递的是一条变a -> b，说明我们要在a为头结点的链表中增加一个结点，头插法
    //将p插入到head[a]的头部
    auto p = new Node(b);
    p->next = head[a];
    haed[a] = p;
}
```

**图的dfs代码：**

关键是用一个`st[N]`数组来记录已经遍历过的结点，主要函数如下：

```cpp
st[N];
dfs(int u){
    st[u] = true;//这个结点设置为true表示遍历过
    //输出这个结点表示进行了一次遍历
    cout << u;
    for(auto p = head[u]; p ; p = p->next){
        if(!st[p->id]) dfs(p->id);
    }
}
```

当然上面只是主要的函数，还有可能是这个图不是一个连通图，在主函数中需要遍历st[]看看是否还有没有遍历的顶点

**图的bfs代码：**

图的bfs和队列的bfs一样是用队列来实现的，只不过跟dfs一样，在加入顶点到队列中的时候需要用一个st[N]数组来

```cpp
st[N];
bfs(){
	queue<int> q;//一个队列，用来存放所有的顶点编号
    q.push(1);//先将第一个顶点加入到队列中
    st[1] = true;
    while(q.size()){
        auto t = q.front();//取出队列头元素
        q.pop();//将队列头元素剔除掉
        cout << t << endl;//打印这个顶点的编号
        //将这个顶点的所有邻接顶点加入到队列中
        for(auto p = head[t]; p; p = p->next){
            if(!st[p->id]) q.push(p->id), st[p->id] = true;
        }
    }
}
```

当然如果这个图不是一个连通图，那么在主函数中遍历st[N]数组，将为false的顶点加入到队列中继续进行bfs即可

**图的dfs和bfs生成树：**

如果题目中只给了一个图，没有给存储结构，那么答案是不唯一的

如果题目中给出了存储结构，那么由于代码是固定的，因此答案其实就是唯一的

dfs和bfs生成树一定是在原来的图中消去某些线得到结果，比如这道题题目：

dfs的过程就是固定的1 -> 2 -> 3 -> 4 -> 5直接线连起来就好了，广搜也是这样的，反正得到的树的dfs和bfs要和图的dfs和bfs的结果一致就好：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241113103550899.png" alt="image-20241113103550899" style="zoom:50%;" />

### （2）判断图是否是树

树其实是特殊的图，树必须在图的基础上满足下面两个条件之一：

（1）这个图是一个没有环路的连通图

（2）这个图是N个顶点，N - 1条边的连通图

第一个判断的方法是需要判断连通以及判断环路

这里使用第二个判断方式

判断连通，直接dfs一遍看看st数组有没有false即可

判断有N - 1条边，其实跟遍历点差不多，在遍历一个顶点的所有邻接点的时候，如果这个点没有背遍历过，那dfs遍历这个点，并且遍历到的边数 + 1

### （3）图的打印路径递归操作

dfs打印从u到v的所有路径：

可以用一个栈来存储路径，遍历到这个顶点的时候将顶点编号入栈，这个顶点返回的时候将这个顶点出栈并且st[N]数组设置为空，表示在后面其实还可以再用：

```cpp
st[N];
stack<int> path;
void dfs(int num){
    path.push(num);
    st[num] = true;
    if(num == v) 打印stack中的路径
    while(auto p = head[num]; p ; p = p->next){
        int j = p->id;
        if(!st[j]) dfs(j);
    }
    //返回的时候将这个顶点从路径中弹出，并且st[num]置为空表示下次遍历到的时候还可以用作路径上的点
    path.pop();
    st[num] = false;
}
```

