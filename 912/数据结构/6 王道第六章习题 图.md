# 图的基本概念

## 大题

### （1）完全图

**完全图：**对于一个无向图来说，每个顶点都与其他顶点之间有一条边的图称为完全图，如果一个完全图有n个顶点，那么边的个数就是$\frac{n(n- 1)}{2}$

> 对于一个无向图来说，如果是非联通图，那么n - 1个顶点组成完全图，剩下一个顶点加入图变成一个非连通图，这时的边最多

**有向完全图：**在有向图中任意两个顶点之间都存在两条方向相反的弧，因此边的个数就是$n(n - 1)$

这道题目，对于固定的边，所对应图的顶点个数要最少

换个说法对于两个非连通子图V1 + V2是两个图的顶点之和，其中V2最少，那必然是1个顶点，下面看V1最少是多少

V1的所有顶点贡献了题中的28条边，对于$n(n-1)/2$条边，其可以对应n个顶点，但是不能对应n - 1个顶点，所以n是$n(n-1)/2$所对应的最小顶点，这里就是8

因此加起来就是9

### （2）图的邻接矩阵存储 + 拓扑排序（序列）

**图的邻接矩阵：**

其实就是用一个二维数据`A[][]`来存放图，如果顶点i, j之间有一条边i -> j，那`A[i][j] = 1`，如果没有边，那就是`A[i][j] = 0`

如果边带权值的话，如果ij有边那就是：`A[i][j] = w`没有边那就是正无穷

这道题目要求这个图的邻接矩阵的1全部在对角线上方，也就是得保证所有的边都是结点小的指向结点大的，也就是对于每条边的顶点(x, y)保证x编号 < y编号

**拓扑序列：**

那这个图就存在一个顶点拓扑序列，我们直接得到这个图的拓扑顶点序列，然后从小到大编号即可

> 若一个由图中所有顶点构成的序列`A`满足：对于图中的每条边的两个顶点 `(x,y)`，`x` 顶点在 `A`序列中都出现在 `y`顶点之前，则称 `A` 是该图的一个拓扑序列，另外一个图的拓扑排序是不唯一的，不一定所有的图都有拓扑排序，如果图中有环则不存在拓扑排序
>
> **拓扑序列是顶点的序列，跟编号无关**

每次将入度为`0`的顶点加入到序列中，并将这个点从图中去除，如下所示，下面是顶点编号已经实现的图，其实初始的顶点编号无所谓，按照这种算法直接得到一个拓扑顶点序列，我们直接从小到大重新编号即可：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/Screenshot_2024-02-13-16-31-36-188_com.jideos.jno.png" alt="Screenshot_2024-02-13-16-31-36-188_com.jideos.jno" style="zoom:50%;" />

可以用一个队列来维护当前入度为`0`的点，然后将这个点去除，它的临接点的入度都减一，加入下一个入度为0的点，不断迭代

# 图的存储和基本操作

## 大题

### （2）图的邻接链表存储

（1）每个图的顶点都对应一个链表，这个链表存放的是这个顶点可以到达的所有顶点

（2）无向图的一条边看作两条有向弧边

一个邻接表包括两类结点，其结构定义如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241110124639502.png" alt="image-20241110124639502" style="zoom:50%;" />

存储举例如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241110124704654.png" alt="image-20241110124704654" style="zoom:50%;" />