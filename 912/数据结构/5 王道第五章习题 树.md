# 树的基本概念

## 选择

1. D

2. C

### **结点的度：**

结点的度就是一个结点拥有的子树的个数

### **树的度：**

树内各结点的度的最大值，也就是树中最多儿子结点的儿子个数

### **树的所有结点的度数之和与结点个数的关系：**

结点个数 - 1 = 树的所有度数之和，因为除了根结点之外每个结点都对应一个分支，一个分支就对应一个度

3. A

### **结点的路径长度：**

从根结点到这个结点的的路径上的所有的边的数目

### **树的路径长度：**

除叶结点之外，从根结点到其他所有结点的路径长度之和

4. A

### **树的高度（深度）：**

是树中结点的最大层数，根结点是第一层，具有n个结点的m叉树的最小高度是$

### **m叉树：**

每个结点可以挂的结点个数<=m个，也就是每个结点的儿子结点的个数<=m个

### **n个结点的m叉树的最小高度h：**

如果这个树的高度是h，那么如果想要高度h的树的结点个数最大的话，那显然每个结点都必须挂满m个子结点，第一层1个结点，第二层m个结点，第三层m^2个结点。。。。。这是一个等比数列，加起来得到高度为h的树的结点个数最多为：
$$
\frac{m^h - 1}{m - 1}
$$
同理，如果结点有n个，那肯定每层都必须挂满才能让总高度最小，所以就上上式 = n，反解出来得到最小高度为：
$$
h = log_m(n(m - 1) + 1)
$$

5. A

6. C

7. B

## 大题

### 2 树的总度数和结点个数的关系 + 叶结点的关系

这种题目就列出两个方程即可

（1）总度数 + 1 = 总结点个数

（2）总结点个数 - 度数不为零的结点的个数 = 叶结点个数 

### 3 树的总度数和结点个数关系 + 叶结点的关系

# 二叉树的概念

## 选择

### 二叉树的定义

二叉树就是每个结点至多只有两个子树的树，并且二叉树的子树有左右之分，次序不能颠倒，即二叉树是一颗有序树，如果将二叉树的左右结点颠倒，则是一颗不同的二叉树

并且二叉树可以为空树，并且二叉树哪怕一个结点只有一个儿子，这个儿子在左右不同的位置那也是一颗不同的二叉树

### 二叉树的叶结点和度 = 2的结点的个数关系

n0 = n2 + 1，n0是叶结点的个数，n2是度为2的结点的个数

这个问题还是列出两个方程，跟上面的类似，n1是度为1的结点的个数，n是总的结点个数：

（1）n = n1 + 2n2 + 1，结点个数与总度数的关系

（2）n = n0 + n1 + n2，总结点个数 - 度数不为零的结点的个数 = 叶结点个数 

### 满二叉树和完全二叉树的定义

![image-20241005214751957](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241005214751957.png)

满二叉树的每一层都堆满了结点，完全二叉树是每个结点编号都与满二叉树一致的二叉树，相当于对应高度的满二叉树最后一层去掉一些叶结点

### 满二叉树和完全二叉树的结点编号 + 上下取整符号

规定结点编号根结点为1，如果一个结点的编号是i，则其父节点的编号是$\lfloor i\rfloor$

> $\lfloor \rfloor$是下取整符号，即$\lfloor 4.9\rfloor = 4$，$\lceil \rceil$是上取整符号，$\lceil 4.9 \rceil = 5$，如果是一个整数，不管是向上还是向下取整结果都是数字本身

如果父节点是i，则左儿子是2i,  右儿子是2i + 1；如果一个完全二叉树的结点的编号为`x`，那么它的左儿子的结点的编号是`2x`，它的右儿子的节点的编号是`2x + 1`，满二叉树和完全二叉树具有一样的结点编号规律，注意这里的结点i不是叶结点

### 满二叉树和完全二叉树的高度

高度为h的满二叉树的结点个数是$2^h - 1$，结点个数为n的二叉树的高度是$log_2(n + 1)$，这根据满二叉树的特征利用等比数列可以推导出来

**完全二叉树的高度：**$ \lfloor log_2n \rfloor + 1$，`n`是完全二叉树结点的个数，下取整加一

> 完全二叉树每一层最左侧的结点的编号就是2的幂次方，它取对数加一就是它的深度，由于每一层最左侧的结点的编号分别以2的次幂递增，因此对于第`k`层的结点，最左侧的结点的编号为`2^(k - 1)`，对于第`k + 1`层的结点最左侧的编号是`2^(k)`，所以对于第`k`层的任意一个结点，他的编号都在`2^(k - 1) ~ 2^k`之间，结点的编号也就是结点的到根节点的结点的个数，所以第`k`层结点的编号取对数在`k - 1 ~ k`之间，向下取整就是`k - 1`，再加一就恰好是这一层的高度
>
> 因此如果一个完全二叉树的高度为`h`，那么最后一层的所有结点的编号取对数的范围都是[h - 1, h)，最后一个结点的编号为`n`，同时也是二叉树的结点的个数，因此`n`取对数下取整再加一就一定是高度`h`了

### （4）只有度为0和度为2的二叉树的形态

这种二叉树，结点个数最少是下面这种形态：

![image-20241016180131009](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241016180131009.png)

最多结点个数，那就是一个满二叉树

### （6）二叉树的总结点方程

这道题目还是考察下面两个方程：

（1）N = n1 + 2n2 + 1，树的总结点等于总结点的度 + 1，也就是分支数 + 1

（2）N = n0 + n1 + n2，数的总结点等于叶结点个数 + 度为1的结点的个数 + 度为2的结点的个数

因为2m + 2n2 + 1 = 2n，等式左边是奇数，右边是偶数，显然不可能

### （12）完全二叉树的叶结点问题（两种可能）

注意完全二叉树如果深度是h，则其叶结点可能出现在h层，也可能出现在h - 1层

这道题目得先算出完全二叉树的高度，然后算最后一层的结点个数

### （14）完全二叉树中度为1的结点的个数

要么是0个要么是1个，出现度为1的结点的完全二叉树只能是下面这种形状：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241016181941772.png" alt="image-20241016181941772" style="zoom:67%;" />

### （15）二叉树的存储结构 + 二叉树总结点方程

**顺序存储结构：**

顺序存储结构，就是用一个数组来存放整个二叉树的结点，二叉树的结点编号就是在数组中的下标

对于满二叉树和完全二叉树用这种方式存储非常方便，但是对于普通二叉树则需要补充一些不存在的结点到数组中来满足实际结点数组下标就是对应的完全二叉树中结点下标的条件

因此普通二叉树存放的时候会造成空间的浪费

**链式存储结构：**

就是用下面链表结构存储：

```cpp
typedef struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
}
```

不再多说

这道题目，所谓二叉链就是上述链式存储结构

空指针个数就是2n0 + n1的个数

而根据二叉树结点方程：

（1）N = n1 + 2n2 + 1，树的总结点等于总结点的度 + 1，也就是分支数 + 1

（2）N = n0 + n1 + n2，数的总结点等于叶结点个数 + 度为1的结点的个数 + 度为2的结点的个数

得到n0 = n2 + 1

所以空结点个数就是2n2 + 2 + n1 = n + 1

### （17）完全二叉树的结点编号和其所在深度的关系

设结点编号为p，其所在高度为h，则有：
$$
2^{h -1} \le p <2^h
$$
因此log2p下取整之后其结果一定是h - 1

### （22）二叉树的顺序存储+题目的理解

这道题目关键是理解对任意二叉树都可以存放，所以顺序存储应该开到最大空间，即31个存储单元，而不是16个存储单元

## 大题

### （1）完全二叉树的高度

这种涉及结点的度的题目一律先列出两个方程：

（1）n0 + n1 + n2 = n

（2）n1 + 2n2 + 1 = n

从而得到n2 + 1 = n0，因为n1 = 1从而得到n = 2n2 = 2(n0 - 1)

**完全二叉树的高度，结点个数下取整加一**

### （4）满m叉树的结点编号问题

在满m叉树中，如果一个结点的编号是i，那么其第一个子结点的编号为
$$
(i - 1)*m + 2
$$
如果一个结点的编号是j，那么其父节点的编号就是：
$$
\lfloor \frac{j - 2}{m} \rfloor  + 1
$$


如果一个结点的编号是i，那么其第k个子结点的编号为：
$$
(i - 1)*m + 1 + k
$$
上面三个结论记住

第四问，当这个结点不是双亲结点的第m个子结点的时候才能有右兄弟

这个结点的父节点的编号是$\lfloor \frac{i - 2}{m} \rfloor  + 1$，这个父节点的第m个结点编号是：
$$
\lfloor \frac{i - 2}{m} \rfloor * m + 1 + m
$$
这个编号要大于i：
$$
\lfloor \frac{i - 2}{m} \rfloor * m + 1 + m > i
$$

# 二叉树的遍历

## 一，选择

## 二，大题

### （1）二叉树的遍历

二叉树的先序遍历是NLR，即先遍历当前结点，然后遍历左子树，然后遍历右子树

二叉树的后续遍历是LRN，即先遍历左子树，然后遍历右子树，然后遍历当前结点

要想两种遍历正好相反，那么显然L为空或者R为空即可

### （4）二叉树的层次遍历 + C++中的栈和队列的基本用法

**从上到下，从左到右的层次遍历：**

用一个队列来实现这个层次遍历

```c++
//二叉树的结点定义
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x), left(NULL), right(NULL){}
}

//参数传递的是树的根结点
void tree(TreeNode* root){
    queue<TreeNode*> q;//一个队列
    q.push(root);//将根结点加入到队列的队尾
    while(q.size()){
        TreeNode* temp = q.front();
        q.pop();
        if(temp->left) q.push(temp->left);
        if(temp->right) q.push(temp->right);
        cout << temp->val;
    }
}
```

**从下到上，从右到左的层次遍历：**

用一个栈和一个队列来实现，将出队列的结点放到栈中就行了

```c++
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x): val(x), left(NULL), right(NULL){}
}

void tree(TreeNode* root){
    queue<TreeNode*> q;
    stack<TreeNode*> stk;
    q.push(root);
    while(q.size()){
        TreeNode* temp = q.front();
        stk.push(temp);//将队列头元素压入栈中
        q.pop();
        if(temp->left) q.push(temp->left);
        if(temp->right) q.push(temp->right);
        //cout << temp->val;
    }
    //将栈中的元素挨个弹出即可
    while(stk.size()){
        cout << stk.top()->val;
        stk.pop();
    }
}
```

**C++栈和队列的基本用法：**

```c++
queue<int> q;
q.push(val);//在队列尾加入一个元素
q.pop();//弹出队列头一个元素，但是不返回东西
q.front();//返回队列头元素，但是不删除
q.size();//队列元素的数量
q.empty();//如果队列为空则返回true

stack<int> stk;
stk.push(val);//压入一个元素
stk.pop();//删除栈顶元素
stk.top();//返回栈顶元素，但是不删除
stk.size();//返回栈中元素的个数
stk.empty();//如果栈为空，返回true
```

### （6）根据前序遍历和中序遍历构造二叉树

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240125201658643.png" alt="image-20240125201658643" style="zoom: 50%;" />

（1）前序遍历序列中第一个元素一定是根结点

（2）在中序序列中以这个根结点进行分界，根结点左边的元素是左子树的中序遍历序列，根结点右边的元素是右子树的中序遍历序列

（3）根据中序遍历中得到的左子树元素和右子树元素，分别递归构造即可

（4）难点在于数组中的下标处理

> 不过我觉得西交不会考代码实现

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    //提供的是两个数组序列
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size() == 0) return NULL;
        TreeNode *root = new TreeNode(preorder[0]);
        int numL = 0;//左子树结点个数
        int numR = 0;//右子树结点个数
        //找到根节点以及计算出左子树的结点的个数
        for(int i = 0; i < inorder.size(); i ++){
            if(inorder[i] == preorder[0]) break;
            numL ++;
        }
        numR = inorder.size() - numL - 1;
        int lPreStart = 1;//左子树的先序遍历的起点下标
        int lPreEnd = lPreStart + numL - 1;//左子树先序遍历的结尾下标
        int rPreStart = numL + 1;//右子树的先序遍历的起点下标
        int rPreEnd = rPreStart + numR - 1;//右子树的先序遍历的结尾下标
        
        int lInStart = 0;//左子树中序遍历的起点下标
        int lInEnd = lInStart + numL - 1;//左子树中序遍历的结尾下标
        int rInStart = numL + 1;//右子树中序遍历的起点下标
        int rInEnd = rInStart + numR - 1;//右子树中序遍历的结尾下标
        //递归构造左子树
        root->left = build(preorder, inorder, lPreStart, lPreEnd, lInStart, lInEnd);
        //递归构造右子树
        root->right = build(preorder, inorder, rPreStart, rPreEnd, rInStart, rInEnd);
        
        return root;
        
    }
    
    //找到子树的根节点并返回
    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int preStart, int preEnd, int inStart, int inEnd){
        if(preEnd < preStart) return NULL;
        
        TreeNode * root = new TreeNode(preorder[preStart]);
        int numL = 0;
        int numR = 0;
        for(int i = inStart; i < inorder.size(); i ++){
            if(inorder[i] == preorder[preStart]) break;
            numL ++;
        }
        numR = preEnd - preStart + 1 - numL - 1;
        int lPreStart = preStart + 1;//左子树的先序遍历的起点下标
        int lPreEnd = lPreStart + numL - 1;//左子树先序遍历的结尾下标
        int rPreStart = lPreEnd + 1;//右子树的先序遍历的起点下标
        int rPreEnd = rPreStart + numR - 1;//右子树的先序遍历的结尾下标
        
        int lInStart = inStart;//左子树中序遍历的起点下标
        int lInEnd = lInStart + numL - 1;//左子树中序遍历的结尾下标
        int rInStart = lInEnd + 2;//右子树中序遍历的起点下标
        int rInEnd = rInStart + numR - 1;//右子树中序遍历的结尾下标
        
        root->left = build(preorder, inorder, lPreStart, lPreEnd, lInStart, lInEnd);
        root->right = build(preorder, inorder, rPreStart, rPreEnd, rInStart, rInEnd);
        
        return root;
        
    }
};
```

### （7）判断二叉树是否是完全二叉树

将这个二叉树当作一个满二叉树进行层序遍历

如果遇到了空结点，看看后面是否还有正常的结点，如果有正常的结点，说明不是完全二叉树，如果全是空结点一直到结束，那这个就是一个完全二叉树

### （13）二叉树的最近公共祖先结点

从根结点开始判断根结点的两个子结点是否是p, q的公共祖先（判断的时候用dfs，分别可以遍历到两个结点就是ture）

如果左儿子是p，q的公共祖先，则递归到左儿子

如果右儿子是p，q的公共祖先，则递归到右儿子

如果两个儿子都不是公共祖先，则结束，此时的结点就是最近公共祖先



每次都要判断这个结点是否可以搜索到p，q的时候其实复杂度挺高的，因为判断的时候仍然是dfs，递归的时候也是dfs

这里可以用记忆化搜索进行优化，判断根结点的左右儿子是不是p，q的公共祖先的时候会用到一次dfs，此时可以记录dfs路径上每个结点是否可以搜索到p，q，dfs返回的时候进行赋值：

```cpp
unordered_map<TreeNode*, bool> f;

//验证子树是含有这两个结点之一
bool search(TreeNode* root, TreeNode* p, TreeNode* q)
{
    if(!root) return false;
    //记忆化搜索，记录每个子树的情况，避免重复搜索，如果这个结点之前已经记录了搜索着两个结点的情况，就不用继续向下搜索了，直接返回结果
    if(f.count(root)) return f[root];
    // if return true;
    return f[root] = search(root->left, p, q) || search(root->right, p, q) || root->val == p->val || root->val == q->val;
}

//下面进行递归就可以了，从根结点开始，如果左儿子结点是祖先结点，则答案在左子树，如果右儿子是祖先结点，则答案在右子树
```

### （15）满二叉树知道先序遍历序列求后续遍历

对于一个满二叉树的先序序列[A, B, C, D, E, F, G]

其中A一定是根结点，知道了A是根结点那么A的两颗子树的结点个数一定是一样的，因此BCD，EFG一定分别是两颗子树的结点

这样直接在这个数组上递归即可，A是根结点，其子树的结点相等，因此BCD一定是左子树的结点

递归进入BCD左子树，B是根结点，那B的左右两个子树的结点就分别是CD

递归进入C，C的两个子树为空，输出C

返回到BCD，然后递归进入B的右子树D的所有结点

递归进入D，D的两个子树为空，输出D

返回到BCD，输出B

返回到A根结点，然后遍历A的右子树

递归进入EFG即可

### （19）叶结点的带权路径长度和树的权

一个叶结点的带权路径长度是这个节点的权值乘以根节点到这个叶结点的路径长度，一颗树的带权路径长度是所有叶结点的带权路径长度之和

### （20）表达式树

一个中缀表示的计算顺序是唯一的，因此我们可以根据其计算顺序将其转换成一个表达式树，比如：`(x + y)  * ((x + y) / x)`

这个树需要满足：

1. 树的中序遍历的顺序应该与我们计算这个表达式的顺序是一样的
2. 这个树的分支结点都是运算符，叶子结点都是变量
3. 表达式树的后序遍历就是这个中缀表达式的后缀表达式形式，前缀遍历就是这个中缀表达式的前缀表达式形式

这道题目的中序遍历其实就是中缀表达式，但是这里需要处理一下括号问题，这道题目主要就是返回的时候带上括号，但是需要将结点分成叶结点，空结点，符号结点，根结点，这四种结点返回上一层的结果的时候带上括号的情况是不同的

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     string val；
 *     TreeNode *left;
 *     TreeNode *right;
 * };
 */
class Solution {
public:
    string expressionTree(TreeNode* root) {
        //根结点返回的时候不带左右括号
        return dfs(root->left) + root->val + dfs(root->right);
    }
    
    string dfs(TreeNode* root){
        //如果是空结点，不返回任何东西给上一层
        if(!root) return "";
        //如果是叶结点，不返回括号给上一层，只返回自己的值
        if(!root->left && !root->right) return root->val;
        
        //不是叶结点，那这个结点一定是一个符号，这个符号子树返回给上一层的时候带上左右两个括号
        return '(' + dfs(root->left) + root->val + dfs(root->right) + ')';
    }
};

```

**递归的关键在于，在假设子问题已经完成的情况下，当前问题怎么利用子问题的结果来完成自己的处理过程得到结果并返回给上一层利用**

**这道题目就假设左右子树已经得到了表达式，当前问题就是用自己结点的符号将两个子树（子问题）的结果拼在一起作为当前结果给上一层利用**

# 树和森林

## 二，大题

### （1）树的存储 + 树和二叉树和森林的互相转换 + 树的遍历

**树的顺序存储法：（双亲存储法）**

这种存储方式用一组连续的空间来存储树的结构，并且一个空间元素包括这个结点以及这个结点的父节点的下标：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241109095030864.png" alt="image-20241109095030864" style="zoom:67%;" />

这种存储方式可以很快找到这个结点的父节点，但是找这个结点的子结点的时候需要遍历整个结构

**树的链式存储法：（孩子兄弟存储法）**

这种存储方式一个结点包括两个指针域，一个指针域指向当前结点的左数第一个儿子结点，一个指针域指向当前结点的右兄弟结点：

```cpp
struct TreeNode{
	int val;
    TreeNode* firstChild;
    TreeNode* rightBrother;
    TreeNode(int x):val(x), firstChild(NULL), rightBrother(NULL){}
}
```

这样的存储结构可以抽象成一个邻接表：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241109095707281.png" alt="image-20241109095707281" style="zoom:50%;" />

**树和二叉树的转换：**

（1）树转换成一颗二叉树：

如果已知了一颗树，下面左侧，那么转换的二叉树满足：

1. 二叉树的根结点是树的根结点
2. 二叉树的每个结点的左儿子是树中每个结点的第一个儿子
3. 二叉树的每个结点的右儿子是树中每个结点的右兄弟

**所以其实可以看到树的左儿子有兄弟存储其实就是二叉树的二叉链表存储，只不过这里的二叉链表中两个指针域的名字变化了一下**

（2）二叉树转换成一颗树：

其实就是将二叉树的二叉链表结点中的两个指针域的名字改一下，左指针改成第一个儿子，右指针改成右兄弟，按照这种改法直接画出树的结果即可

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241109100119705.png" alt="image-20241109100119705" style="zoom:50%;" />

**森林，树，二叉树的互相转化：**

我们认为一个森林中的所有树的根结点之间互为兄弟结点，第一个树的根结点的右兄弟就是第二个树的根结点，那这样就非常简单了

（1）森林转换成二叉树

由于森林的存储就是按照上述临界链表的方式存储的，因此直接将结点的两个指针域的名字改为左儿子和右儿子就可以直接得到一个二叉树了：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241109101305537.png" alt="image-20241109101305537" style="zoom:50%;" />

（2）二叉树转换成森林

可以看到上述二叉树的根结点有右儿子，那显然这个二叉树就是由森林转换过来的，同上，还是直接将二叉树的左右儿子指针域改成第一个儿子，右兄弟即可

（3）二叉树与树的互相转化

上图中如果直接说了是二叉树和单个的树互相转换，那么这个树的根结点就没有右兄弟，转换成的二叉树就是根结点没有右儿子的二叉树，这里根据题意分析转换即可

**树的遍历：**

树的遍历只有先序遍历和后续遍历

树的先序遍历就是先遍历当前结点，然后再依次遍历儿子结点

树的后续遍历就是先依次遍历儿子结点，然后再遍历当前结点

如果根据树的结点的结构来分析的话：

**树的先序遍历：就是二叉树的先序遍历**

```cpp
void dfs(TreeNode* root){
    if(!root) return;
    //先便利当前结点
    root->val;
    //再遍历所有子树
    dfs(root->firstChild);
    //再遍历所有右兄弟
    dfs(root->rightBrother);
}
```

dfs函数的意义就是先遍历当前结点，再遍历所有子树，再遍历当前结点的所有右兄弟，结构与二叉树的先序遍历完全一样

**树的后序遍历：就是二叉树的中序遍历**

树的后续遍历就是先遍历完当前结点的所有子树，然后再遍历当前结点

```cpp
void dfs(TreeNode* root){
    if(!root) return;
    dfs(root->firstChild);
    root->val;
    //上面两行代码遍历完以当前结点作为根结点的子树
    //下面开始遍历当前结点的右兄弟结点
    //这里的整个函数的意义就是遍历完跟当前结点平齐的所有兄弟结点后返回给上一层自己的父节点
    dfs(root->rightBrother);
}
```

dfs函数的意义就是先遍历当前结点作为根结点的子树，然后再遍历其所有的右兄弟作为根结点的子树

代码的结构就是二叉树的中序遍历

### （6）根据树的层次序列和结点的度构造孩子兄弟链表

将这个树的层次序列放入两个队列中

A队列用来弹出根结点；B队列用来弹出子结点

A队列弹出一个元素a，B队列弹出a以及a的度数个结点元素分别是a的子结点，由此构建元素a的一个链表

就这样依次构造下去，A队列弹出结束的时候就构造完成了

# 哈夫曼树和哈夫曼编码

## 二，大题

### （1）带权路径长度 + 哈夫曼树的构造

一个叶结点的带权路径长度是这个节点的权值乘以根节点到这个叶结点的路径长度，一颗树的带权路径长度WPL是所有叶结点的带权路径长度之和

WPL最小的树称为哈夫曼树

**哈夫曼树的构造算法：**

Create(n):表示构造n个节点的可行解
1. 取出n个节点中的权值最小的两个节点a, b
2. 合并成一个节点z且a,b作为z的左右儿子节点
3. 去除a, b节点，加入节点z，变成n - 1个节点
4. 递归构造这n - 1个节点的可行解Create(n - 1)

**哈夫曼树的结构不唯一，但是带权路径长度一定是唯一的**

### （2）Huffman树的合并代价 + 合并有序链表代价

合并两个子树的代价是两个子树的根节点的权值和，合并所有子树的代价之和就是合并这颗树的代价，同时也是**这个树的所有非叶子结点的结点权值之和，一颗树的带权路径长度就是这颗树的所有叶子结点的带权路径长度之和，同时也是从所有零散的结点合并成这颗树的代价**

这道题目六个表分别作为六个结点，权值分别是10，35，40，50，60，200

合并两个有序表的代价其实就是两个有序表元素个数加起来 - 1（这个是一个结论，合并有序表），比如合并10和35，其最坏代价就是44，最好的情况根据有序链表合并算法需要比较Min(n, m)次

因此这道题目的最坏就是指在两两结点合并代价就是其权值相加的情况下，求总的代价最小，由于两两结点的权值相加作为结点的合并代价，因此这就是合并这棵树的代价，因此合并成一棵树的代价就是这个树的带权路径长度之和

要求带权路径长度之和最小也就是Huffman树的构造了

### （3）Huffman编码

**前缀编码：**

对某个字符集进行编码，要求字符集中任意字符的编码都不是其他字符的编码的前缀

比如字符串`aabccccdd`，可以用`a->01, b->10, c->110, d->0000`，因此这个字符串的编码就是：`01011011011011011000000000`，因为编码的方式是前缀编码，所以讲这个`01`串的解码过程就是唯一的

**如何得到这种前缀编码呢：**

直接构造一个含有4个叶子结点的二叉树，二叉树中结点的左分支是0，右分支是1，那么从根结点道叶子结点的路径就是这个叶子结点字符的编码，并且所有的字符编码都必然不是其他编码的前缀：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241110104313792.png" alt="image-20241110104313792" style="zoom:50%;" />

**对于一个确定的字符串，比如aabccccdd，怎样才能得到最短的编码长度呢**

（1）将每个字符作为叶结点，每个字符出现的次数作为权值，比如aabccccdd：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241110104703057.png" alt="image-20241110104703057" style="zoom:50%;" />

（2）总编码长度就是每个字符的编码长度乘这个字符出现的次数相加，也就是我们构造完了二叉编码树之后，叶子结点的路径长度乘这个叶子结点的权值相加，也就是这个二叉树的带权路径长度

（3）要求总的编码长度最小，那就是二叉树的带权路径长度最小，直接构造Huffman树即可





