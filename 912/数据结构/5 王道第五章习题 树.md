# 树的基本概念

## 选择

1. D

2. C

### **结点的度：**

结点的度就是一个结点拥有的子树的个数

### **树的度：**

树内各结点的度的最大值，也就是树中最多儿子结点的儿子个数

### **树的所有结点的度数之和与结点个数的关系：**

结点个数 - 1 = 树的所有度数之和，因为除了根结点之外每个结点都对应一个分支，一个分支就对应一个度

3. A

### **结点的路径长度：**

从根结点到这个结点的的路径上的所有的边的数目

### **树的路径长度：**

除叶结点之外，从根结点到其他所有结点的路径长度之和

4. A

### **树的高度（深度）：**

是树中结点的最大层数，根结点是第一层，具有n个结点的m叉树的最小高度是$

### **m叉树：**

每个结点可以挂的结点个数<=m个，也就是每个结点的儿子结点的个数<=m个

### **n个结点的m叉树的最小高度h：**

如果这个树的高度是h，那么如果想要高度h的树的结点个数最大的话，那显然每个结点都必须挂满m个子结点，第一层1个结点，第二层m个结点，第三层m^2个结点。。。。。这是一个等比数列，加起来得到高度为h的树的结点个数最多为：
$$
\frac{m^h - 1}{m - 1}
$$
同理，如果结点有n个，那肯定每层都必须挂满才能让总高度最小，所以就上上式 = n，反解出来得到最小高度为：
$$
h = log_m(n(m - 1) + 1)
$$

5. A

6. C

7. B

## 大题

### 2 树的总度数和结点个数的关系 + 叶结点的关系

这种题目就列出两个方程即可

（1）总度数 + 1 = 总结点个数

（2）总结点个数 - 度数不为零的结点的个数 = 叶结点个数 

### 3 树的总度数和结点个数关系 + 叶结点的关系

# 二叉树的概念

## 选择

### 二叉树的定义

二叉树就是每个结点至多只有两个子树的树，并且二叉树的子树有左右之分，次序不能颠倒，即二叉树是一颗有序树，如果将二叉树的左右结点颠倒，则是一颗不同的二叉树

并且二叉树可以为空树，并且二叉树哪怕一个结点只有一个儿子，这个儿子在左右不同的位置那也是一颗不同的二叉树

### 二叉树的叶结点和度 = 2的结点的个数关系

n0 = n2 + 1，n0是叶结点的个数，n2是度为2的结点的个数

这个问题还是列出两个方程，跟上面的类似，n1是度为1的结点的个数，n是总的结点个数：

（1）n = n1 + 2n2 + 1，结点个数与总度数的关系

（2）n = n0 + n1 + n2，总结点个数 - 度数不为零的结点的个数 = 叶结点个数 

### 满二叉树和完全二叉树的定义

![image-20241005214751957](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241005214751957.png)

满二叉树的每一层都堆满了结点，完全二叉树是每个结点编号都与满二叉树一致的二叉树，相当于对应高度的满二叉树最后一层去掉一些叶结点

### 满二叉树和完全二叉树的结点编号 + 上下取整符号

规定结点编号根结点为1，如果一个结点的编号是i，则其父节点的编号是$\lfloor i\rfloor$

> $\lfloor \rfloor$是下取整符号，即$\lfloor 4.9\rfloor = 4$，$\lceil \rceil$是上取整符号，$\lceil 4.9 \rceil = 5$，如果是一个整数，不管是向上还是向下取整结果都是数字本身

如果父节点是i，则左儿子是2i,  右儿子是2i + 1；如果一个完全二叉树的结点的编号为`x`，那么它的左儿子的结点的编号是`2x`，它的右儿子的节点的编号是`2x + 1`，满二叉树和完全二叉树具有一样的结点编号规律，注意这里的结点i不是叶结点

### 满二叉树和完全二叉树的高度

高度为h的满二叉树的结点个数是$2^h - 1$，结点个数为n的二叉树的高度是$log_2(n + 1)$，这根据满二叉树的特征利用等比数列可以推导出来

**完全二叉树的高度：**$ \lfloor log_2n \rfloor + 1$，`n`是完全二叉树结点的个数，下取整加一

> 完全二叉树每一层最左侧的结点的编号就是2的幂次方，它取对数加一就是它的深度，由于每一层最左侧的结点的编号分别以2的次幂递增，因此对于第`k`层的结点，最左侧的结点的编号为`2^(k - 1)`，对于第`k + 1`层的结点最左侧的编号是`2^(k)`，所以对于第`k`层的任意一个结点，他的编号都在`2^(k - 1) ~ 2^k`之间，结点的编号也就是结点的到根节点的结点的个数，所以第`k`层结点的编号取对数在`k - 1 ~ k`之间，向下取整就是`k - 1`，再加一就恰好是这一层的高度
>
> 因此如果一个完全二叉树的高度为`h`，那么最后一层的所有结点的编号取对数的范围都是[h - 1, h)，最后一个结点的编号为`n`，同时也是二叉树的结点的个数，因此`n`取对数下取整再加一就一定是高度`h`了

### （4）只有度为0和度为2的二叉树的形态

这种二叉树，结点个数最少是下面这种形态：

![image-20241016180131009](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241016180131009.png)

最多结点个数，那就是一个满二叉树

### （6）二叉树的总结点方程

这道题目还是考察下面两个方程：

（1）N = n1 + 2n2 + 1，树的总结点等于总结点的度 + 1，也就是分支数 + 1

（2）N = n0 + n1 + n2，数的总结点等于叶结点个数 + 度为1的结点的个数 + 度为2的结点的个数

因为2m + 2n2 + 1 = 2n，等式左边是奇数，右边是偶数，显然不可能

### （12）完全二叉树的叶结点问题（两种可能）

注意完全二叉树如果深度是h，则其叶结点可能出现在h层，也可能出现在h - 1层

这道题目得先算出完全二叉树的高度，然后算最后一层的结点个数

### （14）完全二叉树中度为1的结点的个数

要么是0个要么是1个，出现度为1的结点的完全二叉树只能是下面这种形状：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241016181941772.png" alt="image-20241016181941772" style="zoom:67%;" />

### （15）二叉树的存储结构 + 二叉树总结点方程

**顺序存储结构：**

顺序存储结构，就是用一个数组来存放整个二叉树的结点，二叉树的结点编号就是在数组中的下标

对于满二叉树和完全二叉树用这种方式存储非常方便，但是对于普通二叉树则需要补充一些不存在的结点到数组中来满足实际结点数组下标就是对应的完全二叉树中结点下标的条件

因此普通二叉树存放的时候会造成空间的浪费

**链式存储结构：**

就是用下面链表结构存储：

```cpp
typedef struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
}
```

不再多说

这道题目，所谓二叉链就是上述链式存储结构

空指针个数就是2n0 + n1的个数

而根据二叉树结点方程：

（1）N = n1 + 2n2 + 1，树的总结点等于总结点的度 + 1，也就是分支数 + 1

（2）N = n0 + n1 + n2，数的总结点等于叶结点个数 + 度为1的结点的个数 + 度为2的结点的个数

得到n0 = n2 + 1

所以空结点个数就是2n2 + 2 + n1 = n + 1

### （17）完全二叉树的结点编号和其所在深度的关系

设结点编号为p，其所在高度为h，则有：
$$
2^{h -1} \le p <2^h
$$
因此log2p下取整之后其结果一定是h - 1

### （22）二叉树的顺序存储+题目的理解

这道题目关键是理解对任意二叉树都可以存放，所以顺序存储应该开到最大空间，即31个存储单元，而不是16个存储单元

## 大题

### （1）完全二叉树的高度

这种涉及结点的度的题目一律先列出两个方程：

（1）n0 + n1 + n2 = n

（2）n1 + 2n2 + 1 = n

从而得到n2 + 1 = n0，因为n1 = 1从而得到n = 2n2 = 2(n0 - 1)

**完全二叉树的高度，结点个数下取整加一**

### （4）满m叉树的结点编号问题

在满m叉树中，如果一个结点的编号是i，那么其第一个子结点的编号为
$$
(i - 1)*m + 2
$$
如果一个结点的编号是j，那么其父节点的编号就是：
$$
\lfloor \frac{j - 2}{m} \rfloor  + 1
$$


如果一个结点的编号是i，那么其第k个子结点的编号为：
$$
(i - 1)*m + 1 + k
$$
上面三个结论记住

第四问，当这个结点不是双亲结点的第m个子结点的时候才能有右兄弟

这个结点的父节点的编号是$\lfloor \frac{i - 2}{m} \rfloor  + 1$，这个父节点的第m个结点编号是：
$$
\lfloor \frac{i - 2}{m} \rfloor * m + 1 + m
$$
这个编号要大于i：
$$
\lfloor \frac{i - 2}{m} \rfloor * m + 1 + m > i
$$

# 二叉树的遍历

## 一，选择

## 二，大题

### （1）二叉树的遍历

二叉树的先序遍历是NLR，即先遍历当前结点，然后遍历左子树，然后遍历右子树

二叉树的后续遍历是LRN，即先遍历左子树，然后遍历右子树，然后遍历当前结点

要想两种遍历正好相反，那么显然L为空或者R为空即可

### （4）二叉树的层次遍历 + C++中的栈和队列的基本用法

**从上到下，从左到右的层次遍历：**

用一个队列来实现这个层次遍历

```c++
//二叉树的结点定义
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x), left(NULL), right(NULL){}
}

//参数传递的是树的根结点
void tree(TreeNode* root){
    queue<TreeNode*> q;//一个队列
    q.push(root);//将根结点加入到队列的队尾
    while(q.size()){
        TreeNode* temp = q.front();
        q.pop();
        if(temp->left) q.push(temp->left);
        if(temp->right) q.push(temp->right);
        cout << temp->val;
    }
}
```

**从下到上，从右到左的层次遍历：**

用一个栈和一个队列来实现，将出队列的结点放到栈中就行了

```c++
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x): val(x), left(NULL), right(NULL){}
}

void tree(TreeNode* root){
    queue<TreeNode*> q;
    stack<TreeNode*> stk;
    q.push(root);
    while(q.size()){
        TreeNode* temp = q.front();
        stk.push(temp);//将队列头元素压入栈中
        q.pop();
        if(temp->left) q.push(temp->left);
        if(temp->right) q.push(temp->right);
        //cout << temp->val;
    }
    //将栈中的元素挨个弹出即可
    while(stk.size()){
        cout << stk.top()->val;
        stk.pop();
    }
}
```

**C++栈和队列的基本用法：**

```c++
queue<int> q;
q.push(val);//在队列尾加入一个元素
q.pop();//弹出队列头一个元素，但是不返回东西
q.front();//返回队列头元素，但是不删除
q.size();//队列元素的数量
q.empty();//如果队列为空则返回true

stack<int> stk;
stk.push(val);//压入一个元素
stk.pop();//删除栈顶元素
stk.top();//返回栈顶元素，但是不删除
stk.size();//返回栈中元素的个数
stk.empty();//如果栈为空，返回true
```

### （6）根据前序遍历和中序遍历构造二叉树

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240125201658643.png" alt="image-20240125201658643" style="zoom: 50%;" />

（1）前序遍历序列中第一个元素一定是根结点

（2）在中序序列中以这个根结点进行分界，根结点左边的元素是左子树的中序遍历序列，根结点右边的元素是右子树的中序遍历序列

（3）根据中序遍历中得到的左子树元素和右子树元素，分别递归构造即可

（4）难点在于数组中的下标处理

> 不过我觉得西交不会考代码实现

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    //提供的是两个数组序列
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size() == 0) return NULL;
        TreeNode *root = new TreeNode(preorder[0]);
        int numL = 0;//左子树结点个数
        int numR = 0;//右子树结点个数
        //找到根节点以及计算出左子树的结点的个数
        for(int i = 0; i < inorder.size(); i ++){
            if(inorder[i] == preorder[0]) break;
            numL ++;
        }
        numR = inorder.size() - numL - 1;
        int lPreStart = 1;//左子树的先序遍历的起点下标
        int lPreEnd = lPreStart + numL - 1;//左子树先序遍历的结尾下标
        int rPreStart = numL + 1;//右子树的先序遍历的起点下标
        int rPreEnd = rPreStart + numR - 1;//右子树的先序遍历的结尾下标
        
        int lInStart = 0;//左子树中序遍历的起点下标
        int lInEnd = lInStart + numL - 1;//左子树中序遍历的结尾下标
        int rInStart = numL + 1;//右子树中序遍历的起点下标
        int rInEnd = rInStart + numR - 1;//右子树中序遍历的结尾下标
        //递归构造左子树
        root->left = build(preorder, inorder, lPreStart, lPreEnd, lInStart, lInEnd);
        //递归构造右子树
        root->right = build(preorder, inorder, rPreStart, rPreEnd, rInStart, rInEnd);
        
        return root;
        
    }
    
    //找到子树的根节点并返回
    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int preStart, int preEnd, int inStart, int inEnd){
        if(preEnd < preStart) return NULL;
        
        TreeNode * root = new TreeNode(preorder[preStart]);
        int numL = 0;
        int numR = 0;
        for(int i = inStart; i < inorder.size(); i ++){
            if(inorder[i] == preorder[preStart]) break;
            numL ++;
        }
        numR = preEnd - preStart + 1 - numL - 1;
        int lPreStart = preStart + 1;//左子树的先序遍历的起点下标
        int lPreEnd = lPreStart + numL - 1;//左子树先序遍历的结尾下标
        int rPreStart = lPreEnd + 1;//右子树的先序遍历的起点下标
        int rPreEnd = rPreStart + numR - 1;//右子树的先序遍历的结尾下标
        
        int lInStart = inStart;//左子树中序遍历的起点下标
        int lInEnd = lInStart + numL - 1;//左子树中序遍历的结尾下标
        int rInStart = lInEnd + 2;//右子树中序遍历的起点下标
        int rInEnd = rInStart + numR - 1;//右子树中序遍历的结尾下标
        
        root->left = build(preorder, inorder, lPreStart, lPreEnd, lInStart, lInEnd);
        root->right = build(preorder, inorder, rPreStart, rPreEnd, rInStart, rInEnd);
        
        return root;
        
    }
};
```

### （7）判断二叉树是否是完全二叉树

将这个二叉树当作一个满二叉树进行层序遍历

如果遇到了空结点，看看后面是否还有正常的结点，如果有正常的结点，说明不是完全二叉树，如果全是空结点一直到结束，那这个就是一个完全二叉树

### （13）二叉树的最近公共祖先结点

从根结点开始判断根结点的两个子结点是否是p, q的公共祖先（判断的时候用dfs，分别可以遍历到两个结点就是ture）

如果左儿子是p，q的公共祖先，则递归到左儿子

如果右儿子是p，q的公共祖先，则递归到右儿子

如果两个儿子都不是公共祖先，则结束，此时的结点就是最近公共祖先



每次都要判断这个结点是否可以搜索到p，q的时候其实复杂度挺高的，因为判断的时候仍然是dfs，递归的时候也是dfs

这里可以用记忆化搜索进行优化，判断根结点的左右儿子是不是p，q的公共祖先的时候会用到一次dfs，此时可以记录dfs路径上每个结点是否可以搜索到p，q，dfs返回的时候进行赋值：

```cpp
unordered_map<TreeNode*, bool> f;

//验证子树是含有这两个结点之一
bool search(TreeNode* root, TreeNode* p, TreeNode* q)
{
    if(!root) return false;
    //记忆化搜索，记录每个子树的情况，避免重复搜索，如果这个结点之前已经记录了搜索着两个结点的情况，就不用继续向下搜索了，直接返回结果
    if(f.count(root)) return f[root];
    // if return true;
    return f[root] = search(root->left, p, q) || search(root->right, p, q) || root->val == p->val || root->val == q->val;
}

//下面进行递归就可以了，从根结点开始，如果左儿子结点是祖先结点，则答案在左子树，如果右儿子是祖先结点，则答案在右子树
```



