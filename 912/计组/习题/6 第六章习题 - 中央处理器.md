# 6 第六章习题 - 中央处理器

## eg 6.1 单周期CPU指令的时延计算

![image-20241007160246083](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241007160246083.png)

单周期CPU的指令周期等于时钟周期，并且由于每条指令都是一个时钟周期执行完毕，所以单周期的时钟周期就是执行时间最长的那条指令的时延

lw指令：
$$
T = t_{cpq} + 2t_{mem} + t_{RFread} + t_{ALU} + t_{mux} + t_{RFsetup}
$$
因此一条指令的时钟周期就是：
$$
T =  = 30 + 2*250 + 150 + 200 + 25 + 20 = 925ps
$$
那么100条指令的执行时间就是：
$$
100 * 925ps = 92.5ns
$$

## eg 6.2 多周期分散互联结构的CPU指令执行流程图

![image-20241012153943330](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241012153943330.png)

**多周期分散互联结构的CPU前两个时钟周期执行的操作是一样的：**

![image-20241012154143334](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241012154143334.png)

**第三个时钟周期进行ALU操作：**

![image-20241012154212322](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241012154212322.png)

这里的ALUSrcA = 1表示临时寄存器A中的数作为ALU的第一个操作数（A端操作数）

ALUSrcB = 00表示临时寄存器B中的数作为ALU的第二个操作数（B端操作数）

而ALUOp是MCU产生发送到ALU CU的ALU操作信号；当ALUOp = 0X的时候ALU只有add 和sub两种形式；当ALUOp = 1X的时候此时ALU的操作取决于R型指令中的Func字段和ALU CU产生的ALUCtrl控制信号

ALUCtrl是ALU CU产生的ALU控制信号，其与指令中的Func字段一起控制ALU的具体功能；这里为000就是与操作

**第四个时钟周期将数据写入寄存器堆中：**

![image-20241012154620086](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241012154620086.png)

MemtoReg = 0这个控制信号表示写入寄存器堆中的数据来自ALUOut

RegDst = 1表示目的寄存器的地址来自IR[15 - 11]

RegWr表示寄存器写有效

## eg 6.3 多周期分散互联数据通路的CPU指令时延计算

![image-20241012154740001](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241012154740001.png)

首先，我们得确定一个时钟周期的时间，根据表6.7：

![image-20241012155112024](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241012155112024.png)

虽然多周期数据通路中的部件可以在一个指令周期中服务不同的指令而执行不同的功能，但是由于部件也是由时钟信号控制的，所以在一个时钟周期中也只能执行一个动作，因此时钟周期应该取所有部件操作的最大值，即250ps

load指令：5个时钟周期

store指令：4个时钟周期

R指令：4个时钟周期

分支指令：3个时钟周期

![image-20241012160733955](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241012160733955.png)

所以总的执行时间：

![image-20241012160746283](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241012160746283.png)

采用多周期设计方案程序执行总时间更长了，这是因为时钟周期发生了变化，采用了时延最高的部件

## eg 6.4 流水线CPU的时钟周期选择

![image-20241018155130586](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241018155130586.png)

单周期CPU的指令周期等于时钟周期，保证最慢的指令也可以执行完，因此时钟周期选择的是800ps

流水线CPU的时钟周期等于每一级的操作时间，为了保证各级的时间一样，并且要满足最慢的流水级，其选择的是200ps

## 6.1 多周期CPU的数据通路分类

![image-20241109080410794](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241109080410794.png)

先理解一下单周期CPU，单周期CPU即所有指令的执行都只在一个时钟周期中结束，因此时钟周期的长度与执行最慢的指令周期一样，那执行时间短的指令的时钟周期也会强制被延长，因此就会造成时间的浪费

而多周期CPU，即一条指令的执行被划分为多个时钟周期，一个指令包括多个操作，比如取值，寄存器读写，或者ALU操作，这里认定一个时钟周期进行一次操作，时钟周期的宽度以最复杂的操作为标准，这样多周期CPU的每条指令的执行时间会更加灵活一些，时间的浪费会更少

单周期CPU不可能有部件共享，所谓部件共享就是在一个指令执行周期一个部件可以被多次使用，单周期CPU因为指令执行周期等于时钟周期，而一个部件在一个时钟周期中只能执行一次操作，因此一个部件在单周期CPU的一个指令执行周期中也只能进行一次操作，所以在单周期CPU中如果一个指令周期需要多次用到某个部件那就必须进行部件冗余

而对于**多周期CPU，因为一个指令周期包含多个时钟周期，因此一个部件完全可以在两个不同的时钟周期中分别执行操作，可以实现部件共享**，因此多周期CPU可以去掉单周期CPU中的冗余部件实现部件共享；同时由于多周期CPU的下一次时钟周期必须用到上一次时钟周期的数据，因此上一次时钟周期得到的数据必须进行缓存，如果不缓存，这些数据仍然在数据线上，那么下一次时钟周期万一制造这些数据的部件进行了别的操作，而这些数据又刚好被别的部件使用，这就会导致周期竞争，数据使用错误，因此这就**需要增加一些临时的寄存器来存放上一次操作得到的数据**

以上就是单周期CPU和多周期CPU的最大的几个区别了

多周期CPU又可以分为分散互联结构，单总线结构，双总线结构，三总线结构。。。

所谓分散互联结构，就是多周期CPU的各个部件之间直连，这种方式数据传送快，不存在数据竞争，指令执行速度就很快，但是显然互相连来连去结构就比较混乱

单总线结构，部件之间通过总线连接在一起，这种结构非常规整，但是由于数据传递的时候会出现总线的竞争，因此指令执行速度肯定比不上分散互联结构

双总线结构，显然多出来的一条总线就是未来分担单总线中的数据压力的，这样肯定会加快指令的执行速度，减少总线竞争

三总线结构，显然会进一步增加指令执行速度减少竞争，但是三总线结构会导致硬件的复杂度上升

## 6.3 简单CPU的数据通路简略图

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241109085811872.png" alt="image-20241109085811872" style="zoom:50%;" />

**（1）**

这道题目先看主存有a，c与主存直连，那显然a就是MDR，c是MAR

d有+1肯定就是PC了

b的一部分传递给PC，并且主存中的数据传给b，显然b就是指令寄存器了，指令一开始是存放在主存M中的，然后取值到b，IR中

这相当于是一个简略版的CPU数据通路，有点像是分散互联，但是又多了MAR和MDR

**（2）**

这里的寄存器传输语言其实就是课本上的那一堆指令在不同数据通路的执行完整流程的东西

这里看着情况写即可

取值

1. MAR <- (PC)
2. MDR <- M[MAR]
3. IR <- (MDR)，PC = (PC) + 1（注意PC修正始终是到了IR之后再进行修正）
4. 操作控制器 <- (IR)

上面的寄存器传输语言中，箭头右边括号表示部件中的内容，箭头左边不用括号，箭头指向就表示直接将数据放入到左边的部件中

**（3）**

这里有一个操作数是AC累加器，那肯定是累加指令，add x，这里的x是操作数的地址，其RTL如下：

MAR <- x，x作为指令码中的地址部分传递到MAR中

MDR <- M[MAR]，从主存中取数到MDR

AC <- (MDR) + (AC)，ALU进行计算

> 这道题就是仿照课本的多周期CPU写RTL即可，只要背会了多周期CPU的RTL代码就很简单了

## 6.6 双总线数据通路的结构以及指令执行流程

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241110081620483.png" alt="image-20241110081620483" style="zoom:50%;" />



<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241110081641334.png" alt="image-20241110081641334" style="zoom: 50%;" />

（1）

**这里默认指令是单字长**

PC中存放指令的地址，由于指令存储器IM的容量为16384 = 2^14，因此PC的长度是14位

指令寄存器IR中存放指令，因此是指令的宽度，由于指令存储器中的字长是18位，因此IR长度这里是18位

AC0和AC1进行操作数的操作，跟数据的长度一样，并且寄存器R0~R3中存放的也是数据，这里都就是16位

IAR和PC的长度一样，是14位

IDR中存放指令，因此是18位

DAR中存放数据的地址，与数据存储器DM的容量65536 = 2^16有关，这里就是16位

DDR中存放数据，因此是16位

（2）

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241110082650336.png" alt="image-20241110082650336" style="zoom:50%;" />



<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241110082702036.png" alt="image-20241110082702036" style="zoom:50%;" />

这道题目考的就是双总线的指令执行完整的周期描述，用课本上的RTL语言描述，还得加上控制信号

**（1）取值阶段：**

```cpp
IAR <- (PC); IARIn, PCOut 	(PCOut是PC输出总线有效信号, IAR写是IAR写有效信号)
IDR <- IM[IAR]; IMOut, IDRIn 	(IM读是IM读有效信号,或者说是输出总线有效信号, IDR写是IDR写有效信号)
PC <- (PC) + 1; PCIn, PC + 1 	(PCIn是PC写有效信号，PC + 1这里简略了ALU的操作，直接表示PC + 1的控制信号)
IR <- IDR; IDROut, IRIn 	(IDROut是IDR输出总线有效信号，IRIn是IR写有效信号)
```

**（2）执行阶段：**

这里的指令执行，首先得先取出操作数，然后进行相加

首先计算出第二个操作数的地址：

```cpp
ALU_A <- (Ri); 		RiOut
ALU_B <- IR[X]; 	IROut	
AC1 <- (ALU_C); 		Add, AC1In
```

> 这里的运算器不需要读写控制信号，并且可以直接用Add控制命令代替一大坨的课本上的控制命令，放入操作数，然后运算结果写回寄存器中算是一组

然后取出第二个操作数：

```cpp
DAR <- (AC1);	AC1Out, MARIn
DDR <- DM[DAR];		DMOut, DDRIn
```

> 对于普通的部件来说，就两个控制信号，一个读有效，一个写有效

最后进行加法计算

```cpp
ALU_A <- (AC0);		AC0Out
ALU_B <- (DDR);		DDROut
AC1 <- (ALU_C);		Add, AC1In
```

> 这种运算操作就是三条指令，两条分别放入操作数ALU_A, ALU_B，一条省略了加法运算，直接将ALU_C放入结果寄存器中

## 6.7 时钟周期，主频，CPU执行时间，CPI，MIPS

![image-20241110091002256](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241110091002256.png)

**（1）**

> 先整理一下各种单位：
>
> CPI：执行一条指令所需的时钟周期数
>
> IPS：每秒执行多少条指令
>
> MIPS：每秒执行多少百万条指令，这是一个在IPS上扩大一百万倍的单位
>
> CPU的时钟周期：一个时钟脉冲的时间
>
> 主频：CPU中1s中的时钟周期的个数，也就是时钟周期的倒数
>
> CPU的执行时间：运行一个程序所需的时间

这里我们只要算出平均CPI就得到了结果了，当然也可以直接算出所有指令执行的平均时间，然后直接取倒数，不过这里还是先算出每条指令所需的时钟周期数，因为第二问需要使用

存取：$\frac{0.6\mu s}{\frac{1}{4M}} = 2.4个时钟周期$

加减比较转移：$\frac{0.8}{\frac{1}{4}} = 3.2个时钟周期$

乘除：$\frac{10}{\frac{1}{4}} = 40个时钟周期$

其他：$\frac{1.4}{\frac{1}{4}} = 5.6个时钟周期$

平均：$2.4 * 0.35 + 3.2 * 0.5 + 40 * 0.05 + 5.6 * 0.1 = 5$

> 只要能算出平均CPI就行，平均CPI就是每条指令的CPI乘自己的频度加起来，也就是求一个期望

平均一条指令执行需要5个时钟周期，也就是$5 * \frac{1}{4} = 1.25\mu s$

因此MIPS = $\frac{1}{1.25}$ = 0.8MIPS

**（2）**

虽然CPU的主频发生了变化，但是指令的平均时钟周期是不发生变化的

因此一条指令所需的时间是$5 * \frac{1}{6} = \frac{5}{6} \mu s$

因此$MIPS = \frac{1}{\frac{5}{6}} = 1.2$MIPS

## 6.15 单总线CPU的数据通路图和指令执行流程

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241111083848529.png" alt="image-20241111083848529" style="zoom: 33%;" />

**（1）**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241111084557546.png" alt="image-20241111084557546" style="zoom: 33%;" />

> 画这种图主要注意下面几点：
>
> （1）几乎所有的部件都会与总线直接相连（这里除了ALU，其他所有部件都与总线相连）
>
> （2）注意单箭头和双箭头，这里的单双箭头表示读或者可以读写
>
> （3）顺便看图画出功能控制信号即可

**（2）**

SUB (R0), R3，源操作数的地址在R0中，目的操作数的在R3中，这里用目的操作数减去源操作数之后结果放在目的操作数地址中

这里是单总线的指令流程，一个指令周期包含很多个的时钟周期，这里分阶段

**（1）取指阶段：**

```
(PC) -> MAR		PCOut, MARIn
```

```
M[MAR] -> MDR		1->R, MDRIn
```

```
(MDR) -> IR		MDROut, IRIn
```

```
(PC) + 1 -> PC		+1
```

**（2）译码和读寄存器阶段：**

```
(R0) -> MAR		R0Out, MARIn
```
```
(R3) -> C		R3Out, CIn
```

> 这里是目的操作数减去源操作数，因此R3应该放在C中

**（3）指令执行阶段：**

```
M[MAR] -> MDR		1->R, MDRIn
```

```
(MDR) -> D		MDROut, DIn
```

```
(C) - (D) -> R3		-, R3In, V
```

第三问已经将所有的控制信号标在右边了，如果画出指令执行流程框图就是：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241111162353736.png" alt="image-20241111162353736" style="zoom:50%;" />

就是纯纯仿照课本上的单周期的指令流程，这里主要注意一下几点：

（1）取指就是固定的，这里不同多说

（2）接着译码，读寄存器，注意谁放到源操作数A中（这道题目是C），谁放到目的操作数B（这道题目是D）中要根据题中的指令功能描述来做

（3）指令执行，反正就是先放好源操作数，在放好目的操作数，然后进行ALU运算

（4）一般单周期就是用到一次总线传输一次数据，就认为是一个时钟周期

## 6.19 多周期数据通路的特点

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241111163808225.png" alt="image-20241111163808225" style="zoom:50%;" />

这个题其实有点傻逼，主要他想考的是多周期数据通路的特点，即将一个指令周期划分为不同的阶段，每个阶段都有一些微操作，一个阶段的时间与一个时钟周期的时间相等，因此各个阶段的最长时间设置为一个时钟周期时间

比如在分散互联结构的CPU中，一个阶段就对应一个时钟周期，当然一个时钟周期，或者说一个阶段可以有多个微操作，以lw指令为例，包括取指，译码读寄存器，指令执行，读寄存器或存储器，读寄存器或存储器，一共五个阶段，需要五个时钟周期，显然每个时钟周期的微操作就多一些

但是在单总线结构的CPU中，阶段的划分没有那么明显，只能说用了一次总线传递一次数据就花了一个时钟周期，单单是取指这个过程就用了4次时钟周期，这里每个时钟周期就只对应一个微操作

CPI就是指令含有的时钟周期的个数，这题怎么问，那就怎么答

（1）提高CPI，比如就是变成单总线，一个指令所含有的时钟周期巨多，但是每个时钟周期就只有1次微操作，那此时时钟周期就可以变短一点，提高处理器的主频

（2）较少CPI，比如变成分散互联，最多的时钟周期指令lw也只含有5个时钟周期，此时时钟周期降低了即CPI降低了，但是每个时钟周期需要进行的微操作就多了，因此主频就降低了
