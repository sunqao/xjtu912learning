# 第二章习题

## 2.5

![image-20240813175916611](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240813175916611.png)

ASCII是7位，加上一位的校验位，所以是8位，因此主存中按照字节编址更加方便（如果按照字编址，那么一个字节的ASCII码的地址如果在字的非地址字节位置处那么这个ASCII码就不是很好取）

字长是字节的2， 4， 8倍，因此31位显然不合理，指令字长一般与机器字长和或字节长度具有整数倍的关系，这里取12位显然不合适

## 2.6

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240814170639544.png" alt="image-20240814170639544" style="zoom: 50%;" />

**（1）**这里需要得到下一条指令的地址，显然就得使用跳转指令，由于下一条指令的地址在存储单元中，所以这里就使用存储器间接寻址，设计指令如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240814171216976.png" alt="image-20240814171216976" style="zoom:67%;" />

上图中的I表示间接寻址的标志，K是子程序的第一个存储单元的地址

**（2）**可以利用约定好的寄存器或者主存单元进行参数传递

**（3）**这种调用方法是可以实现子程序嵌套，因此子程序嵌套就是一个子程序调用另一个子程序，只需要把源程序的返回地址放到被调用子程序的开头即可

**（4）**不能用于子程序的递归调用，即自己调用自己，因为一个程序A被B调用，那么A的第一个单元放的就是B的返回地址，如果A再调用自己，那么A的第一个存储单元位置就得放入上一次调用它的程序的返回地址，这样就得将A调用A时的返回地址覆盖B调用A时的返回地址，这样A的第一个存储单元内容就会被破坏，显然是不行的

用堆栈当然可以，因为堆栈是先进后出的结构，可以实现子程序的递归调用

## 2.7

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240814172101391.png" alt="image-20240814172101391" style="zoom:67%;" />

这里的操作码扩展，一般指的就是等长的扩展

**首先是5条三地址指令：**

```
000 xxx yyy zzz 
001 xxx yyy zzz 
010 xxx yyy zzz 
011 xxx yyy zzz 
100 xxx yyy zzz 
```

剩下三条表示不再是三地址指令

**然后是8条二地址指令：**

高三位用101表示是二地址指令，次三位一共8种

```
101 (000 ~ 111) yyy zzz
```

**然后是120条单地址指令：**

高三位的110表示是单地址指令，次三位以及再次三位各自有8种，一共64条

```
110 (000 ~ 111) (000 ~ 111) zzz
```

当然不够，此时得高三位用111，然后对应次三位以及再次三位的一部分作为单地址指令，还缺56条，那就用中间6位形成的前56条

```
111 (000 000 ~ 110 111) zzz

等价于：
111 (000 ~ 110) (000 ~ 111) zzz 7 * 8 = 56
```

**最后是60条零地址指令：**

高三位很显然得用111，但是中间的六位被单地址占用了56条剩下8条，然后最低三位可以形成8种，零地址一共可以有64种指令，我们取60条作为零地址，剩下四条冗余备用

```
111 (111 000 ~ 111 110) (000 ~ 111) 7 * 8 = 56
111 111 111 (000 ~ 011) 4种
上面有60条零地址
还剩下：
111 111 111 (100 ~ 111) 4种，作为备用
```

**当规定好某种指令的操作码的位数之后都是操作码从小到大变换作为这个指令不同的类型，然后操作码的剩余部分提供给下一种指令**

比如这题种三地址操作码有3位，那么就是最高位的前5个作为三地址，剩下的101，110，111作为后面的指令使用

然后是两地址，操作码有6位，前三位只能从101，110，111开始取，从小的开始，前三位就取101，然后次三位就是000 ~ 111刚好9条

然后是一地址，操作码有9位，前三位就只能从110开始取了，中间六位取满一共64条接着再从111开始，中间六位从小到大取56条，等价于次三位取前7条，次次三位取满

最后零地址，操作码12位，前三位显然是111，然后中间六位被一地址取了前56个，因此零地址只能取后面的8个，仍然是从小到大，先取中间六位的前7个，然后最后三位取满，接着中间六位取111 111，再取最后三位前四个，就得到了60条了

