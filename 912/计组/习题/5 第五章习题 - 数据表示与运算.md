# 5 第五章习题 - 数据表示与运算

![image-20241018174338712](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241018174338712.png)

## 5.12 定点数的原码补码的范围

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241018174411082.png" alt="image-20241018174411082" style="zoom: 67%;" />

### **无符号整数**

无符号整数，就是16位二进制全是数的大小，没有符号位表示范围：
$$
0 \le a \le2^{16} -1
$$
只有说了无符号的时候第一位才不是符号位，其他的表示方法第一位统一就是符号位

### **原码定点小数**

**数的真值：**

就是一个正负号 + 数的书面书写方式，比如下图的实例第一行，就是二进制的真值

而机器数就是在计算机中的表示，用0，1表示符号位

**原码表示：**

原码表示的定点小数，原码其实就是比真值多了一个符号位

注意定点表示法只能表示纯小数或者纯整数，对于定点小数其默认小数点在符号位之后如下：

![image-20241018180309419](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241018180309419.png)

其范围：
$$
-(1 - 2^{-15})[1,111111111111111] \le a \le(1 - 2^{-15})[0,111111111111111]
$$
上面的符号位与数据位为了区分用逗号隔开，当然在计算机中显然没有逗号，只是约定小数点在符号位后面

### **补码定点小数**

定点小数的补码也还是负数除了符号位按位取反加一，正数不变，-0当作最小的数：
$$
-1[1,000000000000000] \le a \le (1 - 2^{-15})[0,111111111111111]
$$

### 原码定点整数

原码定点整数就是带符号的整数，其范围：
$$
-(2^{15} - 1) [1,111111111111111]\le a \le (2^{15} - 1) [0,111111111111111]
$$

### 补码定点整数

补码定点整数就是补码整数，其范围：
$$
-2^{15}[1,000000000000000] \le a \le (2^{15} - 1) [0,111111111111111]
$$

> 这种题目记住几个结论
>
> （1）一律用2的幂表示
>
> （2）原码对称，补码不对称，补码将原码中的-0当作了最小的一个数

## 5.17 补码加减法 + 溢出处理（直接用双符号位运算）

**（1）**

正常计算

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025183443145.png" alt="image-20241025183443145" style="zoom:67%;" />

**（2）**

这道题目是负溢出

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025183542809.png" alt="image-20241025183542809" style="zoom:50%;" />

当计算出溢出的时候，需要改成双符号位再计算一次，双符号位就是在原来的符号位多加一位即可：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025184232895.png" alt="image-20241025184232895" style="zoom: 50%;" />

 **（3）**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025185247362.png" alt="image-20241025185247362" style="zoom:67%;" />

**（4）**

正常计算即可，这种肯定不会发生溢出

![image-20241025185316790](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025185316790.png)

> 这种计算难点是溢出后怎么得到真值，判断可能出现溢出的运算后（正数加正数，负数加负数），直接用双符号位运算，然后根据双符号位运算的结果来判断溢出，以及得到真值
>
> 另外，最后的结果必须是真值

## 5.18 原码一位乘 + 补码一位乘 + 补码两位乘 

![image-20241025190455257](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025190455257.png)

就只写第一问，第二问跟第一问一样

**（1）**

**原码一位乘：**

![image-20241028213737028](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028213737028.png)

**补码一位乘：**

![img](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/eff826d814e3aa6eefa13f5fd6bd7140.jpg)

**补码两位乘：**

![image-20241029212716683](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241029212716683.png)

## 5.19 原码加减交替除（原码恢复除）

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104182354466.png" alt="image-20241104182354466" style="zoom:50%;" />

这里只做第一问，剩下的都是一样的

**（1）**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/ca77366bcadc233e96d5bca85f425913.jpg" alt="img" style="zoom:67%;" />

## 5.29 浮点数的规格化表示及其范围

![image-20241106172921778](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106172921778.png)

**（1）**

这个浮点数的格式如下所示：

![image-20241106173146004](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106173146004.png)

这里阶码是原码，并且尾数也是原码

**对于正数来讲：**

最大情况时阶码最大，并且尾数也是最大，此时浮点数乘起来才是最大，因此最大为：
$$
2^{2^5 - 1} * (1 - 2^{-9})
$$
最小情况时阶码应该最小，并且尾数也是最小，由于阶码不改变正负情况，因此阶码最小应该是负数：
$$
2^{1 - 2^5} * 2^{-9}
$$
**对于负数来讲：**

最大情况，由于阶码充当的是一个比例因子，不改变正负，所以阶码应该最小，让负数的比例因子最小，这样才能保证负数最大：
$$
2^{1 - 2^5} * (-2^{-9})
$$
最小情况，由于是负数，因此要求阶码所决定的比例因子和尾数的绝对值都应该最大才行：
$$
2^{2^5 - 1}*(-(1 - 2^{-9}))
$$
**（2）**

规格化要求尾数的原码的第一位必须是有效位1，因此对补码的表示就会产生影响

先看阶码部分，阶码用移码表示，**移码表示就是和补码一一对应的**，真值对应的补码的每一个表示与真值的移码表示来说就是符号位相反，数值位相同

**所以阶码来说：**

负数最小：-32，对应补码：$100000$，对应移码：$000000$

负数最大：-1，对应补码：$111111$，对应移码：$011111$

正数最小：1，对应补码：$000001$，对应移码：$100001$

正数最大：31，对应补码：$011111$，对应移码：$111111$

**再看尾数部分：**

尾数要求规格化补码，因此补码必须是1.0XXXXXX以及0.1XXXXXX这种形式，因此对于尾数有：

负数最小：对应补码：$1.000000000$，满足补码规格化定义

> 这里根据真值反推，先看最小的负数补码形式满足规格化不，发现满足，因此就是这个了

负数最大：对应原码：$1.100000001$，对应补码：$1.011111111$，满足规格化定义

>这里的负数要求补码必须是1.0XXXXXXX这样的形式，这种形式下1.000000000确实是最小的负数，在这个基础上增加就是了，因此$1.011111111$就是最大的补码负数，因为再加就不满足了补码的规格化定义
>
>注意直接在补码的基础上加1其实就等价于在原来真值上加1，比如-3的补码是1, 101，那么-2的补码就是1，110，可以直接在补码表示的基础上加一

正数最小：对应补码：$0.100000000$

正数最大：对应补码：$0.111111111$

**所以合起来：**

最小负数：
$$
2^{31} * (-\frac{1}{2})
$$
最大负数：
$$
2^{-32} *(-(2^{-1} + 2^{-9}))
$$
最小正数：
$$
2^{-32} * \frac{1}{2}
$$
最大正数：
$$
2^{31} * (1 - 2^{-9})
$$


**（3）**

-27/1024和7.375的二进制真值表示分别是：
$$
-0.0000011011；+111.011
$$
这里直接先将尾数规格化得到：
$$
-0.11011*2^{-5}；0.111011*2^{3}
$$
阶码部分用移码表示（先将真值转化成补码，然后再写移码）：
$$
-0.110110000*2^{011011}；0.111011000*2^{100011}
$$
尾数部分变成补码规格化形式：
$$
1.001010000*2^{011011}；0.111011000*2^{100011}
$$
所以最后结果是：
$$
0,11011;1.001010000
$$

$$
1,00011;0.111011000
$$



## 5.33 浮点数的加减运算

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107173011093.png" alt="image-20241107173011093" style="zoom:50%;" />

**（1）**

（1）首先，将两个数的阶码和尾数都写成双符号位的补码形式：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107173102870.png" alt="image-20241107173102870" style="zoom:50%;" />

（2）然后进行对阶，始终是小阶向大阶看齐，即小阶加数到大阶，阶码变大，尾数右移变小：

![image-20241107173208690](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107173208690.png)

（3）尾数计算，后面的位保留：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107173240718.png" alt="image-20241107173240718" style="zoom:50%;" />

（4）对尾数进行规格化处理以及处理溢出：

![image-20241107173304935](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107173304935.png)

（5）舍入，并且写出最后的原码结果

![image-20241107173957555](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107173957555.png)

**（2）**

（1）写成两个数的阶码，尾数的双符号位补码：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107174454386.png" alt="image-20241107174454386" style="zoom:50%;" />

（2）对阶，小阶向大阶看齐

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107174706474.png" alt="image-20241107174706474" style="zoom:50%;" />

（3）尾数相加减：

![image-20241107175118267](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107175118267.png)

（4）规格化以及溢出的处理：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107175320289.png" alt="image-20241107175320289" style="zoom:50%;" />

（5）舍入，写出结果

这里的X + Y最后的1，采用0舍1入，最后舍去的时候进一

![image-20241107175552793](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107175552793.png)

不过也可以直接舍，直接舍得化结果如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107175810163.png" alt="image-20241107175810163" style="zoom:50%;" />

## 5.34 浮点数的乘除运算

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108165132704.png" alt="image-20241108165132704" style="zoom:50%;" />

### **（1）**

#### **乘法：**

**（1）将浮点数写成机器数形式：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108104549430.png" alt="image-20241108104549430" style="zoom:50%;" />

**（2）阶码相加，并判断溢出**

这里使用移码的加法，移码的加法公式如下：
$$
[E_X + E_Y]_移 = [E_X]_移 + [E_Y]_补
$$
得到结果：

![image-20241108112551237](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108112551237.png)

没有出现溢出

**（2）尾数相乘**

这里使用定点小数乘法，因为尾数是原码，因此采用原码一位乘：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108114245189.png" alt="image-20241108114245189" style="zoom: 50%;" />

得到尾数：
$$
M = 11.011010(001101)
$$
当然原码的一位乘的符号位是异或单独运算，这里是-1

**（3）规格化和舍入**

这里与浮点加减法的规格化和舍入准则一样

可以看到尾数部分没有溢出，这里只需要左规一位即可，左规一位，阶码减一：

因此阶码就是：
$$
[E - 1]_移 = [E]_移 + [-1]_补 =01,111 + 11,111 = 01,110
$$
阶码没有发生溢出，同时尾数左规以及舍入之后的结果就是：
$$
11.110100
$$
因此最后浮点数的机器结果就是：
$$
[X*Y]_{阶移尾原} = 01,110;11,110100
$$
真值是：
$$
X*Y = 2^{110}*(-0.110100)
$$

#### 除法：

![image-20241108103952332](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108103952332.png)

还是以下面两个数为例子

**（1）将两个浮点数写成机器数的形式并进行尾数调整：**

这里进行调整的意思是可能X的尾数|Mx| > |My|，因此X的尾数需要进行右移缩小，不过这个例子中不需要调整

![image-20241108151745974](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108151745974.png)

**（2）进行阶码相减，并判断溢出**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108152010723.png" alt="image-20241108152010723" style="zoom:50%;" />

没有溢出

**（3）尾数相除**

这里的除法就是原码一位除了，这里用原码交替除法计算，注意这里的原码除法左移的时候并不是算术移位，左移的时候符号位也要参与左移，或者这里可以直接用2符号位进行运算，如果用双符号位就是算术左移了，当然双符号位的最高位是0的时候是正数

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108161256680.png" alt="image-20241108161256680" style="zoom:50%;" />

这里我们就得到了尾数：
$$
[M]_原 = 11,111010
$$
**（3）规格化和舍入**

这里不用规格化和舍入，因此结果的机器数表示为：
$$
[X/Y]_{阶移尾原} = 01,001;11,111010
$$
写成真值形式就是：
$$
2^{001}*(-0.111010)
$$

### （2）

第二问只做一下除法，乘法和第一问的操作是一样的

![img](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/f2f56db7e0884023c159d5c6b1ae8c26.jpg)

这里需要注意的是除法的过程中部分余数出现了0，不过因为此时其最高符号位仍然是0，所以此时按正数处理，后面按照正常流程走完即可

## 5.36 C语言中数据的表示 + 各种机器数的范围 + 溢出判断

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108171957478.png" alt="image-20241108171957478" style="zoom:50%;" />

**（1）**

这里注意下面几个点：

（1）说了这个计算机的字长是8，因此int 就是8位，**int的长度始终是机器字长**

（2）转换的时候机器码基本不变，最后一个语句溢出但是也不用管，直接按8位计算，溢出位不要即可

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108182001174.png" alt="image-20241108182001174" style="zoom:50%;" />

**（2）**

无符号整数和有符号整数：

![image-20241108182211991](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108182211991.png)

这里的规格化浮点尾数是原码形式，下面分别说说尾数的最大和最小：

**正数：**

最大：$0, 111 1111, 1 - 2^{-7}$

最小:：$0, 100 0000, 2^{-1}$

**负数：**

最大：$1, 100 0000, -2^{-1}$

最小：$1,11111111, -(1 - 2^{-7})$

至于阶码，阶码的移码形式其实和补码具有相同的范围，这里直接按照补码来思考，将补码转换成真值即可

（3）不多说，肯定是最后一条了
