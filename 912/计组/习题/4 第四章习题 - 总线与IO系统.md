# 第四章习题-总线与IO系统

## 例 4.1 总线带宽和数据传输率

![image-20240814192528098](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240814192528098.png)

**（1）**

而带宽是总线理论数据传输的最大值，所以一秒的所有时钟周期中总线全部传送数据，**也就是一个总线周期中的所有时钟周期都传输数据，这就是带宽了**，也就是1s能够传输数据的最大值

总线的时钟频率就是一秒有多少个总线时钟周期

每个时钟周期都传输数据，于是总线就是时钟频率乘位数了

带宽：`F = f * D = 33 M * 32 = 132 `MB/s 注意这里的M表示10^6的意思

但是总线并不是1s的每个时钟周期中都传输数据的，总线的一次完整的操作有四个阶段：

（1）申请分配，（2）寻址，（3）数据传送，（4）结束

以同步通信为例，这四个阶段构成了一个总线周期，包含了四个总线时钟周期，也就是说四个时钟周期中总线才传送一次数据，**也就是一个总线周期传送一次数据**，所以我们得求1s中有多少个总线周期，然后1s中的总线的周期个数乘32bit得到数据传输率

总线时钟周期：`T = 1 / f = 1/33M `s 注意这里的M表示10^6的意思

总线周期：`T' = 4T = 4 / f = 4 / 33M `s

1s中总线周期的个数：`1s/T’ = f / 4 = 33M / 4`个

实际数据传输率：`P = D * f / 4 = 32bit * (33M / 4) = 33`MB/s  注意这里的M表示10^6的意思

其实就是带宽除以4

**（2）**

总线时钟频率和带宽增加一倍

那么带宽有：`F = f * D = 33M * 2 * 32 * 2 = 528` MB/s

总线时钟周期：`T = 1 / f = 1 / (33MHz * 2)`s

总线周期：`T' = 2 / f = 2 / (33MHz * 2) = 1 / 33M`s

1s中的总线周期个数：`f / 2 = 33M`个

数据传输率：`D * f / 2 = 64 * 33M = 264 `MB /s 这里的M都是10^6的意思

**总线带宽是1s中的所有时钟周期都传输数据，即一个总线周期中的所有时钟周期都传输数据，实际数据传输率是一个总线周期只传一次数据，假设一个总线周期有k个时钟周期，所以实际数据传输率，就用带宽除以k即可**

## 例 4.2 CRT显示器相关计算

![image-20240914193145897](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240914193145897.png)

**（1）**

这里的缓存容量，就是VRAM的容量

通常字符是以ASCII存放在VRAM中的，一个字符就占一个字节，因此VRAM中的一个存储单元就是一个字节，最大存储容量就是整个屏幕的整个所有字符，即：
$$
64 * 25 *8b = 12800b = 1600B
$$
**（2）**

ROM中存放的是整个字符集，一个字符在屏幕中占据的所有的点阵就表示ROM中的一个二进制的位

每个字符占据7 * 8的点阵，但是还有一像素的字间间隔，注意在这一章中像素点阵的7 * 8是7列8行 即 列*行，而不是一般的程序语言中的行 * 列，所以一个字符占据的点阵应该是8（列） * 8（行）

这个字符集有95个字符，所以ROM的大小至少为：
$$
95 * 8 * 8b= 760B
$$
**（3）**

显示是整个屏幕字符的ASCII码

**（4）**

缓存中的一个字符的地址构成是：
$$
字符所在的行号 * 每行的字符数 + 字符所在的列号
$$
屏幕中的字符显示是从上到下，从左到右显示的

因此VRAM中字符对应的地址也是从小到大与屏幕中的字符一一对应

**（5）**

**点计数器，其模是窗口的大小，在这里就是 7 + 1 = 8**

字计数器，其模是一行所显示的字数加上水平回扫的时间，计算的时候就用一行字符周期的个数代表

这道题目中的点频是14.896MHz，因此扫描一像素点的时间就是$T_点 = \frac{1}{14.896MHz}$

一个字符窗口的行长度是8因此扫描一个字符的长度的时间就是$T_字\frac{8}{14.896MHz}$

同理扫描一行像素点的时间就是$T_{行像素} = \frac{1}{24.5kHz}$

所以扫描一行像素点所扫描的字符的个数，也就是周期的个数就是：
$$
\frac{T_{行像素}}{T_字} = \frac{14.896MHz}{24.5KHz * 8} = 76个
$$
**所以字计数器的模就是76**

行计数器的模，行计数器加一就表示电子束扫描完了一行的像素点，其扫描完成计数达到模就表示电子束扫描完了一排的字符，所以这里得加上行间距，**因此行计数器的模就是字符窗口的高度，就是8 + 6 = 14**

排计数器加一表示扫描完了一排的字符，排计数器达到模就意味着电子束扫描完了整个屏幕，所以排计数器的模就是屏幕的字符的排数

但是排计数器模还得加上电子束垂直回扫的时间，所以这里用扫描一个屏幕时间中扫描的排的周期的个数代替

扫描完一个屏幕的时间就是帧的周期，即$T_{屏幕} = \frac{1}{50}$

行频率，即可以得到扫描一行的像素点的时间是$T_{行像素} = \frac{1}{24.5kHz}$

一排的字符有14行，因此扫描一排的字符的时间就是$T_{排} = \frac{14}{24.5KHz}$

所以扫描完整个屏幕所具有的排的周期个数就是：
$$
\frac{24.5K}{50 * 14} = 35
$$
因此排计数器的模就是35

## 例 4.3 波特率和比特率

![image-20240916160431890](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240916160431890.png)

波特率其实就是数据的传送速率，也就是单位时间中传送的二进制位的大小

比特率跟波特率类似，不过是有效数据的传送速率，即单位时间中传送的有效二进制位的大小

数据帧就是一串完整的数据格式，包括起始位，数据位，校验位等等，其中数据位是有效二进制位，其他的都不是有效位，比特率只用算有效二进制位，但是波特率需要算一个完整的数据帧

这道题目中，一帧有10位，因此波特率就是：
$$
10b * 120 帧/s = 1200 b/s = 1200Baud
$$
一帧有4个有效位，所以比特率就是：
$$
7 * 120 帧/s = 840 b/s
$$

## 例 4.4 数据传送控制方式 - 程序查询方式

![image-20240922153644844](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240922153644844.png)

算这种问题，统一将1s中的总的时钟周期个数当作总的CPU时间所包含的时钟个数

一次查询需要两条指令

对于键盘和硬盘，每次查询所需要的时钟周期个数为：
$$
2 * 5 = 10
$$
对于键盘，1s查询5次，因此1s总的用于查询的时钟周期个数为50个

因此键盘的查询占CPU时间的比率就是：
$$
\frac{50}{50M} * 100 \% = 0.001\%
$$
对于硬盘由于每次查询一次交换一个字节，而传输率是5MB/s，因此1s查询了5M次，所以1s中CPU用于查询的时钟周期个数为50M个

因此硬盘的查询占CPU的时间的比率就是：
$$
\frac{50M}{50M} * 100 \% = 100 \%
$$
这显然是不可能的，CPU不可能将全部的时间全用于硬盘，所以硬盘是不会采用查询方式进行数据交换控制的

## 例 4.5 数据传送控制方式 - 中断方式

![image-20240922155722331](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240922155722331.png)

这里的数据传送就是中断时间，准备时间就是CPU的1s中的总时间总CPU时间，同上一题一样，这里同样可以直接用时钟周期个数来做，这里1s中所包含的CPU时钟周期的个数还是作为CPU时间所包含的时钟周期的个数

首先是一次中断占用的时钟周期个数：

$$
(8 + 2) * 5 = 50
$$

用户是5键/s可以认为是键盘每秒中断5次，因此键盘每1s中断所占的时钟周期个数就是50 * 5 = 250个

因此1s中键盘的中断所占用CPU的时间比率就是（1sCPU有50M个时钟周期）：

$$
\frac{250}{50M} * 100 \% = 0.0005\%
$$

对于硬盘，中断一次交换一个字节，而数据传输率是5MB/s，因此每秒中断5M次

所以1s中键盘中断所占用的时钟周期个数就是：

$$
5M * (8 + 2) * 5
$$

因此硬盘在1s中的CPU的比率就是：

$$
\frac{5M * 50}{50M} * 100\% = 500\%
$$

可以看到CPU在硬盘数据传送时间远远超过准备时间，所以CPU不能采用中断的方式与硬盘进行数据交换，否则会造成数据丢失

## 例 4.6 多重中断与嵌套

![image-20240923154238573](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240923154238573.png)

**（1）**

一般的优先级顺序就是响应的优先级顺序，同时屏蔽字也按照这样设置即可：

![image-20240923155044386](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240923155044386.png)

然后画出处理的程序图，这个图的意思就是在最开始的时候五个中断请求同时到来，但是由于屏蔽字和优先级的顺序一样，所以CPU就先执行A的程序（图中灰色曲线）然后执行完毕之后再执行B，接着一直将E的程序执行完毕再返回

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240923155211392.png" alt="image-20240923155211392" style="zoom:50%;" />

**（2）**

这里的中断处理次序其实就决定了屏蔽字的设置，B的处理次序在E的前面，就说明E在B的位置处的屏蔽字应该为0，表示当CPU执行E的中断服务程序的时候不能阻挡B的中断，所以屏蔽字的设置如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240923160621537.png" alt="image-20240923160621537" style="zoom:67%;" />

当这五个中断同时到来的时候先是处理完B，接着处理E，然后处理C，然后处理A，最后处理D，如下图所示，注意是按照ABCDE的顺序一瞬间到达

> 真的较真的话就是如下：
>
> **CPU响应**：（时间忽略）
>
> （1）一部分保护现场
>
> （2）关中断
>
> （3）找中断程序的地址，执行中断服务程序
>
> **中断服务程序包括：**
>
> （1）一部分保护现场，开中断
>
> （2）中断处理
>
> （3）关中断，一部分恢复现场
>
> 根据出栈规律，恢复哪个程序现场就回到哪个程序，并且（1）（3）操作互逆，且一般忽略CPU响应时间
>
> **中断返回：**中断程序的最后一条指令，忽略
>
> （1）一部分恢复现场
>
> （2）开中断

先是A执行A的一段保护程序并开中断，然后执行完整的B服务程序

B的服务程序保护A，并最后恢复A，应该先到A，然后再去C

C执行一小段保护程序，保护A的现场，开中断之后执行E

E执行完毕之后恢复的是C，应该先到C，执行完了C之后，C恢复了A的现场，应该执行完A

A的服务程序最后恢复了现行程序的现场，所以应该回到现行程序，接着才执行E

所以其实是恢复哪个现场就应该回到哪个现场，CPU的响应开中断事件忽略不计

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240923160918243.png" alt="image-20240923160918243" style="zoom:50%;" />

## 例 4.7 数据传送控制方式 - DMA方式

![image-20240923161850924](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240923161850924.png)

这里其实是例4.5，CPU主频是50MHz，硬盘的数据传输率是5MB/s

这里还是使用时钟周期来做，1s当作CPU时间，1s中有50M个时钟周期

一次DMA操作CPU的开销为500个时钟周期

硬盘的传输速率是5MB/s，而一次DMA传送5000B数据，所以1s中有1000次DMA操作，因此1s中CPU用于DMA的总的时钟周期个数就是：
$$
500 * 1000个
$$
所以DMA操作占CPU时间的比率为：
$$
\frac{500000}{5000000} * 100\% = 10 \%
$$

## 例 4.8 数据传送控制方式的计算题

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240923175058825.png" alt="image-20240923175058825" style="zoom: 50%;" />



**（1）**

这里还是将1s当作整个CPU时间，还是使用时钟周期来做

一次中断所需的时钟周期个数为：$(18 + 2) * 5 = 100$

一次中断传输数据4B，1s传输0.5MB的数据，因此1s应该中断：
$$
\frac{0.5M}{4} = 0.125 * 10^6次
$$
所以1s中用于中断的总的CPU时钟个数为：
$$
12.5 * 10^6个
$$


因此CPU用于外设占整个CPU时间比率为：
$$
12.5*10^6 / 500 *10^6  \%= \frac{12.5}{500} \%= 2.5\%
$$
**（2）**

一次DMA的所占用CPU的时钟周期个数为：500个

1次DMA传送数据5000B，1s传送5MB个，所以1s有1000次DMA操作

因此1s中用于DMA的CPU时钟周期个数为：500000个

所以DMA方式CPU用于外设占总的CPU时间的比率就是：
$$
\frac{500000}{500000000} * 100\% = 0.1\%
$$

## 4.1 总线主模块和从模块

![image-20240925161042495](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240925161042495.png)

![image-20240925161230635](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240925161230635.png)

## 4.2 总线传送信息的过程

![image-20240925161310785](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240925161310785.png)

![image-20240925161401170](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240925161401170.png)

时序关系图不要求掌握

## 4.3 总线带宽和数据传输率

![image-20240926161644755](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240926161644755.png)

总线带宽是指单位时间内总线上可以传输的最大数据量，计算公式：
$$
总线频率 * 总线宽度（字节数）
$$
单位是MB/s

注意根据例4.1，总线频率就是每秒使用总线多少次，但是不是每次都在传输数据，一个总线周期可以包含多个总线时钟频率，一次总线周期传输一次数据，所以实际的数据传输率应该用总线周期来计算；不过在这题中的总线周期与总线时钟周期相等，这里的带宽就是数据传输率

总线带宽：
$$
70MHz * 8B = 560 MB/s
$$
总线数据传输率：
$$
560MB/s
$$

## 4.4 总线带宽和数据传输率

![image-20240926162520440](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240926162520440.png)

**（1）**

总线带宽，就是总线的所有时钟周期都传输数据，是数据传输率的最大值

总线数据传输率，就是总线的一次周期传输一次数据，总线周期可以包含多个总线时钟周期

总线时钟频率，就是1s使用了总线多少次，假如每次都传输数据，那其与总线带宽乘起来就是1s传输数据的量，就是带宽了

当然并不是每次都传输数据，比如这题中一个总线周期包含三个时钟周期，这就意味着3个时钟周期才传输一次数据，所以实际的数据传输率就是总线带宽除以3

**总线带宽：**
$$
33MHz * 4B = 132 MB/s
$$
**数据传输率：**
$$
132 / 3 = 44 MB/s
$$
**（2）**

**总线带宽：**
$$
66MHz * 8 B = 528MB/s
$$
**数据传输率：**
$$
528  / 2MB/s = 264 MB/s
$$

## 4.5 异步通信和同步通信

![image-20240928163815145](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240928163815145.png)

同步通信是一个总线周期中的所有操作（CPU发送地址，发送读命令，发送数据等）根据统一的时钟周期进行，哪个时钟周期进行哪个操作是固定的，比如一个总线周期被划分为四个时钟周期，在第一个时钟周期CPU发送地址，第二个时钟周期发送读命令，第三个时钟周期主存给CPU发送数据等等

异步通信是主模块和从模块采用应答的方式来相互联络，即主模块要等待从模块的回答信号后才能撤销自己发出的信号；异步通信的模块按照自己的使用实际时间使用总线

所以这道题的答案如下：

![image-20240928164740140](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240928164740140.png)

## 4.6 异步通信和同步通信，异步通信的分类

![image-20240928164919907](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240928164919907.png)

![image-20240928164940953](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240928164940953.png)

这里画图不要求掌握

## 4.7 半同步通信

![image-20240929163010901](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240929163010901.png)

**（1）**

半同步通信是同步通信和异步通信结合的一种通信方式；

它以同步通信为基础，可以像同步通信那样由统一的时钟控制，同时可以像异步通信那样，允许各个部件传输的时间不一致

它保留了同步通信简单的特点，又具有异步通信的灵活性

**（2）**

半同步通信在正常总线通信双方的时间协调方式与同步通信一样，一个总线周期的操作根据统一的时钟周期进行；但是对于某些特别慢的模块，它可以插入若干个等待时钟周期来延长总线周期，并增加一条等待状态线/WAIT来控制是否进入等待状态，它通过检测等待信号的有无来判断是否加入等待始终周期来进入等待状态，从而实现双方在时间上的协调

也就是说同步通信的总线周期是固定的，中间分为几个时钟周期，到了什么时间就应该做什么事；但是半同步通信通过检测等待信号在一个总线周期中加入几个等待周期从而改变总线周期的长度，这样显然更灵活一些

## 4.8 总线仲裁 + 集中式总线控制

![image-20240929164026733](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240929164026733.png)

这道题目是死的，直接背会即可

![image-20240929164047087](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240929164047087.png)

## 4.9 总线仲裁方式 + 集中式中的独立请求方式

![image-20241004171837789](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241004171837789.png)

独立请求方式是集中式总线仲裁方式中的一种，其意思就是每一个主模块都单独用一个总线请求信号线BR和总线允许信号线BG

总线控制器中对各个模块发来的总线请求线BR进行排序，按照优先级通过总线允许信号线BG来发送总线允许信号

其对各个模块的总线请求线BG的优先级排序如下所示，高电平有效：

![image-20241004172418938](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241004172418938.png)

上图中BR0有效时，通过另外三个与门的作用让其他三个的请求信号在高电平的情况下允许信号低电平

只有BR0第电平的时候BR1高电平才能导致BG1允许信号有效

## 4.10 有编码键盘的接口逻辑

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241004172630094.png" alt="image-20241004172630094" style="zoom:67%;" />

**（1）**

这是一个有编码键盘，其接口逻辑如下所示：

![image-20241004175033589](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241004175033589.png)

扫描计数器的作用就是产生扫描数，通过列译码和行译码分别循环轮流选中每个键的行线和列线，如果有键被按下，那扫描计数器就停止计数，将此时的扫描数作为地址去查找ROM，在ROM中找到这个键的ASCII码，然后送到CPU中；延迟一段时间之后重新开始计数，开始新一轮的扫描

因此扫描计数器的位数与键的个数相关，这道题目中行有8行，列有16列，所以扫描计数器中有3位作为行译码去选择行，有4位作为列译码去选择列，一共7位

**（2）**

这里的ROM用于存放整个字符集的ASCII码，一个ASCII码8位，字符集一共128个，所以整个ROM的大小是128B

**（3）**

所谓奇校验，就是在原来的位数中增加一个校验位使得编码中1的个数是奇数

偶校验，就是在原来的位数中增加一个校验位使得编码中1的个数是偶数

F的ASCII码是106，二进制就是0100 0101，其实7位就能搞定，第一位就作为校验位

**（4）**

如果不包含校验位，那么每个键其实就只有7位的ASCII位，这时其实可以按照每个键的ASCII码来设计字符在键位上的排列，使得扫描数的前三位（行位）就是这个键对于字符的ASCII的前三位，扫描数的后四位（列位）就是这个键对应字符的ASCII的后四位，这样每个键的扫描数就是自己的ASCII码了，也就不需要ROM了

## 4.11 CRT显示器有关计算题

![image-20241005173454572](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241005173454572.png)

**（1）**

显存也就是VRAM，VRAM中存放整个屏幕的字符，因此其大小与整个屏幕的字符相对应，而且VRAM中的一个存储单元的最小宽度是一个字节

因此VRAM容量就是：
$$
72 * 24 B = 1728B
$$
**（2）**

ROM的大小取决于字符集的大小和每个字符的点阵规模，点阵的一个点表示二进制的一个位，并且字符的行间隔也要存放在ROM中

因此这里的ROM大小就是：
$$
64 * (7 + 1)(横向8个点) * (8)(纵向8个点) = 512B
$$
**（3）**

显存中存放的是整个屏幕字符的ASCII码信息

**（4）**

VRAM中的每个单元的地址是由屏幕上字符的行和列决定的，即VRAM的地址为字符所在的行号 * 一行的字符个数 + 字符所在的列号

这里的行号和列号都是字符的行号和列号不是像素点的行号和列号

显示位置从左到右从上到下，分别对应显存中的地址的从小到大

**（5）**

**点计数器**：

点计数器的作用是统计和跟踪像素点的位置，每扫描一个像素点其值加一，他的模是一个字符的像素宽度，也就是8，每扫描了一个字符宽度的像素点，点计数器就输出一个信号

**字计数器：**

字计数器的作用是对屏幕中的一行的字符进行计数，电子束每扫描了一个字符宽度的像素点，字计数器就加一，也就是说点计数器每输出一次，字计数器就加一；字计数器的模等于屏幕中一行显示的字数加上水平回扫的时间，一般用一行的字符周期个数来计算

这里一行有24个字符，因此扫描字符就是24个字符周期，然后水平回扫占总的扫描20%的时间，假设水平扫描的总的字符周期个数是x个，则24 / x = 80%，因此x = 30个字符周期，所以水平扫描总的就是30个字符周期，回扫占了6个字符周期，因此字计数器的模就是24 + 6 = 30个字符周期，即30

字计数器每达到模记满一次就输出一个行时钟信号，表示一行的像素点扫描结束，输出一个行时钟信号

**行计数器：**

行计数器是对整个屏幕的像素行进行跟踪和计数，电子束每扫描了一行的像素行行计数器就加一

行计数器的模就是字符窗口的高度，每记满一次就输出一个排时钟信号，表示一排的字符扫描完毕；所谓字符窗口就是屏幕上的一个字符所占的行和列的点阵以及字符之间的间隔合在一起称为字符窗口

因此行计数器的模就是8 + 6 = 14

**排计数器：**

排计数器的作用是统计跟踪屏幕上的字符行，排计数器加一就表示电子束扫描了一行的字符

排计数器的模是整个屏幕的字符行加上水平回扫的时间，这里一般用整个屏幕的字符行的周期个数代替

整个屏幕一共有24排，因此单纯扫描字符行的周期个数就是24，而垂直回扫占总的扫描时间的20%，所以扫描字符行的周期个数占总的扫描时间的80%，因此24 / y = 0.8，所以y = 30，所以垂直回扫所占6个行扫描周期，因此排计数器的模就是24 + 6 = 30

**（6）**

帧频率为50Hz即1s扫描50整个屏幕的点，所以我们算出即1s可以扫描多少个像素点即可

需要注意的是，这里的1/50s即扫描一个屏幕的时间其实包括了水平回扫和垂直回扫的时间的，水平回扫以及垂直回扫也应该等价于在扫描像素点，如果我们设扫描像素点的周期是T，则一个字周期就是：
$$
14(字符窗口高度) * 8(字符窗口宽度) * T
$$
整个屏幕有多少字周期呢：
$$
(72 + 8)(一个像素行有72个字，加上水平回扫，等价于多扫了8个字) * (24 + 6)(一个屏幕有24排字符，加上竖直回扫，等价于多扫了6排字符)
$$
这里的等价可以理解为往后多扫描了几个字，然后回扫的时间不计

所以扫描一帧的时间就是：
$$
14 * 8 * 80 * 30T = \frac{1}{50}
$$
所以点频率就是$\frac{1}{T} = 15.12MHz$

## 4.12 打印机有关计算题

![image-20241005173548338](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241005173548338.png)

**（1）**

这里的缓存，跟上面的键盘和显示器一毛一样，用来存放所有字符的ASCII码的，而点阵打印机的意思是用一个点阵来表示字符或图像，所以7列9行表示的是一个字形点阵，总的字符其实就是132个，加上一个校验位，其实也是8位，所以缓存容量：
$$
132B
$$
**（2）**

字符发生器容量，也就是ROM容量，跟上面的键盘和CRT一致，取决于字符集和每个字符的点阵，所以器容量为：
$$
\frac{7 * 9 * 96}{8}B = 972 * 9bit
$$
**（3）**

打印机的控制逻辑如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241005184308337.png" alt="image-20241005184308337" style="zoom:67%;" />

ROM中存放字符点阵的信息，根据这个字符的地址将ROM中的内容放入驱动器中由驱动头打印出点，ROM中的存放也跟CRT的存放非常类似，ROM中连续的几个字节分别存放这个字符的每一列的点列信息

而ROM中字符集的地址由两部分构成

高位地址是RAM中字符的ASCII码

低位地址是列计数器提供的，与CRT显示器中的ROM的低位地址类似，是字符在一个字符点阵中的列号，因此这里的列计数器的模其实就是字符点阵的列，即7，所以3位就可以了

**（4）**

缓存地址计数器提供RAM中字符的地址，而RAM中的容量为132，所以计数器的位数8位即可，至于驱动器是怎么知道打印的字符在整张纸的那一列，推测是根据RAM地址和ROM中的lie'hao

## 4.14 比特率和波特率

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241007164701034.png" alt="image-20241007164701034" style="zoom:67%;" />

波特率其实就是数据的传送速率，也就是单位时间中传送的二进制位的大小

比特率跟波特率类似，不过是有效数据的传送速率，即单位时间中传送的有效二进制位的大小

数据帧就是一串完整的数据格式，包括起始位，数据位，校验位等等，其中数据位是有效二进制位，其他的都不是有效位，比特率只用算有效二进制位，但是波特率需要算一个完整的数据帧

这里的异步和同步通信对计算没有影响，只是影响数据帧的格式

**（1）**

这里的波特是一个单位，1200Baud = 1200b/s

由于1200b/s，那么传送1 + 512B的数据需要：
$$
(513 * 8) / 1200 = 3.42s
$$
那么比特率就是：
$$
\frac{512 * 8}{3.42s} = 1197.7b/s
$$


**（2）**

传送8位数据时间为：
$$
\frac{10}{1200} = \frac{1}{120}s
$$
这些时间中传输的有效数据是7b，所以比特率就是：
$$
\frac{7}{\frac{1}{120}} =840 b/s
$$
**所以这类题目主要是算出传送一个数据帧所需要的时间，然后利用数据帧的有效位算出比特率**

## 4.16 数据传送控制方式 - 程序查询方式 + 踏步等待

![image-20241007172154736](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241007172154736.png)

![image-20241007172219435](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241007172219435.png)

程序查询方式是CPU控制IO数据传送的一种方式，程序查询方式的思想是在现行程序中插入一段由IO指令编制的程序来完成IO数据交换，交换完毕之后又执行现行程序

流程图如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241007172425570.png" alt="image-20241007172425570" style="zoom:67%;" />

## 4.17 数据传送控制方式 - 中断方式

![image-20241007172513962](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241007172513962.png)

中断方式是CPU在执行程序的过程中出现紧急事件，CPU暂停线性程序的执行，转去执行别的事件，别的事件执行完毕之后再回来执行现行程序；中断是一种软硬件结合的技术

> [!NOTE]
> 一次完整的中断过程分为5个阶段：
> 
>  **（1）中断请求**
> 
>  IO设备完成操作之后就向CPU发送中断请求，IO接口中有一个中断请求触发器INTR，INTR = 0表示没有请求，INTR = 1表示有请求
> 
>  同时CPU还可以决定是否响应这个请求，IO接口中还有一个中断屏蔽触发器MASK，MASK = 1表示这个IO的中断请求被屏蔽，CPU不理他，MASK = 0表示CPU对这个中断表示响应
> 
> **（2）中断判优**
> 
> 多个中断源同时请求的时候CPU需要对这些中断源进行判优排队，排队主要有串行排队和并行排队两种方式，可以由硬件也可以由软件实现
> 
> **（3）中断响应**
> 
> 中断响应就是CPU受到中断源发出的请求之后开始有所动作，当然CPU自已也可以决定不采取响应，CPU有一个中断允许触发器EINT，EINT = 0表示禁止中断，无论IO怎么法请求CPU都没有动作，EINT = 1表示允许中断；CPU在每条指令执行完了之后都会查询是否有中断请求
> 
> 在中断响应中CPU主要执行三个操作，这三个操作是由硬件自动执行的，就好像有默认的指令一样，所以称为隐指令：
> 
>  **i 关中断**
> 
> 即将EINT设置为0，表示CPU正在处理中断，以免别的中断过来有冲突
> 
> **ii 保护程序断点，PSW**
> 
> **iii 获得中断服务程序地址**
> 
> 获得的方法主要有两种，软件查询法和硬件向量法
> 
> **（4）中断服务 - 执行中断服务程序**
> 
>  CPU在执行完响应操作得到中断服务地址之后就开始执行中断服务程序，中断服务程序要完成三个工作：
> 
>  **i 保护现场**
> 保护现场主要是保存CPU正在运行的程序的位置以及程序中的一些内容，其有两个方面：
> 
> 保存断点和程序状态字(PSW)，这一步通常在CPU响应中断的时候由隐指令完成，因此保护现场的一些操作主要跟程序内部的内容有关
>  
> 保存寄存器的内容
> 
> **ii 开中断**
> 这一步是为了在处理的时候允许多重中断
> 
> **iii 中断处理**
> 这一步就是中断要做的主要工作了，对于IO中断来说就是完成IO与主机之间的数据交换
> 
> **iv 关中断**
> 因为下一步需要恢复现场，不能被打断，所以这里关中断，不允许别的嵌套别的中断过程
> 
> **v 恢复现场**
> 恢复现场是保护现场的逆操作，包括恢复寄存器内容和恢复断点和程序状态字
> 
> **（5）中断返回**
> 即现行程序端点和 PSW 出栈
> 
> 中断返回由中断返回指令执行，通常在中断服务程序的最后一个指令，中断返回就是中断响应的逆操作，将中断断点和PSW出栈以及开中断，表示CPU这时处理完成了中断操作，可以响应别的中断源发出的中断请求了
> 
> 中断返回其实也应该看作中断服务程序中的一部分

对于这道题目：

**（1）**

当然是IO接口中的MASK = 0，屏蔽触发器没有被CPU屏蔽，当然还得IO完成了自己的操作之后才行，通过设置INTR = 1，向CPU发送中断请求

**（2）**

当CPU一条指令执行完毕，查询到有中断请求并且EINT = 0表示可以进行中断响应的时候才会中断响应

**（3）**

CPU在获得中断服务程序入口地址的时候是通过查询中断向量来获得中断服务程序的地址

一般而言中断是不仅仅有IO中断的，这里将所有的中断服务程序入口地址放到一张表里面，这个表就是中断向量表

而中断向量表的地址就是中断向量地址

**（4）**

中断向量是必须得CPU来读取获得中断向量地址的，而地址线是CPU发送地址给IO的，是一个单项的，CPU只能发送不能读，所以得放到数据线上让CPU也可以读

## 4.19 多重中断的与嵌套

![image-20241007181900930](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241007181900930.png)

**（1）**

关键是画出每个中断源自己的中断屏蔽字

注意多重中断的屏蔽字并不是MASK，多重中断的屏蔽字是用于屏蔽其他的中断的，其设置在每个中断源自己的中断服务程序中，中断服务程序执行的时候就将中断屏蔽字放入中断寄存器中用来屏蔽其他的中断，并且中断的时候也得保存和恢复现存程序的中断寄存器；比如正常程序的中断屏蔽字是0000，表示不会屏蔽任何中断，当中断发生之后0000必须进行保护，即此时的中断寄存器中的中断屏蔽字0000得保护一下，然后中断寄存器中放入导致中断的中断源的屏蔽字，比如1010，当中断返回的时候再恢复0000到中断寄存器中，进行其他的程序执行，或下一个中断：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241007183749947.png" alt="image-20241007183749947" style="zoom:50%;" />

注意现行程序也有自己的中断屏蔽字，这里直接画出每个中断服务程序的中断屏蔽字即可，1表示屏蔽，0表示不屏蔽，意思就是自己可以被这个中断源进行中断嵌套：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241007183840468.png" alt="image-20241007183840468" style="zoom:67%;" />

注意屏蔽字中的1表示这种中断源可以屏蔽对应的中断源，并且自己的中断源，也应该屏蔽

**（2）**

注意像这种多重中断画图题应该弄清小平台问题，就是保护现场和恢复现场的入栈出栈顺序

当A中断被B中断嵌套时，只有A的现场保护完了并打开了中断之后才能被嵌套转去执行B的中断服务程序，同时B的服务程序执行到恢复A的现场的时候要关中断，表示此时不能被打断，否则A会出现数据丢失

CPU响应中断其实包括关中断，找到中断服务程序入口地址，然后还有一部分的保护现场操作，这里根据题意，CPU响应事件忽略不计

中断服务程序有三个阶段，保护前一个程序现场并开中断，中断处理，关中断并恢复前一个程序现场，这里恢复是保护的逆操作，本题默认近似逆操作，CPU响应的一部分保护操作时间不计，因此保护和恢复的时间我们认为是相等的即4us/2 = 2us，总的中断服务程序处理一共10us

> 真的较真的话就是如下：
>
> **CPU响应**：（时间忽略）
>
> （1）一部分保护现场
>
> （2）关中断
>
> （3）找中断程序的地址，执行中断服务程序
>
> **中断服务程序包括：**
>
> （1）一部分保护现场，开中断
>
> （2）中断处理
>
> （3）关中断，一部分恢复现场
>
> 根据出栈规律，恢复哪个程序现场就回到哪个程序，并且（1）（3）操作互逆，且一般忽略CPU响应时间
>
> **中断返回：**中断程序的最后一条指令，大概0.5us
>
> （1）一部分恢复现场
>
> （2）开中断

当然这里其实CPU响应和中断返回都可以直接忽略，不用太纠结，直接近似认为中断服务程序就是保护现场，处理，恢复现场即可，小平台就是保护现场的延迟



首先是四个中断同时到达，不过严格来说还是有顺序的，**这里按照A, B, C, D的顺序，只不过瞬间到达**，那么先是A，它被B中断，那肯定得保护下A的现场并开中断，再去执行B，所以A的中断服务程序得先执行2us才行

同理到B的时候起服务程序也得先执行下2us来保护现场

接着到C，C可以完整被执行，就是10us

C执行完了之后恢复B的现场应该回到B，执行B的剩下的8us

然后B恢复A的现场后回到A执行A的剩下的8us

A执行完了之后显然先恢复现行程序应该回到现行程序，然后再去执行完整的D中断的服务程序，最后回到现行程序

![image-20241007190328709](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241007190328709.png)

上图中的2us就是用来保护上一个程序的现场并开中断的时间，后面的很微小的一段延迟应该是A的服务程序执行完毕之后中断返回的延迟，一条指令的延迟0.5us，其实可以直接忽略

## 4.20 磁盘的有效数据传输率的计算 + 解决IO与CPU速率不匹配的缓存设计方法

![image-20241012181409906](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241012181409906.png)

**（1）**

这里求磁盘所需的最大传输率的意思是我们先求出磁盘的最高数据传输率，然后磁盘通道必须能够提供这样的速率通道

磁盘的最大数据传输率，就是有效信息的传输率

磁盘的一个磁道中有4个区，每个区之间有一个间隔，那么一个环形的磁道就有4个间隔

磁头转一圈有效读取时间就是25ms - 1.25ms * 4 =20ms

一圈的容量是：1.6 / 200 = 0.008MB

所以最大传输速率就是：
$$
\frac{0.008MB * 1024 * 1024}{20*10^{-3}s}  \approx 0.4MBps
$$
式子中的M是1024倍的B的意思，而速率单位的M则是10^6的意思

**（2）**

当这个接口的寄存器满了之后，如果磁盘再读入一个bit数据，但是此时CPU还没有响应，那就会造成数据丢失

所以我们就需要比较磁盘读一个bit数据的时间与CPU响应时间的大小，如果CPU响应时间小于磁盘读一个bit时间，那再下次磁盘再读入一个bit到寄存器中前，CPU就已经完成了响应取走了数据，这就不会造成数据丢失

根据第一问的结果，磁头转一圈是20ms，读取了8KB的数据，那读一个数据的时间就是：
$$
\frac{20}{8 * 1024 * 8} \approx 0.305\mu s
$$
所以CPU响应要比读取一个bit数据慢得多，当寄存器满了之后磁盘还会不停读取数据到寄存器中，将前面的CPU还没有取走的数据全挤走了，那这样CPU还读个苟巴

既然磁盘继续读取数据将以前的寄走，那我将挤走的再存起来不就完事了，CPU读取的时候读存起来的数据就可以了

所以这里常见的解决方法就是设置缓存器，这里设置二级缓存

第一级跟题目中一样，是一个串行的缓存器，一共16位，当满了之后就给CPU发送取数据信号，同时并且将这16位数据放入第二级寄存器中

这样当第二次一级缓存器读满了之后才会发生数据丢失，这时留给CPU的时间就有16 * 0.305us = 4.88us > 3us，于是CPU就有充足的时间来取数据了

当然写入的时候是一个反过程，CPU将数据放入到二级缓存中，然后二级缓存再并行直接写入到一级缓存中，一级缓存再串行写入到磁盘

整个逻辑如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241012184514465.png" alt="image-20241012184514465" style="zoom:67%;" />

注意这里的CPU响应的时间就是CPU得到信号然后将数据取走的时间是3us

## 4.21 DMA的计算题 + DMA周期窃取方式访存 + 主存存取时间的定义

![image-20241012184711065](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241012184711065.png)

**（1）**

一次完整的DMA过程就包括预处理，数据传输，后处理三个阶段

数据传输的时候时间是：
$$
\frac{4*1024B}{2*10^6 B/s} = 2.048ms = 2048us
$$
预处理和后处理的时间为：
$$
(800 + 500)*\frac{1}{50MHz} = 0.026ms
$$
所以一共就是2074us

**（2）**

DMA周期窃取（挪用）的方式与主存交换数据的方式就是，CPU始终继续执行当前程序，只是当磁盘（IO）数据准备好了之后占用一下总线交换数据，这里只是占用总线，并不会让CPU中断，对当前程序执行的影响小很多

DMA以周期窃取方式与主存交换的过程是，首先磁盘准备数据，准备好了数据之后就占用总线交换一次，注意在交换的过程中磁盘还在并行地准备数据，并且IO这里是磁盘，准备数据的速度比占用总线传输一次慢得多，**所以其实数据传输率其实就是磁盘准备数据的速率**：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241013183127388.png" alt="image-20241013183127388" style="zoom:50%;" />

上图绿色就是窃取总线一次，使用一次总线存取周期，存一次数据，即100ns

> 一般而言主存的存取周期是启动一次存储器操作，然后到下一次启动存储器操作的时间间隔
>
> 而主存的存取时间就是单纯的存数据或是取数据操作的时间，存数据的时间等于取数据的时间，统称为存取时间
>
> 存取周期包括存/取操作 + 各种复位时间，接着进行下一次存/取操作，因此存取周期是略大于存取时间的
>
> 不过这道题目不需要区分这个，只用知道磁盘窃取总线一次使用总线存一次数据的时间就是一个存取周期即可

黑色就是准备数据，数据传输率是2MB/s，这里的M是速率单位，因此准备一次数据的时间就是：
$$
\frac{4B}{2MB} = 2\mu s
$$
题目的意思就是绿色，周期窃取一次表示占用了主存一次存了一次数据，这个时间占总的比率，显然就是100ns除以2us了：
$$
\frac{100ns}{2000ns} = 5\%
$$
**（3）**

直接按照题意除即可：
$$
\frac{26 \mu s}{2074 \mu s} \approx 1.25 \%
$$

## 4.22 DMA的计算题 + 周期窃取方式传输数据

![image-20241013183644219](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241013183644219.png)

**磁盘的数据传输率**

就是转速乘道容量：
$$
3000r/ min * 8KB = 50 r/s * 8 * 1024B = 409.6KBps
$$


**磁盘的平均等待时间：**

磁盘的平均等待时间就是磁盘旋转一周时间的一半，这里是10ms

这里没有说总线宽度，就默认准备好一个字节就传输一次数据，那么准备数据时间就是：
$$
\frac{1}{409.6KBps} \approx 2.4\mu s
$$
所以大概24个存取周期

这种题目，磁盘准备数据速度就是传输速率，准备好了之后就窃取一次存取周期存入主存一次数据

## 4.23 DMA传送方式以及流程（简答）

![image-20241013190734665](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241013190734665.png)

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241013190747618.png" alt="image-20241013190747618" style="zoom:50%;" />

## 4.24 程序查询，程序中断，DMA三种方式的理解（简答）

![image-20241018164355544](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241018164355544.png)

**（1）依赖软件还是硬件**

程序查询方式是在现行程序中插入一段IO指令组成的程序片段完成数据交换，因此是依赖软件

程序中断方式是软硬结合完成的，在中断响应中CPU通过中断隐指令完成，但是进行数据交换还是中断服务程序来处理的，因此数据传送还是依赖软件

> 程序中断方式比程序查询方式的好处在于程序查询方式在IO设备准备数据的时候CPU需要停下当前程序反复查询IO是否准备好数据，这就是踏步等待；而中断方式在IO准备数据的时候CPU仍然在并行执行当前程序，只是在数据交换的时候CPU中断去进行数据交换
>
> 但是中断方式在进行成批数据传输的时候也是需要等IO准备好然后一个数据，传输一个，然后再启动IO，等他准备好一个数据，再传输一个

DMA方式，DMA方式在数据传送的过程中是利用总线进行的，此时CPU仍然在执行自己的程序，因此就是靠硬件完成的，只不过DMA方式结束之后还是需要通过中断来进行DMA的收尾处理

> DMA方式比前两种好的原因是，在交换一批数据的时候是IO与内存直连交换的，即在交换数据的时候CPU也还是在并行执行现行程序，只有在DMA交换数据结束需要收尾的时候才出现中断

**（2）传输基本单位**

程序查询方式：一个字节或者一个字

中断方式：交换一个数据，一个字节或者一个字

DMA方式：一个数据块

**（3）工作并行性**

程序查询：现行程序与IO设备以及传送串行工作

中断方式：现行程序与IO设备并行工作，现行程序与IO传送串行工作

DMA方式：现行程序与IO设备，传送，并行工作

**（4）主动性**

程序查询方式：CPU主动，反复查询IO设备的工作状态，暂停现行程序执行，此为踏步等待

程序中断或者DMA方式：CPU被动接受中断或者DMA请求

**（5）传输速度**

程序中断方式：中断服务程序在负责传输数据的时候还需要保护现场等等的额外操作，因此速度最慢

程序查询方式：虽然这种方式有踏步等待，但是在实际传输数据的时候就是几条指令的事情，因此速度比程序中断方式要快

DMA方式：这种方式的数据传输是由硬件完成的，因此速度最快

**（6）经济性**

程序查询方式完全由软件完成，最经济

程序中断方式软硬结合，硬件相对不复杂，次经济

DMA方式的硬件结构最复杂，最贵

**（7）应用对象**

程序查询方式：适用于中，低速的设备传输数据，CPU不太忙的时候用这种方式

程序中断方式：适用于中，低速的实时或者比较紧急的处理过程

> 这里的实时主要强调的是速度，显然不能CPU停运然后慢慢等IO，紧急就不说了，中断经常用在出错等紧急事件中

DMA方式：适用于高速设备的IO交换过程

