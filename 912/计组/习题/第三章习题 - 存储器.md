# 第三章习题 - 存储器

## 3.5

![image-20240825110109164](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240825110109164.png)

**（1）**

存取周期和存取时间都是存储器存储速度的概念

存取时间是存储器的访问时间，也就是启动一次存储器读写到完成操作的时间

存取周期是存储器完成一个完整的读写所需要的时间，包括读写时间（存取时间）和后面的电路恢复的时间，是一个更加完整的概念，其时间略大于存取时间

**（2）**

存储器带宽是指单位时间内从存储器进出信息的最大数量，其计算方式是1s中所能够交换的最大信息量

也就是先计算1s有多少个周期，然后这些周期全部用来交换信息即数据总线的位数：
$$
\frac{1s}{T} * 32bit
$$


也就是频率乘总位数了，结果为：
$$
20MB/s
$$
注意带宽这里的K, M表示的是10的3次方，而不是2的10次方

## 3.6

![image-20240825111701516](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240825111701516.png)

**（1）**

主存一共有：
$$
\frac{64 * 2^{10} * 8}{32}个字 = 16K字
$$
如果主存是按字编址，那么描述方式就是存储单元个数（字的个数） * 存储字长；如果是按字节编址，那就直接是多少个字节

所以这里是16K * 32bit

**（2）**

![image-20240825112615634](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240825112615634.png)

上图中方框中的是按字节编址，旁边的是按字的地址，因为主存是按字节编址，所以字的地址是字节的地址的4倍，上图是按照大端方式的结果，不过大端方式只影响字中的数据的存放方式与字或者字节的地址没有关系

**（3）**

背诵题，这里不多赘述

## 3.7

![image-20240826102052978](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240826102052978.png)

**（1）**

根据题意应该是按字编址，因此可以存储：
$$
2^{20} * 32 / 8 = 4MB
$$
**（2）**
$$
\frac{2^{20} * 32}{2^9 * 2^{10} * 8} = 8
$$
**（3）**

上述芯片中，4个芯片一组作为位扩展，两组作为字扩展，因此1位作为地址选择信号

4个芯片位扩展，扩展为一个512K * 32的芯片组

2个芯片组字扩展形成一个1M * 32位的存储器

## 3.8

![image-20240826103535675](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240826103535675.png)

简答题，这里不多赘述，这题别想复杂，并不是考SRAM的时序图，根据直觉分析即可

## 3.9

简答题

## 3.10

![image-20240826103934423](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240826103934423.png)

刷新周期与存储周期相同，因此刷新时间也是250ns，1ms中刷新64次，也就是1ms有64 * 250ns用于刷新

所以所占时间为：
$$
\frac{64 * 250ns}{1000000ns} * 100\% = 1.6\%
$$

## 3.11

![image-20240827110448774](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827110448774.png)

芯片内部的存储单元成正方形排列，一个存储单元是1位，说明一个DRAM芯片是$2^{10} * 2^{10}$的排列，说明其有$2^{10}$行

异步刷新，说明每行在一个最大刷新间隔中只刷新一次，因此每隔$\frac{4000us}{2^{10}} = 3.9us$刷新一次

4ms中一共有1024个刷新周期

注意异步刷新就是最大刷新间隔中保证每行刷新一次，至于谁先刷，怎么安排保证大家都在各自的刷新间隔中被刷新一次则是硬件电路的事情，我们这里不必考虑

**这里的刷新周期其实就是两次刷新操作相隔的时间**

## 3.12

![image-20240827111205529](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827111205529.png)

这里的8K*8K指的是内部是一个正方形的8K * 8K位组成的64M * 1位（存储容量）的存储体，但是注意这一个存储体中其实有8K行而不是64M行，只是作为存储数据的时候每一个存储体64M个位中的一个位作为总的存储体64M * 4位中的一位

所以需要刷新的行就是8K = 8 * 1024行

因此两次刷新之间的时间就是$\frac{8000 us}{8 * 1024} = 0.9us$，**注意这个时间只能取小，不能四舍五入取大**，因为如果两行刷新的时间比理论值大，那么所有行刷新的总时间就超过了最大刷新间隔，这就会造成有的行被刷新一次之后第二次刷新与第一次刷新的间隔超过了自己的最大刷新间隔，其不能被及时刷新，会造成数据丢失

所谓刷新定时信号的周期时间，也就是两行之间的时间间隔，就是0.9us

8 * 1024个刷新周期



**注意异步刷新必须保证在一个最大刷新间隔时间中每一行必须被刷新一次，如果有一行没有被刷新，那这一行保存的数据经过了这最大刷新间隔的时间数据就会丢失**

## 3.13

![image-20240827113234491](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827113234491.png)

**（1）**

芯片用量：$\frac{64K * 32}{16K * 8} = 16$个

**（2）**

画这种DRAM扩展的逻辑示意图的流程：

（1）先画出所有的芯片，本题中一共有4 * 4个芯片，引出所有的数据位D0~D32

（2）画出两个控制器件，一个是地址多路选择器，一个是片选译码器

（3）对于地址多路选择器（三选一），因为DRAM是多路地址复用的，这里一组有16K的地址，所以应该有14位的地址，复用一下就是7位，所以行地址7位，列地址7位，并且还需要提供刷新地址，而一组有128行的存储单元，所以刷新地址也是七位

（4）对于片选译码器，这里有四组，因此输出就是4个片选信号，输入就是2位地址，所以这是一个2-4译码器，片选译码器的输入包含三个部分，最高的几位地址形成片选信号，行选通信号RAS，以及刷新信号，DRAM芯片组中的片使能信号与行选通信号结合了，在本题中有四组芯片，所以形成的片选信号（行选通信号就是4个）

（5）然后是一些细节收尾，列选通信号CAS和读写控制信号WE，这两个信号单独引出

（6）最后是芯片的连线，芯片之间的连线表示这条线上的数据都是一样的，连线分支表示总线上和分支上的数据都是一样的，对于地址分配，首先是最高的几位地址作为片选信号，然后是列地址，然后是行地址，刷新地址与行地址的位数一样，最后就是不用在意低电平还是高电平有效（圈圈不用画出来），箭头表示信号传递方向，地址线的宽度要宽一些

因此画出来的结果如下所示：

![image-20240827162002081](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827162002081.png)



**（3）**

注意分析芯片中存储的行列的时候，有以下几点：

1. 芯片中是一个正方形的存储单元矩阵，一个存储单元可以包含1个或者8的倍数个存储元（1位）
2. 所以对于64K * 8的芯片其就是一个$2^{8} * 2^{8}$的存储矩阵，这个矩阵中一个存储单元就是8位，对于题中的$128 * 128 * 8$的意思就是存储矩阵是128 * 128 但是一个存储单元是8位
3. 一组是4个这样的芯片进行位扩展，四组进行字扩展，所以这个存储体的总的行就是4 * 128 = 512行

但是注意刷新都是按照芯片进行的，所以刷新的行其实是128行，因此刷新周期就是：
$$
\frac{8000us}{128} = 62.5us
$$
当一个芯片刷新完成之后也就代表整个存储体的刷新就完成了，所以有128个刷新周期

**（4）**

这里还是以一个128行的芯片作为对象分析

分散式刷新是指将刷新分散到存取周期中，即存取周期的前半段存取，后半段刷新，因此这里的存取周期变成了1us，所以8ms中一共有$\frac{8ms}{1us} = 8000次$刷新

评均下来一行刷新了$\frac{8000}{128} = 62.5次$，比异步式刷新多刷新了61.5次

**（5）**

集中式刷新是在一个最大刷新间隔的末尾统一刷新所有的行，**刷新一行需要一个存取周期**，所以死时间就是128 * 0.5us = 64us

## 3.14*

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827190444742.png" alt="image-20240827190444742" style="zoom:67%;" />

**（1）**

地址空间分配方案如下所示

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827192319797.png" alt="image-20240827192319797" style="zoom:67%;" />

**所谓译码方案，就是16根地址线多少根作为片选地址，多少根作为片内地址**所以我们需要知道ROM和RAM各用了多少片

ROM的数量为：
$$
\frac{16K * 16}{8K * 8} = 4片
$$
两片为一组进行位扩展，两组作为字扩展

RAM的数量为：
$$
\frac{40K * 16}{8K * 8} = 10片
$$
2片为一组进行位扩展，5组作为字扩展，所以在图中表示出来就是：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827192727566.png" alt="image-20240827192727566" style="zoom:67%;" />

因此片内地址应该是8K，也就是需要13根地址线，而片选负责每个组，也就是7组，需要3根地址线即可，所以根上述每组分配的片选信号如下所示，注意RAM的地址从0110 0000 0000 0000开始，所以RAM区域对应的地址其最高三位必然大于等于3，因此3-8译码给其分配的是后5个信号，而不是从2开始的连续五个信号（从二开始的信号对应的最高三位地址线是010但是RAM不可能出现这样的地址）：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827192901575.png" alt="image-20240827192901575" style="zoom:67%;" />

**（2）**

画出SRAM和ROM的过程一般如下：

1. 将所需要的ROM和RAM摆好之后引出数据线连接到CPU，数据线8位一组，连到CPU

2. 画出译码器，分别将输出连到对应的片组，这里是将3-8译码器的7个输出连到对应的片组
   1. 译码器的输入有两个部分，一个是控制信号G2A, G2B, G1，以及地址信号（本例中是2个最高位地址），输出就是8个片选信号，这里只用了7个

3. 画出CPU，CPU包含四个部分：
   1. 数据部分，这里是16位的数据，每8位一组
   2. 片内地址部分，这里是0 ~ 12编号的地址线
   3. 片选部分，这里是13 ~ 15编号的地址线
   4. 访存控制信号MREQ和读写控制信号
4. 连线
   1. 数据线连到CPU的数据部分
   2. 片内地址从CPU引出来连到对应的片组
   3. 片选地址连到译码器，这里是最高三个地址线连到3-8译码器
   4. 访存控制信号连到译码器的控制段信号G2A和G2B，读写控制信号连到RAM
   5. 译码器的G1连到电源
   6. 最后连上片选信号即可
   7. 注意那些控制信号都是低电平有效，写出名字的时候加上一个横线即可

画图如下所示：

![image-20240827200540574](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827200540574.png)

或者采用横着摆放每一组，位扩展竖着摆放：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827195837807.png" alt="image-20240827195837807" style="zoom:67%;" />

第二种摆放的时候片内地址作为一个分支分别连到一组中的两个芯片，表示这一组被片选信号选中之后这两个芯片接收同样的13位地址，读取的数据分别作为16位数据的低八位和高八位

## 3.15*

![image-20240907150432271](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907150432271.png)

CPU有8根地址线，那很显然就是按字节编址了

6000H ~ 67FFH为系统程序区，需要使用ROM，占据$2^{11}$字节的内容

6800H ~ 6BFFH为用户程序区，显然是要用SRAM的，这里有3FFH个字节，即$2^{10}$个字节的内容

6C00H ~ 6FFFH为系统程序工作区，需要使用RAM，占据$2^{10}$字节的内容，除了系统程序区，其他的区域都使用RAM

并且上面三块地址是连在一起的，一共4K的空间，系统程序占用2K，然后RAM区占用2K

**主存地址分配图如下，所谓主存地址分配图，就是按题意，那些地址给系统程序区，那些地方给用户程序区，那些地方给系统程序工作区，画出这些区域的起始地址和大小：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907153137417.png" alt="image-20240907153137417" style="zoom:67%;" />

**所谓译码方案，就是地址线多少根作为片选地址，多少根作为片内选择地址**

我们先算出各需要多少片芯片：

ROM：2K，一块2K*8的ROM即可

RAM：2K，4块1K * 4的RAM，两块作为一组当作位扩展

> 再看看ROM和RAM分别占据的地址的二进制位的信息：
>
> `0110 0000 0000 0000 ~ 0110 0111 1111 1111`是ROM有4K
>
> `0110 1000 0000 0000 ~ 0110 1011 1111 1111`是用户RAM
>
> `0110 1100 0000 0000 ~ 0110 1111 1111 1111`是系统工作RAM

其实不管是怎么样，对于74138来说，地址线的最高两位一定是作为译码器的控制信号的，然后次高三位作为译码器的输入，通过上面的分析，地址线的高四位为0110是不变的，因此译码器的输出只有4和5两个信号

0110 0就是ROM，然后有2K的片内选择，剩下11根地址线作为片内选择信号

0110 1就是RAM，这里两片RAM作为一组，有一根地址线作为RAM的片选信号用于区分两个占据1K的RAM区域，剩下10根地址线作为片选信号

**因此译码方案如下：**

A15 ~ A11地址线作为74138的输入

当译码器的输出是4的时候是ROM，此时A10 ~ A0作为ROM的片内选择

当译码器的输出是5的时候是RAM，A10与译码器的5号输出工作作为RAM的片选，然后A9 ~ A0作为RAM的片内选择

A11 为0，则是ROM，译码器输出是4

A11为1，则是RAM，译码器输出是5

​	A10为0则为用户区

​	A10为1则为系统程序工作区

所以译码器输出是4的时候就锁死RAM的片选，这些RAM芯片的使能都是无效

译码器输出是5的时候就锁死ROM的片选，ROM芯片的使能无效，并用A10做RAM的片选，A11, A10 11是系统工作区，A11 A10 10是用户工作区

**画出的逻辑连接图如下所示：**

![image-20240907170653656](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907170653656.png)

**需要注意几个地方：**

（1）3-8译码器的G2A和G2B输入都是低电平且G1的输入是高电平的时候才工作有效，而这里的高四位一致是0110，A15是0，读写控制信号是0，A14是1，所以这里的A14连接到G1，而读写控制信号MREQ和A15连接到G2A和G2B

（2）3-8译码器的CBA才是对应的二进制的顺序，A是最低位，不要弄反了

（3）A11为0的时候译码器输出是4，此时ROM被选中，A0 ~ A10作为片内地址，RAM部分由于5的输出没有，所以就没有选中

（4）A11为1的时候译码器输出的是5，此时ROM就没有被选中，这里用两个与门来片选两组不同的RAM，A10为0表示选中低1K的RAM，A10为1表示选中高1K的RAM

（5）还有如果CS都是低电平有效的话，其实还得再与门上加上一个小圆圈

## 3.16

![image-20240907170917856](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907170917856.png)

**（1）**

按字节编址，显然范围是$2^{32}B$即4GB大小的寻址范围

**（2）**

8个

**（3）**
$$
\frac{512 * 8}{64 * 4} = 16个
$$
一共需要16 * 8 = 128个SRAM芯片

**（4）**

3位地址用来选择存储条，然后3位地址用来选择SRAM（一个存储条中有8组SRAM进行字扩展），最后24位地址用来片内选择地址

![image-20240907171916968](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907171916968.png)

**（5）**

这里只画出一个存储条中的逻辑连接，一共有8组SRAM，每一组SRAM有两个芯片用于位扩展，一个74138的译码芯片，对应地址是A28 ~ A0，画出的逻辑如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907172913422.png" alt="image-20240907172913422" style="zoom: 50%;" />

这里逻辑很简单就不再多说了，注意此时的74138的G2A和G2B的控制信号由CPU那边发出的片选信号控制

**（6）**

有8个存储片，因此这里的74138仍然是8个，并且地址的最高三位作为译码器的输入，此时CPU的访存控制信号MREQ作为译码器的控制信号：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907173743958.png" alt="image-20240907173743958" style="zoom:50%;" />

上图即为所画，这里就非常简单了，比15题简单多了

做这种题目，CPU就只有四个部分：地址，数据，访存控制MERQ信号，读写控制信号

译码器有三个部分：G2A, G2B, G1的控制信号，输入信号，输出信号

芯片有四个部分，片选信号，读写信号，地址，数据

对于线的连接，注意一根线及其分叉上的数据是一样的即可

## 3.17*

![image-20240907174132131](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907174132131.png)

**（1）**

除了2片1M*4位的SRAM之外还需要，1M\*8的SRAM，因此需要：
$$
\frac{1M * 8}{256K * 8} = 4片
$$
**（2）**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907175831691.png" alt="image-20240907175831691" style="zoom: 67%;" />

这道题目是SRAM作为位扩展的时候进行片选的做法，对于最高的地址位00表示选择第一个，01表示第二个，10表示第三个11表示第4个，因此这里需要一个2-4译码器，同时有两片SRAM不同字扩展，最高两位同时作为其地址位，这里与第15题很像，还是通过最高地址位的编码来确定片选

然后剩下的18位作为位扩展的片内地址

这里的256K*4的四块SRAM同时进行了字位扩展

## 3.18

![image-20240908104613028](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240908104613028.png)

**（1）**

64位机器，那也就说机器中的存储字长就是64位

这里模板块的容量表示是1M * 64，说明就是按字编址，所以所需的模板块的数量为：
$$
\frac{2^{26} * 64}{2^{20} * 64} = 64
$$
**（2）**
$$
\frac{2^{10} * 64}{2^8 * 16} = 16
$$
**（3）**
$$
2^{10}
$$
**（4）**

26位地址码最高6位用来选择模板块，次高2位用来选择DRAM（注意这里只需要两位，因为DRAM四个一组进行位扩展，四组一起进行字扩展），然后剩下16位用来片内选址

## 3.19

![image-20240908105743963](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240908105743963.png)

这段汇编代码中，`msg db “HEllo!”`表示的是定义一串字节型的数据

`align 4`表示紧接着这条指令后面的数据按4字节对齐，注意align的作用范围是紧接着其的一个数据

`dw `表示定义字型数据

另外注意的是IA32中存储字长是32位而不是16位

**（1）**

画这种存储数据图注意三点：

（1）画出字地址（起始就是字的起始字节地址）

（2）画出一个**字中的字节地址**（注意标出小端还是大端），小端则0字节在字的起始，大端则0字节在字的末尾

（3）**标出一个字地址中的高字节和底字节，注意是小端存放（低字节在低地址）还是大端（底字节在高地址）**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240908112703631.png" alt="image-20240908112703631" style="zoom:50%;" />

这里由于align的作用，导致紧接着‘o’的100这个16位数字的地址应该是按4字节对齐的，但是align的作用只在紧跟着它的数据，后面的数据还是按小端的方式按序存放

**（2）**

![image-20240908113234165](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240908113234165.png)

## 3.20

这是简答题，不再多说

## 3.21

![image-20240908113328791](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240908113328791.png)

这里的图应该是图3-36：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240908114114270.png" alt="image-20240908114114270" style="zoom:50%;" />

**这里是相联存储器的原理，其工作原理是这样的：**

（1）首先检索寄存器中存放查询的检索字，检索寄存器的位数与存储器中的存储字长相等，当然检索寄存器中不是所有的位都去查找，而是利用其中的关键字去与存储体中的单元匹配

（2）因此这里就需要屏蔽寄存器，这个寄存器的位数与检索寄存器的位数一样，屏蔽寄存器中的位为1，表示检索寄存器对应的位是一位关键字，屏蔽寄存器中的位为0表示检索寄存器中对应位的数据应该被屏蔽

（3）接着就将存储体中的所有存储单元与检索寄存器进行比较，结果放在匹配寄存器中，匹配寄存器的位数与存储单元的个数相等（很多位）如果这个存储单元能够跟检索寄存器匹配上，那么匹配寄存器中这个存储单元对应的位就为1

（4）这里的匹配的意思是一个存储单元中的对应的位（位置）以及位上的数据都要与检索寄存器中保持一致

所以这道题目中的屏蔽寄存器中的值就应该为：`0000 1111 0000 0000`

存储体中一个字长是16位，上图中一共有5个存储单元，只有第二个存储单元对应的位以及位上的数据符合`1011`，因此检索寄存器中的结果就是：`01000...`

## 3.22，3.23，3.24 简答

都是简答题，不再赘述

## 3.25

![image-20240909102934603](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240909102934603.png)

**（1）**

Cache的命中率，其实就是CPU访问Cache的次数除以CPU访问存储器的总数的比值

这里就是$\frac{4200}{4500} = \frac{14}{15}$

**（2）**

平均访存时间其实就是CPU访存的期望时间，CPU访问Cache的概率是$\frac{14}{15}$，所以时间就是：
$$
\frac{14}{15}*40 + \frac{1}{15}200 = \frac{760}{15} = 50ns
$$

## 3.26

![image-20240909103654888](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240909103654888.png)

在CPU发出访存地址之后，其需要按照一定的映射关系将这个内存地址映射到Cache中进行比较，然后才能判断是否在Cache中命中这个块，这就说明：

（1）内存中的内容的地址对应于放入Cache中的地址，这两个地址其实是有一个映射关系

（2）这个映射在Cache中就有三种



这里的容量是直接64KB，因此是按字节编址的，并且主存和Cache的块的大小都是一样的

**直接映射的地址关系有以下几个注意的点：**

（1）主存的地址被分为区号E，区内块号B，块内地址W

（2）主存中的每个区中的块只能放到Cache中的固定的块号处，映射关系是$b = B mod 2^c$，这里b是Cache中的块号，B是主存中一个区中的块号，$2^c$是整个Cache的块的数量

> 也就是说主存中的不同区相同块号的数据块放入Cache中时会发生冲突，但是同一个区的数据块放入Cache中时不会发生冲突



先计算Cache中有多少块：
$$
2^c = \frac{64KB}{16B} = 4K
$$
因此主存中的一个区中的数据块也是4K个，因此主存地址中B应该时12位，一个数据块是16B，所以块内地址应该是4位

所以主存中的后16位是块号B加上块内地址W，前16位是区号

所以这里的`B = 56F`，因此在Cache中其块地址也就是56F，当然，这只是这个数据所在的数据块在Cache中的地址，这里还需要加上块内的偏移，因此这个存储单元的地址（这个字节的地址）就是56F8

关于这里为什么是56F8，首先其是在第56F块中，一块有16个字节，所以这一块的起始字节就是56F0，然后块内偏移是8，所以这个数据字节的地址就是56F8了

## 3.27

![image-20240911171721842](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240911171721842.png)

这里的按行优先的意思是程序中行相邻的数据在内存中存放在一起

按列优先的意思是程序中列相邻的数据在内存中放在一起

由于程序的访问是按行进行的，因此如果存储的时候按行优先存储会使得数据访问具有局部性，一段时间内集中访问的数据会在一个块中，这时Cache的命中率更高

## 3.28

![image-20240911172018145](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240911172018145.png)

**组相联映射是全相联映射和直接相联映射的复合，其特征为：**

（1）Cache和内存均分组，且Cache的组与内存的组中的数据块个数相同

（2）主存中先分区，一个区中的组的个数与Cache中组的个数相等

（3）Cache的组和内存的组采用的是直接相联映射，即主存中每个区中的第i组只能放到Cahce中的第i组

（4）主存中的组内的数据块和Cahce中组内的数据块是按照全相联映射的方式的，即主存中的一个区中的第i组中的某个数据块可以映射道Cahce中第i组中的任意一个数据块

（5）CPU发出的访存地址被分为区号E，组号G，组内块号B和块内地址W四个部分，Cache的地址被分为组号g，组内块号b和块内地址w四个部分



所以这道题目

Cache中4块一组，一共16组，因此主存中一个区中应该是16组共64块

所以主存中有$2^6$个区

$2^6$个区，因此区号E 6位

一个区16组，所以组号G 4位

一个组4块，所以块号B 2位

一块为128B，所以块内地址W 7位

因此主存地址就是19位

同理Cache地址只有g, b, w所以两者的地址如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240911174128854.png" alt="image-20240911174128854" style="zoom:67%;" />

## 例 3.4

![image-20240911173604740](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240911173604740.png)

在这道题目中所谓标记字段其实就是记录Cache中存放的是主存中的哪个块而多出的附加信息

全相联中就是主存的块号

直接相联中就是主存的区号

组相联中就是主存的区号和块号

这里标记字段需要满足其大小可以代表主存中的对应的属性的数量，因此其位数就是主存地址中对应属性字段的位数

**（1）**

直接相联映射

主存中的一个区的大小与Cache一样，所以区的个数为：$\frac{2^{32}}{4K * 16} = 2^{16}$

因此这里就是16位

**（2）**

2路组相联，即一组中有2块

主存中的一个区的大小与Cache的大小一样，所以一共有$\frac{2^{32}}{2^{12}(4K) * 16} = 2^{16}$个区

每组中2块

所以这里的标记字段就是17位

**（3）**

同上，区号16位，一组4块，块号就是2位，所以标记字段18位

**（4）**

直接就是块号了主存中共有块$\frac{2^{32}}{16} = 2^{28}$，所以这里就是28位



**这里需要分清每种映射方式形成的块表的比较手段**

**（1）全相联映射方式**

主存和Cache都只有块号和块内地址，形成的块表的一个字段由主存的块号和Cache的块号再加上一个有效位组成，有效位为1，那就说明这个字段中主存的块已经在Cache中了，**此时b + W就是Cache中的地址**

![image-20240911175324281](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240911175324281.png)

**（2）直接相联映射方式**

主存被划分为区E + 区内块号B + 块内地址W，Cache被划分为块号e + 块内地址w，这里不仅块的大小一样，并且主存中一个区中的块的数量与Cache中块的数量是一样的，直接相联映射中主存一个区中的所有块从上到下映射到Cache中的所有块，因此对于整个主存的块号与Cache的块号（注意不是B，而是E + B）来讲其实是一个模关系，模的其实就是Cache的块的数目；

对于直接相联方式的查找方法，首先CPU获得主存的地址，E + B + W，接着CPU根据区内块号B去访问区表，由于每个区中块号都是一样的，所以不同的区同样的B那其一定占据Cache中同一个位置，所以这里用B作为地址访问区表，区表中的一个字段就表示Cache中对应的块的占位情况，区表中一个字段由区号和一个有效位组成，如果此时的有效位为1，那就说明Cache中对应的块的位置已经被占据了，此时再看看区表中的E，如果跟主存中的区号E一样，那就表示命中，**命中时B和W就是Cache的块号和块内地址**

![image-20240911175335174](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240911175335174.png)

**（3）组相联映射方式**

这种方式主存被划分为区号E，区内组号G，组内块号B，块内地址W；Cache被划分为组号g，组内块号e，块内地址w

这时内存中的组和Cache中的组对应时采用的时直接相联映射方式，即主存中一个区中的组的个数与Cache中的组的个数一样，主存中一个区中的组按顺序从上到下依次可以存放在Cache中，也就是说主存中的E + G其实对于Cache的g其实是一个模关系，模的就是Cache的组数

接着此时主存中的这个组和Cache中对应的这个组中的块采用的是全相联的映射方式

对于组相联的映射方式的查找方法

首先一个区中的组是按照直接相联映射的，因此跟直接相联的查找方式类似，这里用组号作为地址去查找组表，所以组表中应该有一个区号

然后由于一个组中的块是按照全相联映射的，所以这里需要确定这个组中的块以及Cache中的一个块是否一致

所以这里的组表的一个字段由区号E（直接相联映射），块号B，Cache块号b（全相联映射），有效位四个组成

在直接相联映射中，使用组号G作为地址去查找组表，这时查找到的其实是一堆块表字段，每个字段表示Cache中组号B中的所有块的占据情况，然后看区号E + b，这里直接用主存中的E + B与用G查找到的所有的E + b进行对比，如果对的上，那就命中，否则没有命中，**此时Cache的地址就是G + b + W**

![image-20240911181555891](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240911181555891.png)

## 3.29

![image-20240911172039702](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240911172039702.png)

   组相联映射

内存的地址分为：区号E，组号G，块号B，块内地址W

Cache地址分为：组号g，块号b，块内地址w

其中内存的组与Cache中的组采用的是直接相联映射，内存中每个区中固定的组只能放在Cahce中固定的组的位置处

组内的块则采用的是全相联映射

内存的一个区的大小等于Cache的大小，一个区中的组数与Cache中的组数相等

主存一共2M字，Cache8K字，因此这里主存中就有$\frac{2M}{8K} = 2^8$个区，因此区号E就是8位

一组两块，所以一个组的大小就是$2^9$个字，所以一个Cahce就有$\frac{2^{13}}{2^9} = 2^4$个组，因此组号G就是4位

一组两块，因此一组中的块号B就是1位

一个块中有256个字，所以块内地址就是8位

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240912114421256.png" alt="image-20240912114421256" style="zoom:67%;" />

当在组表中匹配上之后块表字段中的组号G，即内存中的组号G作为Cache中的组号g，组表字段中的块号b作为Cache的组内块号b，然后内存地址中的块内地址W作为Cahce中的块内地址w，即Cache中的地址就是G + b + W -> g + b + w

**对于地址组成的理解：**

对于内存地址的组成，比如E + G + B + W

可以这样理解，W其实就是在第E区，第G组，第B块中第W个字（字节）

对于Cache地址的组成，g + b + w

这个含义也是第g组，第b块中的第w个字（字节）

所以对于组相联映射，其本质是将第E区，第G组，第B块放入到Cache中第g组，第b块上

由于上文的直接相联映射关系，内存一个区中的组的个数与Cache中的组的个数相等，并且内存中的第G组也一定是放入到Cache中第G组上，因此Cache中的g = G

对于放入到Cahce中的哪一个块，则是块表中的字段b决定

对于块中的第W个字节，其在块中的位置没有变化，还是第W个字（字节），所以在Cache中也是第W个字（字节），因此w = W

所以Cache中这个字（字节）的地址就是g + b + w = G + b + W了

**注意上述的+号表示拼接**

## 3.30

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240912152341155.png" alt="image-20240912152341155" style="zoom:67%;" />

**（1）**

按照下面这个表画出来然后计算即可：

![image-20240912152740880](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240912152740880.png)

这个表的横向表示程序执行的顺序，表中的一个列表示此时程序执行完毕之后Cache中所有块的存储情况

这里LRU替换算法，即近期最少使用算法，当Cache中的块出现冲突的时候将近期最少使用的块替换出去，这里由于是直接相联映射，每一块的位置其实是固定的，这里出现冲突的时候直接将上一块换出去即可

命中率就是4 / 15

**（2）**

跟第一问一样：

![image-20240912153957920](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240912153957920.png)

命中率3 / 15

**（3）**

这里采用二路组相联映射，两块为一组，8块为一个区，即4组为一个区

组采用直接相联映射，组中的块采用全相联映射

下方表格中最左侧的Cache块0后面的括号表示其属于Cache中哪一组

最上方一行，括号中表示是内存中的第几块，属于哪个区，哪个组，组中第几块

这里组内采用全相联映射的时候如果有空则按顺序从上到下放入组中

注意组相联映射的时候**并不是**第一个区中的某个组有块占用了Cache中的某个组中的空间，然后下个区中的相同的组中的块放入Cache中时要将前面的区中的组的块全部换出来再放入这个区中的对应的组里面的块

而是所有的区中相同的组中所有的块在Cache固定的组中使用全相联映射，至于怎么交换出去，本题中就使用的时LRU算法

| 程序执行顺序  | 1（1，0，0，1） | 2（2，0，1，0） | 3（4，0，2，0） | 4（8，1，0，0） | 5（16，2，0，0） | 6（21，2，2，1） | 7（56，7，0，0） | 8（45，5，2，1） | 9（2）    | 10（4） | 11（6，0，3，0） | 12（7，0，3，1） | 13（5，0，2，1） | 14（4）   | 15（7）   |
| ------------- | --------------- | --------------- | --------------- | --------------- | ---------------- | ---------------- | ---------------- | ---------------- | --------- | ------- | ---------------- | ---------------- | ---------------- | --------- | --------- |
| Cache块0（0） | 1               | 1               | 1               | 1               | 16               | 16               | 16               | 16               | 16        | 16      | 16               | 16               | 16               | 16        | 16        |
| 块1（0）      |                 |                 |                 | 8               | 8                | 8                | 56               | 56               | 56        | 56      | 56               | 56               | 56               | 56        | 56        |
| 块2（1）      |                 | 2               | 2               | 2               | 2                | 2                | 2                | 2                | 2（命中） | 2       | 2                | 2                | 2                | 2         | 2         |
| 块3（1）      |                 |                 |                 |                 |                  |                  |                  |                  |           |         |                  |                  |                  |           |           |
| 块4（2）      |                 |                 | 4               | 4               | 4                | 4                | 4                | 45               | 45        | 45      | 45               | 45               | 5                | 5         | 5         |
| 块5（2）      |                 |                 |                 |                 |                  | 21               | 21               | 21               | 21        | 4       | 4                | 4                | 4                | 4（命中） | 4         |
| 块6（3）      |                 |                 |                 |                 |                  |                  |                  |                  |           |         | 6                | 6                | 6                | 6         | 6         |
| 块7（3）      |                 |                 |                 |                 |                  |                  |                  |                  |           |         |                  | 7                | 7                | 7         | 7（命中） |

命中率就是3 / 15 = 20 %

这里使用的是LRU算法，即近期最不使用的算法，注意这个算法与LFU算法的区别

LRU是时间的角度比如A块在tk的时候被访问了3次，而B块在tk + 1的时候被访问了2次，但是t k + 1的时候访问的是B，那么下次有个块进来的时候是换A而不是换B，因为B比A更接近使用了一次

LFU是次数角度，同上，则换出的是B而不是A，因此A的使用次数比B多

## 3.31

![image-20240914151739777](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240914151739777.png)

写回法和写直达法是用来处理CPU写入数据到存储器时，Cache和主存的内容不同步的问题的

写直达法是指CPU写入Cache的同时写主存，因此这里写主存也进行了100次

写回法是CPU直接写入Cache中对应的这个块，只有当这个块被换出Cache的时候才将Cache中的内容更新到主存，所以写回法至少要向主存写入一次；但是具体写入多少次这就跟替换策略以及块的大小有关了

**CPU在执行写操作的时候的具体流程：**

（1）如果要写入的块就在Cache中，即命中，则采用上述两个策略中的一个执行即可

（2）如果要写入的块不在Cache中，即没有命中，这时需要解决写的时候是否将块放入Cache的问题，有以下两种方式来处理

​	i 不按写分配法，即只写入主存，不把这个数据块放入Cache

​	ii 按写分配法，首先写入主存，然后将这个块调入到Cache中

对于采用写回法策略的机器，即只有将Cache中的块换出去的时候才将数据写入主存，其如果在写的时候没有命中采用的是写分配法，即先写入主存，然后再调入Cache中

对于写直达法策略的机器，即CPU写入的时候Cache和主存同步写入，其如果在写的时候块不在Cache中，其采用的策略时不按写分配法

## 3.32*

![image-20240914153326246](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240914153326246.png)

**磁盘的构成：**

磁盘由一组盘片组成，每一个盘片都有一些同心圆，称为磁道，最外侧的磁道开始编号，编号为0

这样不同盘面上的相同编号的磁道就形成了一个圆柱体，称为一个柱面，柱面上的磁头从上到下从0开始编号

> 写入操作的时候是按照柱面进行的，即在一组磁盘的一个柱面上从上到下写入数据，只有这个柱面写满了，才移动到下一个柱面

一个磁道，被划分为若干个圆弧线，一个圆弧线称为扇区，一个磁道上的所有扇区的长度是一样的，当然扇区的大小也是一样的

> 硬盘以扇区进行最小单位存取，磁盘可寻址的最小单位是扇区

硬盘的地址格式如下所示：

![image-20240914154425199](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240914154425199.png)

驱动器号是用来区分不同的磁盘系统的，后面的柱面号，盘面号，扇区号这三个是一个磁盘的数据

**（1）**

其实就是一个盘面有多少个磁道，这里用道密度乘距离即可
$$
\frac{33 - 22}{2} * 40 = 220道
$$


**（2）**

磁盘的总容量，其实就是整个磁盘的所有位的个数

盘面个数：
$$
6 *2 - 2 = 10
$$
总磁道个数：
$$
2200道
$$
一个磁道的容量，这里用最内层的算：
$$
2\pi*\frac{22}{2} *500 = 4319.56B
$$
总容量：
$$
2200 * 4319.56 \approx 9MB
$$
注意在容量这里$K = 1024B，M = 1024K$

**（3）**

**磁盘的传输率：**就是单位时间的数据传输量

**内部传输率**

就是将磁盘的内容读到缓存的过程，其跟转速和磁道容量有关，当然是转到哪里读哪里

转速单位一般是r / min，表示每分钟读了多少个磁道，很显然这里直接用转速乘磁道容量就是内部传输率了：
$$
传输率 = 转速(r / min) * 磁道容量(B / r)
$$
**外部传输率**

这个是将磁盘中的内容读到外面计算机中的速率，这个东西与硬盘的接口和缓存的大小有关

所以这一题中的传输率就是：
$$
5400(r/min) *(22*\pi *500)(b/r)  =186516000 (b/min) = 3108600 (b/s,bps) = 388575(B/s, Bps) = 388.575(KB/s, KBps)
$$
这里最好从头算，如果直接用第二问的道容量结果会有比较大的误差

另外，在速率中$MB = 10^3 KB$，$KB = 10^3 B$，这里与容量是不同的但是字节和位的换算还是乘8$B = 8b$

**（4）**

磁盘直接寻址的最小单位就是扇区

硬盘的地址格式如下所示：

![image-20240914154425199](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240914154425199.png)

两台盘驱，因此这里驱动号就是1位

220个柱面，因此这里柱面就应该是8位

10个盘面，盘面就是4位

一个磁道容量为4319.56B，一个扇区为512B，所以扇区有8.4个，这里向下取整，不满一个扇区的丢弃，于是扇区位数就是3位

![image-20240914160717653](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240914160717653.png)

**（5）**

同一个柱面上，因为其实一个磁盘系统中磁头其实是一个磁头组分部在不同的盘面，直接在同一个柱面上读写，可以减少磁头找道的时间

## 3.33

![image-20240916150847875](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240916150847875.png)

**（1）**

一个磁道的容量：
$$
12 * 512B = 6144B
$$
一个盘面的容量：
$$
200 * 6144B = 1228800B = 1200KB
$$
总容量：
$$
1200KB * 8 = 9.375MB
$$
**（2）**

平均寻址时间是磁头从起始位置先到目标磁道位置，再到目标扇区的时间，因此平均寻址时间由两个部分组成：

1. 平均寻道时间

磁头到目标磁道所需的平均时间

2. 平均等待时间

磁头到目标磁道之后等待所需要访问的扇区旋转到磁头下方所需的平均时间，一般取盘片旋转一周所需的时间的一半（通过转速来计算）

所以这里的平均寻址时间就是，这里题目中的平均定位时间就是平均寻道时间：
$$
8ms + \frac{1}{2} \frac{1}{\frac{7200}{60*1000} rpms} = 12.1ms
$$
**（3）**

磁道容量：
$$
6144B
$$
转速：$7200 rpm$

数据传输率：
$$
6144B * \frac{7200}{60} r/s = 737280 B/s = 737.28 KBps
$$
这里的K是10^3

## 3.34*

![image-20240916152244689](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240916152244689.png)

**（1）**

一个盘面200道

所以一个盘面的容量为：
$$
200 * 12288B = 2457600B = 2400KB
$$
因此磁盘的总容量为：
$$
2400KB * 6 = 14400KB = 14.0625MB
$$
**（2）**

所谓位密度，就是单位长度的位的个数，容量除以道长度即可

内层：
$$
\frac{12288B}{22cm * \pi} = 177.79 B/cm = 1422.32 b/cm \approx 142 b/mm
$$
外层：
$$
\frac{12288B}{(22+4)cm * \pi} = 1203.50 b/cm \approx120 b/mm
$$
**（3）**
$$
\frac{7200}{60}r/s * 12288B = 1474560 Bps = 1474.560 KBps \approx 1.5MBps
$$
速率中的K, M分别表示10^3, 10^6
