# 第三章习题 - 存储器

## 3.5

![image-20240825110109164](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240825110109164.png)

**（1）**

存取周期和存取时间都是存储器存储速度的概念

存取时间是存储器的访问时间，也就是启动一次存储器读写到完成操作的时间

存取周期是存储器完成一个完整的读写所需要的时间，包括读写时间（存取时间）和后面的电路恢复的时间，是一个更加完整的概念，其时间略大于存取时间

**（2）**

存储器带宽是指单位时间内从存储器进出信息的最大数量，其计算方式是1s中所能够交换的最大信息量

也就是先计算1s有多少个周期，然后这些周期全部用来交换信息即数据总线的位数：
$$
\frac{1s}{T} * 32bit
$$


也就是频率乘总位数了，结果为：
$$
20MB/s
$$
注意带宽这里的K, M表示的是10的3次方，而不是2的10次方

## 3.6

![image-20240825111701516](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240825111701516.png)

**（1）**

主存一共有：
$$
\frac{64 * 2^{10} * 8}{32}个字 = 16K字
$$
如果主存是按字编址，那么描述方式就是存储单元个数（字的个数） * 存储字长；如果是按字节编址，那就直接是多少个字节

所以这里是16K * 32bit

**（2）**

![image-20240825112615634](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240825112615634.png)

上图中方框中的是按字节编址，旁边的是按字的地址，因为主存是按字节编址，所以字的地址是字节的地址的4倍，上图是按照大端方式的结果，不过大端方式只影响字中的数据的存放方式与字或者字节的地址没有关系

**（3）**

背诵题，这里不多赘述

## 3.7

![image-20240826102052978](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240826102052978.png)

**（1）**

根据题意应该是按字编址，因此可以存储：
$$
2^{20} * 32 / 8 = 4MB
$$
**（2）**
$$
\frac{2^{20} * 32}{2^9 * 2^{10} * 8} = 8
$$
**（3）**

上述芯片中，4个芯片一组作为位扩展，两组作为字扩展，因此1位作为地址选择信号

4个芯片位扩展，扩展为一个512K * 32的芯片组

2个芯片组字扩展形成一个1M * 32位的存储器

## 3.8

![image-20240826103535675](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240826103535675.png)

简答题，这里不多赘述，这题别想复杂，并不是考SRAM的时序图，根据直觉分析即可

## 3.9

简答题

## 3.10

![image-20240826103934423](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240826103934423.png)

刷新周期与存储周期相同，因此刷新时间也是250ns，1ms中刷新64次，也就是1ms有64 * 250ns用于刷新

所以所占时间为：
$$
\frac{64 * 250ns}{1000000ns} * 100\% = 1.6\%
$$

## 3.11

![image-20240827110448774](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827110448774.png)

芯片内部的存储单元成正方形排列，一个存储单元是1位，说明一个DRAM芯片是$2^{10} * 2^{10}$的排列，说明其有$2^{10}$行

异步刷新，说明每行在一个最大刷新间隔中只刷新一次，因此每隔$\frac{4000us}{2^{10}} = 3.9us$刷新一次

4ms中一共有1024个刷新周期

注意异步刷新就是最大刷新间隔中保证每行刷新一次，至于谁先刷，怎么安排保证大家都在各自的刷新间隔中被刷新一次则是硬件电路的事情，我们这里不必考虑

**这里的刷新周期其实就是两次刷新操作相隔的时间**

## 3.12

![image-20240827111205529](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827111205529.png)

这里的8K*8K指的是内部是一个正方形的8K * 8K位组成的64M * 1位（存储容量）的存储体，但是注意这一个存储体中其实有8K行而不是64M行，只是作为存储数据的时候每一个存储体64M个位中的一个位作为总的存储体64M * 4位中的一位

所以需要刷新的行就是8K = 8 * 1024行

因此两次刷新之间的时间就是$\frac{8000 us}{8 * 1024} = 0.9us$，**注意这个时间只能取小，不能四舍五入取大**，因为如果两行刷新的时间比理论值大，那么所有行刷新的总时间就超过了最大刷新间隔，这就会造成有的行被刷新一次之后第二次刷新与第一次刷新的间隔超过了自己的最大刷新间隔，其不能被及时刷新，会造成数据丢失

所谓刷新定时信号的周期时间，也就是两行之间的时间间隔，就是0.9us

8 * 1024个刷新周期



**注意异步刷新必须保证在一个最大刷新间隔时间中每一行必须被刷新一次，如果有一行没有被刷新，那这一行保存的数据经过了这最大刷新间隔的时间数据就会丢失**

## 3.13

![image-20240827113234491](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827113234491.png)

**（1）**

芯片用量：$\frac{64K * 32}{16K * 8} = 16$个

**（2）**

画这种DRAM扩展的逻辑示意图的流程：

（1）先画出所有的芯片，本题中一共有4 * 4个芯片，引出所有的数据位D0~D32

（2）画出两个控制器件，一个是地址多路选择器，一个是片选译码器

（3）对于地址多路选择器（三选一），因为DRAM是多路地址复用的，这里一组有16K的地址，所以应该有14位的地址，复用一下就是7位，所以行地址7位，列地址7位，并且还需要提供刷新地址，而一组有128行的存储单元，所以刷新地址也是七位

（4）对于片选译码器，这里有四组，因此输出就是4个片选信号，输入就是2位地址，所以这是一个2-4译码器，片选译码器的输入包含三个部分，最高的几位地址形成片选信号，行选通信号RAS，以及刷新信号，DRAM芯片组中的片使能信号与行选通信号结合了，在本题中有四组芯片，所以形成的片选信号（行选通信号就是4个）

（5）然后是一些细节收尾，列选通信号CAS和读写控制信号WE，这两个信号单独引出

（6）最后是芯片的连线，芯片之间的连线表示这条线上的数据都是一样的，连线分支表示总线上和分支上的数据都是一样的，对于地址分配，首先是最高的几位地址作为片选信号，然后是列地址，然后是行地址，刷新地址与行地址的位数一样，最后就是不用在意低电平还是高电平有效（圈圈不用画出来），箭头表示信号传递方向，地址线的宽度要宽一些

因此画出来的结果如下所示：

![image-20240827162002081](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827162002081.png)



**（3）**

注意分析芯片中存储的行列的时候，有以下几点：

1. 芯片中是一个正方形的存储单元矩阵，一个存储单元可以包含1个或者8的倍数个存储元（1位）
2. 所以对于64K * 8的芯片其就是一个$2^{8} * 2^{8}$的存储矩阵，这个矩阵中一个存储单元就是8位，对于题中的$128 * 128 * 8$的意思就是存储矩阵是128 * 128 但是一个存储单元是8位
3. 一组是4个这样的芯片进行位扩展，四组进行字扩展，所以这个存储体的总的行就是4 * 128 = 512行

但是注意刷新都是按照芯片进行的，所以刷新的行其实是128行，因此刷新周期就是：
$$
\frac{8000us}{128} = 62.5us
$$
当一个芯片刷新完成之后也就代表整个存储体的刷新就完成了，所以有128个刷新周期

**（4）**

这里还是以一个128行的芯片作为对象分析

分散式刷新是指将刷新分散到存取周期中，即存取周期的前半段存取，后半段刷新，因此这里的存取周期变成了1us，所以8ms中一共有$\frac{8ms}{1us} = 8000次$刷新

评均下来一行刷新了$\frac{8000}{128} = 62.5次$，比异步式刷新多刷新了61.5次

**（5）**

集中式刷新是在一个最大刷新间隔的末尾统一刷新所有的行，**刷新一行需要一个存取周期**，所以死时间就是128 * 0.5us = 64us

## 3.14*

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827190444742.png" alt="image-20240827190444742" style="zoom:67%;" />

**（1）**

地址空间分配方案如下所示

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827192319797.png" alt="image-20240827192319797" style="zoom:67%;" />

**所谓译码方案，就是16根地址线多少根作为片选地址，多少根作为片内地址**所以我们需要知道ROM和RAM各用了多少片

ROM的数量为：
$$
\frac{16K * 16}{8K * 8} = 4片
$$
两片为一组进行位扩展，两组作为字扩展

RAM的数量为：
$$
\frac{40K * 16}{8K * 8} = 10片
$$
2片为一组进行位扩展，5组作为字扩展，所以在图中表示出来就是：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827192727566.png" alt="image-20240827192727566" style="zoom:67%;" />

因此片内地址应该是8K，也就是需要13根地址线，而片选负责每个组，也就是7组，需要3根地址线即可，所以根上述每组分配的片选信号如下所示，注意RAM的地址从0110 0000 0000 0000开始，所以RAM区域对应的地址其最高三位必然大于等于3，因此3-8译码给其分配的是后5个信号，而不是从2开始的连续五个信号（从二开始的信号对应的最高三位地址线是010但是RAM不可能出现这样的地址）：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827192901575.png" alt="image-20240827192901575" style="zoom:67%;" />

**（2）**

画出SRAM和ROM的过程一般如下：

1. 将所需要的ROM和RAM摆好之后引出数据线连接到CPU，数据线8位一组，连到CPU

2. 画出译码器，分别将输出连到对应的片组，这里是将3-8译码器的7个输出连到对应的片组
   1. 译码器的输入有两个部分，一个是控制信号G2A, G2B, G1，以及地址信号（本例中是2个最高位地址），输出就是8个片选信号，这里只用了7个

3. 画出CPU，CPU包含四个部分：
   1. 数据部分，这里是16位的数据，每8位一组
   2. 片内地址部分，这里是0 ~ 12编号的地址线
   3. 片选部分，这里是13 ~ 15编号的地址线
   4. 访存控制信号MREQ和读写控制信号
4. 连线
   1. 数据线连到CPU的数据部分
   2. 片内地址从CPU引出来连到对应的片组
   3. 片选地址连到译码器，这里是最高三个地址线连到3-8译码器
   4. 访存控制信号连到译码器的控制段信号G2A和G2B，读写控制信号连到RAM
   5. 译码器的G1连到电源
   6. 最后连上片选信号即可
   7. 注意那些控制信号都是低电平有效，写出名字的时候加上一个横线即可

画图如下所示：

![image-20240827200540574](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827200540574.png)

或者采用横着摆放每一组，位扩展竖着摆放：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240827195837807.png" alt="image-20240827195837807" style="zoom:67%;" />

第二种摆放的时候片内地址作为一个分支分别连到一组中的两个芯片，表示这一组被片选信号选中之后这两个芯片接收同样的13位地址，读取的数据分别作为16位数据的低八位和高八位

## 3.15*

![image-20240907150432271](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907150432271.png)

CPU有8根地址线，那很显然就是按字节编址了

6000H ~ 67FFH为系统程序区，需要使用ROM，占据$2^{11}$字节的内容

6800H ~ 6BFFH为用户程序区，显然是要用SRAM的，这里有3FFH个字节，即$2^{10}$个字节的内容

6C00H ~ 6FFFH为系统程序工作区，需要使用RAM，占据$2^{10}$字节的内容，除了系统程序区，其他的区域都使用RAM

并且上面三块地址是连在一起的，一共4K的空间，系统程序占用2K，然后RAM区占用2K

**主存地址分配图如下，所谓主存地址分配图，就是按题意，那些地址给系统程序区，那些地方给用户程序区，那些地方给系统程序工作区，画出这些区域的起始地址和大小：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907153137417.png" alt="image-20240907153137417" style="zoom:67%;" />

**所谓译码方案，就是地址线多少根作为片选地址，多少根作为片内选择地址**

我们先算出各需要多少片芯片：

ROM：2K，一块2K*8的ROM即可

RAM：2K，4块1K * 4的RAM，两块作为一组当作位扩展

> 再看看ROM和RAM分别占据的地址的二进制位的信息：
>
> `0110 0000 0000 0000 ~ 0110 0111 1111 1111`是ROM有4K
>
> `0110 1000 0000 0000 ~ 0110 1011 1111 1111`是用户RAM
>
> `0110 1100 0000 0000 ~ 0110 1111 1111 1111`是系统工作RAM

其实不管是怎么样，对于74138来说，地址线的最高两位一定是作为译码器的控制信号的，然后次高三位作为译码器的输入，通过上面的分析，地址线的高四位为0110是不变的，因此译码器的输出只有4和5两个信号

0110 0就是ROM，然后有2K的片内选择，剩下11根地址线作为片内选择信号

0110 1就是RAM，这里两片RAM作为一组，有一根地址线作为RAM的片选信号用于区分两个占据1K的RAM区域，剩下10根地址线作为片选信号

**因此译码方案如下：**

A15 ~ A11地址线作为74138的输入

当译码器的输出是4的时候是ROM，此时A10 ~ A0作为ROM的片内选择

当译码器的输出是5的时候是RAM，A10与译码器的5号输出工作作为RAM的片选，然后A9 ~ A0作为RAM的片内选择

A11 为0，则是ROM，译码器输出是4

A11为1，则是RAM，译码器输出是5

​	A10为0则为用户区

​	A10为1则为系统程序工作区

所以译码器输出是4的时候就锁死RAM的片选，这些RAM芯片的使能都是无效

译码器输出是5的时候就锁死ROM的片选，ROM芯片的使能无效，并用A10做RAM的片选，A11, A10 11是系统工作区，A11 A10 10是用户工作区

**画出的逻辑连接图如下所示：**

![image-20240907170653656](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907170653656.png)

**需要注意几个地方：**

（1）3-8译码器的G2A和G2B输入都是低电平且G1的输入是高电平的时候才工作有效，而这里的高四位一致是0110，A15是0，读写控制信号是0，A14是1，所以这里的A14连接到G1，而读写控制信号MREQ和A15连接到G2A和G2B

（2）3-8译码器的CBA才是对应的二进制的顺序，A是最低位，不要弄反了

（3）A11为0的时候译码器输出是4，此时ROM被选中，A0 ~ A10作为片内地址，RAM部分由于5的输出没有，所以就没有选中

（4）A11为1的时候译码器输出的是5，此时ROM就没有被选中，这里用两个与门来片选两组不同的RAM，A10为0表示选中低1K的RAM，A10为1表示选中高1K的RAM

（5）还有如果CS都是低电平有效的话，其实还得再与门上加上一个小圆圈

## 3.16

![image-20240907170917856](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907170917856.png)

**（1）**

按字节编址，显然范围是$2^{32}B$即4GB大小的寻址范围

**（2）**

8个

**（3）**
$$
\frac{512 * 8}{64 * 4} = 16个
$$
一共需要16 * 8 = 128个SRAM芯片

**（4）**

3位地址用来选择存储条，然后3位地址用来选择SRAM（一个存储条中有8组SRAM进行字扩展），最后24位地址用来片内选择地址

![image-20240907171916968](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907171916968.png)

**（5）**

这里只画出一个存储条中的逻辑连接，一共有8组SRAM，每一组SRAM有两个芯片用于位扩展，一个74138的译码芯片，对应地址是A28 ~ A0，画出的逻辑如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907172913422.png" alt="image-20240907172913422" style="zoom: 50%;" />

这里逻辑很简单就不再多说了，注意此时的74138的G2A和G2B的控制信号由CPU那边发出的片选信号控制

**（6）**

有8个存储片，因此这里的74138仍然是8个，并且地址的最高三位作为译码器的输入，此时CPU的访存控制信号MREQ作为译码器的控制信号：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907173743958.png" alt="image-20240907173743958" style="zoom:50%;" />

上图即为所画，这里就非常简单了，比15题简单多了

做这种题目，CPU就只有四个部分：地址，数据，访存控制MERQ信号，读写控制信号

译码器有三个部分：G2A, G2B, G1的控制信号，输入信号，输出信号

芯片有四个部分，片选信号，读写信号，地址，数据

对于线的连接，注意一根线及其分叉上的数据是一样的即可

## 3.17*

![image-20240907174132131](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907174132131.png)

**（1）**

除了2片1M*4位的SRAM之外还需要，1M\*8的SRAM，因此需要：
$$
\frac{1M * 8}{256K * 8} = 4片
$$
**（2）**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240907175831691.png" alt="image-20240907175831691" style="zoom: 67%;" />

这道题目是SRAM作为位扩展的时候进行片选的做法，对于最高的地址位00表示选择第一个，01表示第二个，10表示第三个11表示第4个，因此这里需要一个2-4译码器，同时有两片SRAM不同字扩展，最高两位同时作为其地址位，这里与第15题很像，还是通过最高地址位的编码来确定片选

然后剩下的18位作为位扩展的片内地址

这里的256K*4的四块SRAM同时进行了字位扩展

## 3.18

![image-20240908104613028](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240908104613028.png)

**（1）**

64位机器，那也就说机器中的存储字长就是64位

这里模板块的容量表示是1M * 64，说明就是按字编址，所以所需的模板块的数量为：
$$
\frac{2^{26} * 64}{2^{20} * 64} = 64
$$
**（2）**
$$
\frac{2^{10} * 64}{2^8 * 16} = 16
$$
**（3）**
$$
2^{10}
$$
**（4）**

26位地址码最高6位用来选择模板块，次高2位用来选择DRAM（注意这里只需要两位，因为DRAM四个一组进行位扩展，四组一起进行字扩展），然后剩下16位用来片内选址

## 3.19

![image-20240908105743963](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240908105743963.png)

这段汇编代码中，`msg db “HEllo!”`表示的是定义一串字节型的数据

`align 4`表示紧接着这条指令后面的数据按4字节对齐，注意align的作用范围是紧接着其的一个数据

`dw `表示定义字型数据

另外注意的是IA32中存储字长是32位而不是16位

**（1）**

画这种存储数据图注意三点：

（1）画出字地址（起始就是字的起始字节地址）

（2）画出一个**字中的字节地址**（注意标出小端还是大端），小端则0字节在字的起始，大端则0字节在字的末尾

（3）**标出一个字地址中的高字节和底字节，注意是小端存放（低字节在低地址）还是大端（底字节在高地址）**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240908112703631.png" alt="image-20240908112703631" style="zoom:50%;" />

这里由于align的作用，导致紧接着‘o’的100这个16位数字的地址应该是按4字节对齐的，但是align的作用只在紧跟着它的数据，后面的数据还是按小端的方式按序存放

**（2）**

![image-20240908113234165](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240908113234165.png)

## 3.20

这是简答题，不再多说

## 3.21

![image-20240908113328791](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240908113328791.png)

这里的图应该是图3-36：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240908114114270.png" alt="image-20240908114114270" style="zoom:50%;" />

**这里是相联存储器的原理，其工作原理是这样的：**

（1）首先检索寄存器中存放查询的检索字，检索寄存器的位数与存储器中的存储字长相等，当然检索寄存器中不是所有的位都去查找，而是利用其中的关键字去与存储体中的单元匹配

（2）因此这里就需要屏蔽寄存器，这个寄存器的位数与检索寄存器的位数一样，屏蔽寄存器中的位为1，表示检索寄存器对应的位是一位关键字，屏蔽寄存器中的位为0表示检索寄存器中对应位的数据应该被屏蔽

（3）接着就将存储体中的所有存储单元与检索寄存器进行比较，结果放在匹配寄存器中，匹配寄存器的位数与存储单元的个数相等（很多位）如果这个存储单元能够跟检索寄存器匹配上，那么匹配寄存器中这个存储单元对应的位就为1

（4）这里的匹配的意思是一个存储单元中的对应的位（位置）以及位上的数据都要与检索寄存器中保持一致

所以这道题目中的屏蔽寄存器中的值就应该为：`0000 1111 0000 0000`

存储体中一个字长是16位，上图中一共有5个存储单元，只有第二个存储单元对应的位以及位上的数据符合`1011`，因此检索寄存器中的结果就是：`01000...`

## 3.22，3.23，3.24 简答

都是简答题，不再赘述

## 3.25

![image-20240909102934603](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240909102934603.png)

**（1）**

Cache的命中率，其实就是CPU访问Cache的次数除以CPU访问存储器的总数的比值

这里就是$\frac{4200}{4500} = \frac{14}{15}$

**（2）**

平均访存时间其实就是CPU访存的期望时间，CPU访问Cache的概率是$\frac{14}{15}$，所以时间就是：
$$
\frac{14}{15}*40 + \frac{1}{15}200 = \frac{760}{15} = 50ns
$$

## 3.26

![image-20240909103654888](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240909103654888.png)

在CPU发出访存地址之后，其需要按照一定的映射关系将这个内存地址映射到Cache中进行比较，然后才能判断是否在Cache中命中这个块，这就说明：

（1）内存中的内容的地址对应于放入Cache中的地址，这两个地址其实是有一个映射关系

（2）这个映射在Cache中就有三种



这里的容量是直接64KB，因此是按字节编址的，并且主存和Cache的块的大小都是一样的

**直接映射的地址关系有以下几个注意的点：**

（1）主存的地址被分为区号E，区内块号B，块内地址W

（2）主存中的每个区中的块只能放到Cache中的固定的块号处，映射关系是$b = B mod 2^c$，这里b是Cache中的块号，B是主存中一个区中的块号，$2^c$是整个Cache的块的数量

> 也就是说主存中的不同区相同块号的数据块放入Cache中时会发生冲突，但是同一个区的数据块放入Cache中时不会发生冲突



先计算Cache中有多少块：
$$
2^c = \frac{64KB}{16B} = 4K
$$
因此主存中的一个区中的数据块也是4K个，因此主存地址中B应该时12位，一个数据块是16B，所以块内地址应该是4位

所以主存中的后16位是块号B加上块内地址W，前16位是区号

所以这里的`B = 56F`，因此在Cache中其块地址也就是56F，当然，这只是这个数据所在的数据块在Cache中的地址，这里还需要加上块内的偏移，因此这个存储单元的地址（这个字节的地址）就是56F8

关于这里为什么是56F8，首先其是在第56F块中，一块有16个字节，所以这一块的起始字节就是56F0，然后块内偏移是8，所以这个数据字节的地址就是56F8了
