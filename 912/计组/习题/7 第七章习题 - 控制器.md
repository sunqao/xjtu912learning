# 7 控制器

## 7.1 指令周期，机器周期（主存周期），时钟周期，机器主频

![image-20241113095950144](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241113095950144.png)

指令周期是CPU取出一条指令并执行完毕的时间

机器周期是指令执行中，某个完整阶段的时间，比如指令执行中的取指阶段，一般安排机器周期 = 主存周期

时钟周期是计算机主时钟的周期时间，是计算机运行的最基本时间单位，对应一个微操作的时间，时钟周期是计算机主频的倒数，一个机器周期可以包含多个时钟周期

显然不能说机器的主频越快，机器的速度就越快，因为机器的主频越快说明时钟周期越小，但是一条指令的执行速度，或者说机器的速度，取决于指令周期含有的时钟周期的数量和时钟周期的大小，虽然主频高的计算机的时钟周期时间小，但是指令含有的时钟周期个数取决于数据通路等结构，可能一个计算机的主频高但是指令含有的时钟周期很多，那这样机器的速度还是很慢；要看综合效果

## 7.2 硬布线和门阵列的特点

![image-20241113100448275](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241113100448275.png)

硬布线和门阵列都是采用组合逻辑电路实现的控制器，两者的区别在于两种不同的控制器实现的组合电路所采用的器件是不一样的

硬布线采用的是传统的门电路来构建逻辑控制单元，一旦构建完成就不能更改，如果想要增加功能只能从头开始构建

门阵列采用的是通过可编程的门阵列器件来构建逻辑控制单元，集成度更高，性能更好，并且采用硬件编程语言来进行逻辑设计，通过烧制实现芯片内部电路制作；显然在进行逻辑设计的时候如果有错误或者想要更改功能就方便很多，不用重头再来

## 7.10 主频，机器周期，时钟周期，MIPS，计算机速度

![image-20241114152307185](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241114152307185.png)

（1）

一个指令平均有5个时钟周期

根据机器的主频是8MHz，时钟周期是$\frac{1}{8M}s$

因此MIPS为：
$$
\frac{1}{5*\frac{1}{8M}} = \frac{8M}{5} = 1.6MIPS
$$
（2）

每条指令这时有20个时钟周期

因此MIPS为：
$$
\frac{8}{20} = 0.4MIPS
$$
（3）

由此可以得出计算机的执行速度不单单和主频有关，还与指令含有的时钟周期的个数有关，这两个计算机的主频一样，但是执行速度就不一样

## 7.11 主频，机器周期，时钟周期，MIPS，计算机速度

![image-20241114153624131](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241114153624131.png)

（1）

一条指令含有的时钟周期个数是x，1s有8M个时钟周期，可以执行0.8M个指令，因此一个指令对应的时钟周期个数就是：
$$
8/0.8 = 10
$$
因此一个指令含有的机器周期的个数就是：
$$
\frac{10}{4} = 2.5
$$
（2）

时钟周期是0.4us，那计算机的主频就是：
$$
\frac{1}{0.4\mu s} = 2.5 MHZ
$$
单个指令含有的时钟周期不变，因此是：
$$
\frac{2.5}{10} = 0.25MIPS
$$
（3）

一个指令是10个时钟周期，那么40万条指令1s就是1s400万个时钟周期

即主频是4MHz

> 关于主频这个东西，其公式是$\frac{1}{T}$这里的T是时钟周期的长度，所以其意义也可以是1s中时钟周期的个数

## 7.13 uMAR和uPC的理解与PC, MAR的区别

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241118215635038.png" alt="image-20241118215635038" style="zoom:67%;" />

不能代替

注意微程序控制器的控存中存放的全部是微程序，因此uMAR只暂存的是微程序地址

但是主存中除了指令之外还有数据，因此MAR是指令地址和数据地址公用的

如果用MAR代替PC，那么在取数据的时候将数据地址放到MAR中就完全乱套了

## 7.15 微指令的结构 + 水平型微指令的设计 + 互斥微命令的处理

![image-20241118220234099](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241118220234099.png)

首先这个机器是32位机，因此微指令的位数就是32位

然后我们看看**微指令的基本格式**：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241118222058431.png" alt="image-20241118222058431" style="zoom:50%;" />

**微操作控制字段：**

微操作控制字段这个字段产生全部的控制信号，注意这是一条微指令，一段时间的所有微命令组织在一起形成一个控制字，就是微指令

> **设计控制字段的方式主要有三种：**
>
> （1）直接编码方式
>
> 就是微指令中的每一位都表示一个微命令，0表示这个微命令无效，1表示微命令有效
>
> （2）字段直接编码方式
>
> > 首先微命令其实有互斥与相容之分
> >
> > 所谓互斥就是指不同同时出现的微命令，比如存储器的读和写就不能同时出现
> >
> > 所谓相容就是指可以同时出现的微命令，比如寄存器写和加法操作等；显然直接编码方式不能体现互斥与相容
>
> 所谓字段直接编码就是：
>
> 用控制字段中的一小段来表示一组互斥的微命令，而不同的小端之间表示可以相容的微命令，比如XXX YYY这两组字段，XXX三者在同一时间只能翻译成一个微命令，那XXX的二进制不同组合有8种，那就可以表示8种互斥的微命令，而YYY的编码可以与XXX共存，因此XXX和YYY分别表示的微命令就可以共存
>
> 当一个字段短到只有一位的时候就认为是混合编码方式，即直接编码和字段直接编码相结合的编码方式
>
> （3）字段间接编码方式
>
> 字段直接编码方式的一个字段的一种编码就表示一个微命令，而间接编码则是一个字段还要兼容其他的字段来共同编码一个微命令，显然这种编码方式进一步压缩了微指令的长度，但是因为多个字段才能确定一条微命令，因此同时能够并行的微命令就少了很多

这道题目就采用字段直接编码的方式来设计控制字段

**顺序控制字段：**

这个字段指出下一条微指令的地址，用于顺序控制