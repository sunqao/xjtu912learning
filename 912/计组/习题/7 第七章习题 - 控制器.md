# 7 控制器

## 7.1 指令周期，机器周期（主存周期），时钟周期，机器主频

![image-20241113095950144](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241113095950144.png)

指令周期是CPU取出一条指令并执行完毕的时间

机器周期是指令执行中，某个完整阶段的时间，比如指令执行中的取指阶段，一般安排机器周期 = 主存周期

时钟周期是计算机主时钟的周期时间，是计算机运行的最基本时间单位，对应一个微操作的时间，时钟周期是计算机主频的倒数，一个机器周期可以包含多个时钟周期

显然不能说机器的主频越快，机器的速度就越快，因为机器的主频越快说明时钟周期越小，但是一条指令的执行速度，或者说机器的速度，取决于指令周期含有的时钟周期的数量和时钟周期的大小，虽然主频高的计算机的时钟周期时间小，但是指令含有的时钟周期个数取决于数据通路等结构，可能一个计算机的主频高但是指令含有的时钟周期很多，那这样机器的速度还是很慢；要看综合效果

## 7.2 硬布线和门阵列的特点

![image-20241113100448275](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241113100448275.png)

硬布线和门阵列都是采用组合逻辑电路实现的控制器，两者的区别在于两种不同的控制器实现的组合电路所采用的器件是不一样的

硬布线采用的是传统的门电路来构建逻辑控制单元，一旦构建完成就不能更改，如果想要增加功能只能从头开始构建

门阵列采用的是通过可编程的门阵列器件来构建逻辑控制单元，集成度更高，性能更好，并且采用硬件编程语言来进行逻辑设计，通过烧制实现芯片内部电路制作；显然在进行逻辑设计的时候如果有错误或者想要更改功能就方便很多，不用重头再来

## 7.10 主频，机器周期，时钟周期，MIPS，计算机速度

![image-20241114152307185](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241114152307185.png)

（1）

一个指令平均有5个时钟周期

根据机器的主频是8MHz，时钟周期是$\frac{1}{8M}s$

因此MIPS为：
$$
\frac{1}{5*\frac{1}{8M}} = \frac{8M}{5} = 1.6MIPS
$$
（2）

每条指令这时有20个时钟周期

因此MIPS为：
$$
\frac{8}{20} = 0.4MIPS
$$
（3）

由此可以得出计算机的执行速度不单单和主频有关，还与指令含有的时钟周期的个数有关，这两个计算机的主频一样，但是执行速度就不一样

## 7.11 主频，机器周期，时钟周期，MIPS，计算机速度

![image-20241114153624131](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241114153624131.png)

（1）

一条指令含有的时钟周期个数是x，1s有8M个时钟周期，可以执行0.8M个指令，因此一个指令对应的时钟周期个数就是：
$$
8/0.8 = 10
$$
因此一个指令含有的机器周期的个数就是：
$$
\frac{10}{4} = 2.5
$$
（2）

时钟周期是0.4us，那计算机的主频就是：
$$
\frac{1}{0.4\mu s} = 2.5 MHZ
$$
单个指令含有的时钟周期不变，因此是：
$$
\frac{2.5}{10} = 0.25MIPS
$$
（3）

一个指令是10个时钟周期，那么40万条指令1s就是1s400万个时钟周期

即主频是4MHz

> 关于主频这个东西，其公式是$\frac{1}{T}$这里的T是时钟周期的长度，所以其意义也可以是1s中时钟周期的个数

## 7.13 uMAR和uPC的理解与PC, MAR的区别

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241118215635038.png" alt="image-20241118215635038" style="zoom:67%;" />

不能代替

注意微程序控制器的控存中存放的全部是微程序，因此uMAR只暂存的是微程序地址

但是主存中除了指令之外还有数据，因此MAR是指令地址和数据地址公用的

如果用MAR代替PC，那么在取数据的时候将数据地址放到MAR中就完全乱套了

## 7.15 微指令的结构 + 水平型微指令的设计 + 互斥微命令的处理

![image-20241118220234099](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241118220234099.png)

首先这个机器是32位机，因此微指令的位数就是32位

然后我们看看**微指令的基本格式**：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241118222058431.png" alt="image-20241118222058431" style="zoom:50%;" />

**微操作控制字段：**

微操作控制字段这个字段产生全部的控制信号，注意这是一条微指令，一段时间的所有微命令组织在一起形成一个控制字，就是微指令

> **设计控制字段的方式主要有三种：**
>
> （1）直接编码方式
>
> 就是微指令中的每一位都表示一个微命令，0表示这个微命令无效，1表示微命令有效
>
> （2）字段直接编码方式
>
> > 首先微命令其实有互斥与相容之分
> >
> > 所谓互斥就是指不同同时出现的微命令，比如存储器的读和写就不能同时出现
> >
> > 所谓相容就是指可以同时出现的微命令，比如寄存器写和加法操作等；显然直接编码方式不能体现互斥与相容
>
> 所谓字段直接编码就是：
>
> 用控制字段中的一小段来表示一组互斥的微命令，而不同的小端之间表示可以相容的微命令，比如XXX YYY这两组字段，XXX三者在同一时间只能翻译成一个微命令，那XXX的二进制不同组合有8种，那就可以表示8种互斥的微命令，而YYY的编码可以与XXX共存，因此XXX和YYY分别表示的微命令就可以共存
>
> 当一个字段短到只有一位的时候就认为是混合编码方式，即直接编码和字段直接编码相结合的编码方式
>
> 注意每个字段除了表示互斥的一组微命令之外还应该留有一种编码表示无操作，因此一个字段如果有n位，则一般可以表示$2^n - 1$个微命令
>
> （3）字段间接编码方式
>
> 字段直接编码方式的一个字段的一种编码就表示一个微命令，而间接编码则是一个字段还要兼容其他的字段来共同编码一个微命令，显然这种编码方式进一步压缩了微指令的长度，但是因为多个字段才能确定一条微命令，因此同时能够并行的微命令就少了很多

这道题目就采用字段直接编码的方式来设计控制字段

**顺序控制字段：**

这个字段指出下一条微指令的地址，用于顺序控制

> 下一条指令，也就是下一条微地址的形成方式有如下几种：
>
> （1）直接表示方式
>
> 也就是在顺序控制字段中直接给出下一条微指令的地址
>
> （2）增量方式
>
> 所谓增量方式，就是将微指令CMAR当作PC一样让其具有自增的功能，这时寻址的话就必须要给出顺序控制字段了，直接CMAR自动增加即可，下面是顺序型微指令的格式，其省去了顺序控制字段：
>
> <img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119200540370.png" alt="image-20241119200540370" style="zoom:50%;" />
>
> 不过这里只有顺序微指令才能这样寻址，很显然类似于指令，还有一种是转移型的微指令，跟一般的指令一样，其需要满足条件之后进行跳转，地址就是顺序控制字段给出的地址，因此其就需要一个条件字段和转移地址字段，这两类字段都放在顺序控制字段中，其结构如下：
>
> <img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119200737118.png" alt="image-20241119200737118" style="zoom:50%;" />
>
> 
>
> （3）增量和下址字段相结合的方式
>
> 这种方式其实跟增量方式是差不多的，这种方式与增量方式不同之处在于统一了指令的格式：
>
> <img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119200940910.png" alt="image-20241119200940910" style="zoom:50%;" />
>
> 此时CMAR仍然保留有自增的功能，当满足条件的时候进行条件转移，当不满足条件的时候直接自增
>
> 显然，（2）（3）两种方式只能实现两路转移
>
> > 这里的条件选择字段的设计原理是一种编码表示一种条件，也就是一种编码选择一种条件进行测试
> >
> > 比如00表示顺序转移
> >
> > 比如11表示无条件转移
> >
> > 比如01表示测试条件C，C = 1转移，C = 0顺序执行
> >
> > 比如10表示测试条件B，B = 1转移，B = 0顺序执行
> >
> > 不过这里不管是哪一种编码，都只能进行两路转移，并且必须预留00和11表示顺序转移和无条件转移
>
> （4）断定方式
>
> 所谓断定方式，就是通过机器的状态来得到地址，他与前面的区别在于CMAR没有自增功能了，所有的微指令地址都是由顺序控制字段产生的
>
> 顺序控制字段分为两个部分
>
> 一个部分作为产生的微指令地址的高位，是非测试字段
>
> 另一个部分作为测试字段，用来测试机器的状态，即断定机器的状态来得到后继的低位地址：
>
> <img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119201434704.png" alt="image-20241119201434704" style="zoom: 50%;" />
>
> 显然，这种方式可以实现多路转移

这道题题目采用字段直接编码的方式，一个小字段编码一组互斥的微命令，注意还有一个无操作

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119201934385.png" alt="image-20241119201934385" style="zoom:50%;" />

说了微指令字长是29位

一组4个，加上一个无操作，因此需要3位才行

一组5个，加上一个无操作，因此需要3位

8个，需要4位

15个，需要4位

20个，需要5位

控制字段设计完毕

这里的微指令的寻址是增量与下址字段结合的方式，因此顺序控制字段包括两个部分，条件选择和转移地址字段

首先是条件选择字段，这个字段需要预留无条件转移和顺序转移两个条件，再加上题中说了有两个条件，因此有4个可以选择的条件，因此条件选择字段就是2位

剩下就是转移地址了，因此设计微指令格式如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119202813676.png" alt="image-20241119202813676" style="zoom:50%;" />

**（2）**

这里的转移地址表示了这里可以选择的微指令的范围

因此就是：
$$
2^8 * 29位 = 256 * 29 位
$$

## 7.16 微指令的设计互斥组的寻找 + 混合编码格式设计控制字段 + 断定方式设计顺序控制字段

![image-20241119221014391](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119221014391.png)

这里的微指令虽然有16条，但是我们设计微指令的格式其实是按照通用格式设计的

也就是说格式其实就只有一种格式，这种格式应该可以展现出上述16种微指令，即这种格式的微指令应该有至少16中不同的微命令发出组合方式；对应的16种微命令组合方式如题中的图所示

**（1）**

显然有16种不同的微命令，那不可能直接用不译码的方式，因为如果1位表示一个微命令，那至少需要16位控制字段，大于10位

而又要求译码速度尽可能快，所以必然是混合方式编码

下面开始分组，看看哪些微命令是互斥的，那些是相容的

只要是一组微命令可以出现在一条微指令中，那就一定是相容的，这很显然，一条微指令需要发出多个微命令，这些微命令是一定相容的

以微命令a为例，可以发现它跟其他的15个微命令都同在一个指令中出现过，因此a与其他的所有微指令都相容

因此a就应该单独占据一个字段，这个字段只有1位，1表示发出a命令，0表示无操作

我们将不同微指令中微命令的组合表示在下面的表中便于观察：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119222036356.png" alt="image-20241119222036356" style="zoom:50%;" />

可以发现c，d也是与所有的微命令都是相容的，因此c，d也必须单独占据一个字段，每个字段1位

然后再分别查看剩下的微命令

首先是含有b的互斥组

b 与ghijklnp互斥因此bghijklnp先成为一组

然后再看g与后面的hijklnp，由于g与hplk相容，因此可以剔除hplk，更新组得到bgijn

再看i，其余j可以相容，因此可以提出j

所以得到了一个互斥组bgin

下面从出现较少的微命令开始分析

比如p

首先p与onmlkjiheb没有同时出现过，因此ponmlkjiheb可能组成一个互斥组

再看o挨个与后面，发现o与mb相容，因此去掉mb得到ponlkjihe

再看n，n与lj相容，因此去掉得到ponkihe

再看k, 后面的都与k互斥，不去

再看i，不去

再看h，e都不用再去

因此ponkihe就是一组互斥命令

现在我们得到了5组互斥命令了：

a c d bgin ponkihe 

现在还剩下fjlm这四个，我们在这里面再挑一个出现少的m来分析

m 与j相容，因此去掉j得到mlf，然后lf不相容，因此mlf也是一组互斥命令

因此我们得到了a c d bgin ponkihe mlf但是还有一个j命令没有加进去，j肯定不能单开一段，因此j并不是与所有命令都相容

注意我们得到的一组互斥微命令并不是唯一的，我们观察得到的六组微命令，发现i, n有重复，所以bgin可以去掉in得到bg也是互斥的

然后再加入j得到bgj也是互斥组，所以我们就得到了六组互斥的微命令组并且可以包含所有的微命令：

a c d bgj ponkihe mlf刚好所有的微指令最多发出6个微命令，因此这六组就刚刚好

因此字段设计如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241120173718310.png" alt="image-20241120173718310" style="zoom:50%;" />

> 像这种给出了微命令出现大表的图我们寻找互斥微命令的做法就是：
>
> （1）从出现最少的微命令开始进行，比如p得到与p互斥的一组onmlkjiheb
>
> （2）接着对ponmlkjiheb从o开始挨个向后剔除与o互斥的，与n互斥的等等，于是可以得到一组互斥命令ponkihe了
>
> （3）接着就从剩下的出现最少（相对少的也行）的微命令开始比如m，得到与m互斥的一组gfl
>
> （4）然后再看g，根据g剔除f，这样就得到mlg了
>
> （5）还剩下bfj剔除f，得到互斥的bj
>
> （6）那此时就得到了a c d bj mlg ponkihe
>
> （7）然后再调整看f能加入哪一个，acd三组肯定不能加入，先加入bj，那就变成fj，但是b不能加入到mlg，加入mlg，剔除g变成mlf，刚好g可以加入bj变成bgj，于是就通过调整得到了a c d bgj mlf ponkihe了

根据字段位数为n最多表示$2^n - 1$个微命令于是刚好可以占满10位

**（2）**

所谓断定方式确定的微地址就是这种方式可以实现多路转移

顺序控制字段一部分决定最后地址的高位部分

顺序控制字段一部分输入到测试网络中进行条件选择，来决定低位部分

比如这道题目中，因为控存是512*20，因此地址必然是9位，其有4个测试条件，每个测试条件测试成功或失败决定了两个地址，因此总的地址就是8路

T0决定了微地址的最低位，那顺序控制字段的最低位就进行T0的选择呗，0表示不进行这个测试1表示进行这个测试

T1决定了次第位，那顺序控制字段的次第位就进行T1的选择，0表示不进行这个测试，1表示进行这个测试

T2, T3共同决定了次低位，那顺序控制字段可以留出两位的测试字段对条件T2， T3进行选择，比如11表示T2, T3两个条件共同决定倒数第三位，01表示T3条件决定倒数第三位，10表示T2条件决定倒数第三位

所以我们可以进行下面的定义：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241120183026162.png" alt="image-20241120183026162" style="zoom: 50%;" />

上图中顺序控制字段中的前六位决定微指令地址的高6位地址

顺序控制字段中的最低位进行条件T1的选择来决定地址的最低位

顺序控制字段中的次第位进行条件T2的选择来决定地址的次低位

顺序控制字段中的倒数第34位进行条件T3，T4的选择来决定地址的倒数第3位

至于测试字段是怎么选择，一般是1表示这个地址位由其选择的条件T决定，0表示这个地址位是0

不过这里答案不唯一，下面给出一种定义方式

A = 0表示uA0 = 0，A = 1表示uA0由T1决定即uA0 = T1

B = 0表示uA1= 0，B = 1表示uA1由T2决定即uA1 = T2

CD = 00表示uA2 = 0, CD = 01表示uA2 = T3，CD = 10表示uA2 = T4，CD = 11表示uA2 = T3 OP T4

## 7.18 水平型微指令格式设计 + 互斥微命令的处理 + 自增和下址结合的方式设计顺序控制字段

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241120183219568.png" alt="image-20241120183219568" style="zoom:50%;" />

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241120183233148.png" alt="image-20241120183233148" style="zoom:50%;" />

**（1）**

首先100条指令的所有执行阶段的微指令共有6 * 100 = 600条

然后算公用的微指令

两端微程序公用，一段微程序由5条微指令，一段微程序由8条微程序

因此合起来就是613条微指令

所以至少613个存储单元

**（2）**

16互斥组：5位

8互斥组：4位

7互斥组：3位

3互斥组：2位

3互斥组：2位

2互斥组：2位

2互斥组：2位

4个单独的微命令：4位

一共24位

**（3）**

这种格式的指令是增量和下址结合的方式决定微程序的地址

条件选择字段用来选择条件进行测试，条件满足则后面的转移条件地址就是微指令的地址

条件有4个，再加上顺序转移，以及无条件转移两个，因此有6个需要进行选择的条件

所以转移条件应该是4位

613个存储单元，所以转移地址字段应该是10位

因此顺序控制字段应该是4 + 10 = 14位

因此微指令格式设计如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241120185634499.png" alt="image-20241120185634499" style="zoom:50%;" />

## 7.19 微指令控制字段编码方式

![image-20241120185742129](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241120185742129.png)

**（1）**

**微命令编码方式（常见）：**

（1）直接编码

用一位表示一个微命令，缺点是可能导致微指令非常长

（2）字段直接编码

用一个字段来编码一组互斥的微命令，不同字段直接的微命令是相容的，这种编码可以压缩微指令的长度就，但是由于需要一次译码，会影响一些速度

（3）混合编码方式

就是直接编码和字段直接编码的混合，当有微命令与所有其他的微命令都相容的时候其就只占一个位，这个字段就只有一个位，退化成了直接编码

这种编码结合了上面两种编码方式，即压缩了编码长度，又可以增加一些执行速度

**（2）**

80条指令，平均每条有6个微指令，1个事公用的

因此执行阶段有5条，所以一共的微指令条数就是：5 * 80 + 1 = 401条

控存CM就是401 * 32位
