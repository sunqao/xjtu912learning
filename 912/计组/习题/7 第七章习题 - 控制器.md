# 7 控制器

## 7.1 指令周期，机器周期（主存周期），时钟周期，机器主频

![image-20241113095950144](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241113095950144.png)

指令周期是CPU取出一条指令并执行完毕的时间

机器周期是指令执行中，某个完整阶段的时间，比如指令执行中的取指阶段，一般安排机器周期 = 主存周期

时钟周期是计算机主时钟的周期时间，是计算机运行的最基本时间单位，对应一个微操作的时间，时钟周期是计算机主频的倒数，一个机器周期可以包含多个时钟周期

显然不能说机器的主频越快，机器的速度就越快，因为机器的主频越快说明时钟周期越小，但是一条指令的执行速度，或者说机器的速度，取决于指令周期含有的时钟周期的数量和时钟周期的大小，虽然主频高的计算机的时钟周期时间小，但是指令含有的时钟周期个数取决于数据通路等结构，可能一个计算机的主频高但是指令含有的时钟周期很多，那这样机器的速度还是很慢；要看综合效果

## 7.2 硬布线和门阵列的特点

![image-20241113100448275](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241113100448275.png)

硬布线和门阵列都是采用组合逻辑电路实现的控制器，两者的区别在于两种不同的控制器实现的组合电路所采用的器件是不一样的

硬布线采用的是传统的门电路来构建逻辑控制单元，一旦构建完成就不能更改，如果想要增加功能只能从头开始构建

门阵列采用的是通过可编程的门阵列器件来构建逻辑控制单元，集成度更高，性能更好，并且采用硬件编程语言来进行逻辑设计，通过烧制实现芯片内部电路制作；显然在进行逻辑设计的时候如果有错误或者想要更改功能就方便很多，不用重头再来

## 7.10 主频，机器周期，时钟周期，MIPS，计算机速度

![image-20241114152307185](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241114152307185.png)

（1）

一个指令平均有5个时钟周期

根据机器的主频是8MHz，时钟周期是$\frac{1}{8M}s$

因此MIPS为：
$$
\frac{1}{5*\frac{1}{8M}} = \frac{8M}{5} = 1.6MIPS
$$
（2）

每条指令这时有20个时钟周期

因此MIPS为：
$$
\frac{8}{20} = 0.4MIPS
$$
（3）

由此可以得出计算机的执行速度不单单和主频有关，还与指令含有的时钟周期的个数有关，这两个计算机的主频一样，但是执行速度就不一样

## 7.11 主频，机器周期，时钟周期，MIPS，计算机速度

![image-20241114153624131](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241114153624131.png)

（1）

一条指令含有的时钟周期个数是x，1s有8M个时钟周期，可以执行0.8M个指令，因此一个指令对应的时钟周期个数就是：
$$
8/0.8 = 10
$$
因此一个指令含有的机器周期的个数就是：
$$
\frac{10}{4} = 2.5
$$
（2）

时钟周期是0.4us，那计算机的主频就是：
$$
\frac{1}{0.4\mu s} = 2.5 MHZ
$$
单个指令含有的时钟周期不变，因此是：
$$
\frac{2.5}{10} = 0.25MIPS
$$
（3）

一个指令是10个时钟周期，那么40万条指令1s就是1s400万个时钟周期

即主频是4MHz

> 关于主频这个东西，其公式是$\frac{1}{T}$这里的T是时钟周期的长度，所以其意义也可以是1s中时钟周期的个数

## 7.13 uMAR和uPC的理解与PC, MAR的区别

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241118215635038.png" alt="image-20241118215635038" style="zoom:67%;" />

不能代替

注意微程序控制器的控存中存放的全部是微程序，因此uMAR只暂存的是微程序地址

但是主存中除了指令之外还有数据，因此MAR是指令地址和数据地址公用的

如果用MAR代替PC，那么在取数据的时候将数据地址放到MAR中就完全乱套了

## 7.15 微指令的结构 + 水平型微指令的设计 + 互斥微命令的处理

![image-20241118220234099](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241118220234099.png)

首先这个机器是32位机，因此微指令的位数就是32位

然后我们看看**微指令的基本格式**：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241118222058431.png" alt="image-20241118222058431" style="zoom:50%;" />

**微操作控制字段：**

微操作控制字段这个字段产生全部的控制信号，注意这是一条微指令，一段时间的所有微命令组织在一起形成一个控制字，就是微指令

> **设计控制字段的方式主要有三种：**
>
> （1）直接编码方式
>
> 就是微指令中的每一位都表示一个微命令，0表示这个微命令无效，1表示微命令有效
>
> （2）字段直接编码方式
>
> > 首先微命令其实有互斥与相容之分
> >
> > 所谓互斥就是指不同同时出现的微命令，比如存储器的读和写就不能同时出现
> >
> > 所谓相容就是指可以同时出现的微命令，比如寄存器写和加法操作等；显然直接编码方式不能体现互斥与相容
>
> 所谓字段直接编码就是：
>
> 用控制字段中的一小段来表示一组互斥的微命令，而不同的小端之间表示可以相容的微命令，比如XXX YYY这两组字段，XXX三者在同一时间只能翻译成一个微命令，那XXX的二进制不同组合有8种，那就可以表示8种互斥的微命令，而YYY的编码可以与XXX共存，因此XXX和YYY分别表示的微命令就可以共存
>
> 当一个字段短到只有一位的时候就认为是混合编码方式，即直接编码和字段直接编码相结合的编码方式
>
> 注意每个字段除了表示互斥的一组微命令之外还应该留有一种编码表示无操作，因此一个字段如果有n位，则一般可以表示$2^n - 1$个微命令
>
> （3）字段间接编码方式
>
> 字段直接编码方式的一个字段的一种编码就表示一个微命令，而间接编码则是一个字段还要兼容其他的字段来共同编码一个微命令，显然这种编码方式进一步压缩了微指令的长度，但是因为多个字段才能确定一条微命令，因此同时能够并行的微命令就少了很多

这道题目就采用字段直接编码的方式来设计控制字段

**顺序控制字段：**

这个字段指出下一条微指令的地址，用于顺序控制

> 下一条指令，也就是下一条微地址的形成方式有如下几种：
>
> （1）直接表示方式
>
> 也就是在顺序控制字段中直接给出下一条微指令的地址
>
> （2）增量方式
>
> 所谓增量方式，就是将微指令CMAR当作PC一样让其具有自增的功能，这时寻址的话就必须要给出顺序控制字段了，直接CMAR自动增加即可，下面是顺序型微指令的格式，其省去了顺序控制字段：
>
> <img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119200540370.png" alt="image-20241119200540370" style="zoom:50%;" />
>
> 不过这里只有顺序微指令才能这样寻址，很显然类似于指令，还有一种是转移型的微指令，跟一般的指令一样，其需要满足条件之后进行跳转，地址就是顺序控制字段给出的地址，因此其就需要一个条件字段和转移地址字段，这两类字段都放在顺序控制字段中，其结构如下：
>
> <img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119200737118.png" alt="image-20241119200737118" style="zoom:50%;" />
>
> 
>
> （3）增量和下址字段相结合的方式
>
> 这种方式其实跟增量方式是差不多的，这种方式与增量方式不同之处在于统一了指令的格式：
>
> <img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119200940910.png" alt="image-20241119200940910" style="zoom:50%;" />
>
> 此时CMAR仍然保留有自增的功能，当满足条件的时候进行条件转移，当不满足条件的时候直接自增
>
> 显然，（2）（3）两种方式只能实现两路转移
>
> > 这里的条件选择字段的设计原理是一种编码表示一种条件，也就是一种编码选择一种条件进行测试
> >
> > 比如00表示顺序转移
> >
> > 比如11表示无条件转移
> >
> > 比如01表示测试条件C，C = 1转移，C = 0顺序执行
> >
> > 比如10表示测试条件B，B = 1转移，B = 0顺序执行
> >
> > 不过这里不管是哪一种编码，都只能进行两路转移，并且必须预留00和11表示顺序转移和无条件转移
>
> （4）断定方式
>
> 所谓断定方式，就是通过机器的状态来得到地址，他与前面的区别在于CMAR没有自增功能了，所有的微指令地址都是由顺序控制字段产生的
>
> 顺序控制字段分为两个部分
>
> 一个部分作为产生的微指令地址的高位，是非测试字段
>
> 另一个部分作为测试字段，用来测试机器的状态，即断定机器的状态来得到后继的低位地址：
>
> <img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119201434704.png" alt="image-20241119201434704" style="zoom: 50%;" />
>
> 显然，这种方式可以实现多路转移

这道题题目采用字段直接编码的方式，一个小字段编码一组互斥的微命令，注意还有一个无操作

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119201934385.png" alt="image-20241119201934385" style="zoom:50%;" />

说了微指令字长是29位

一组4个，加上一个无操作，因此需要3位才行

一组5个，加上一个无操作，因此需要3位

8个，需要4位

15个，需要4位

20个，需要5位

控制字段设计完毕

这里的微指令的寻址是增量与下址字段结合的方式，因此顺序控制字段包括两个部分，条件选择和转移地址字段

首先是条件选择字段，这个字段需要预留无条件转移和顺序转移两个条件，再加上题中说了有两个条件，因此有4个可以选择的条件，因此条件选择字段就是2位

剩下就是转移地址了，因此设计微指令格式如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119202813676.png" alt="image-20241119202813676" style="zoom:50%;" />

**（2）**

这里的转移地址表示了这里可以选择的微指令的范围

因此就是：
$$
2^8 * 29位 = 256 * 29 位
$$

## 7.16 微指令的设计 + 混合编码格式

![image-20241119221014391](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119221014391.png)

这里的微指令虽然有16条，但是我们设计微指令的格式其实是按照通用格式设计的

也就是说格式其实就只有一种格式，这种格式应该可以展现出上述16种微指令，即这种格式的微指令应该有至少16中不同的微命令发出组合方式；对应的16种微命令组合方式如题中的图所示

**（1）**

显然有16种不同的微命令，那不可能直接用不译码的方式，因为如果1位表示一个微命令，那至少需要16位控制字段，大于10位

而又要求译码速度尽可能快，所以必然是混合方式编码

下面开始分组，看看哪些微命令是互斥的，那些是相容的

只要是一组微命令可以出现在一条微指令中，那就一定是相容的，这很显然，一条微指令需要发出多个微命令，这些微命令是一定相容的

以微命令a为例，可以发现它跟其他的15个微命令都同在一个指令中出现过，因此a与其他的所有微指令都相容

因此a就应该单独占据一个字段，这个字段只有1位，1表示发出a命令，0表示无操作

我们将不同微指令中微命令的组合表示在下面的表中便于观察：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119222036356.png" alt="image-20241119222036356" style="zoom:50%;" />

可以发现c，d也是与所有的微命令都是相容的，因此c，d也必须单独占据一个字段，每个字段1位

