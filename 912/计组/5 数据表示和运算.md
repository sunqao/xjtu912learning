# 数据表示

计算机中的数据可以用有符号和无符号划分，也可以用整数，定点数（定点整数和定点小数），浮点数划分，而其中整数，定点数，浮点数又以原码形式，补码形式，移码形式存放在计算机中，这里不多说了

## 机器数（以下均以8位为例）

机器数就是计算机内部的数据表示，如果是有符号数的话，最高位表示符号位，0（正）1（负）

> 我们这里按照每种不同表示类型的数据分别总结原码，补码，反码的真值范围
>
> 所谓真值就是符号用+-表示然后后面跟上数的书面写法，比如-4的二进制真值就是-100

### 整数表示

#### 原码整数

原码整数就是在真值的基础上最高位变成了符号位，其范围就是：
$$
-(2^{7} -1)[1,1111111] \le a \le(2^{7} -1)[0,1111111]
$$
**原码零：**

0的表示不唯一，有$+ 0[0,0000000]$和$-0[1,0000000]$两种

#### 补码整数

负数补码对于原码来说就是符号位不变，其他位按位取反加一；正数就是补码原码一毛一样

> 算补码的真值的时候需要变换成原码，然后再计算真值，补码变成原码也是符号位不变，其他位按位取反加一

其范围是：
$$
-2^7[1,0000000] \le a\le 2^{7} -1[0,1111111]
$$
补码将原码中的$-0[1, 0000000]$当作了最小的数，补码的范围不对称

**补码零：**

补码零表示唯一，只有+0一种，即0, 0000000

#### 反码整数

其实就是每一位取反，这个范围不要求

### 定点表示（只能表示纯小数和纯整数）

需要注意的是，定点表示法只能表示纯小数和纯整数，整数定点表示默认小数点在最后一位后面，因此其实和上文的整数表示以及范围是一样的

> 另外，定点表示没有什么规划化的问题，定点表示非常简单，原码就是多了个符号位，补码就是负数按位取反加一，然后-0当作最小的数

下面只说一下定点小数的范围问题，定点表示的真值，就是带正负符号的那种其实也是书面写法，只有加上符号位的原码，反码，补码才是计算机中的表示，称为机器数

#### 定点整数（跟整数表示一样）

计算机中的char, short, int, long都是定点整数，也就是整数表示

#### 定点小数

定点小数默认小数点在符号位的后面，小数点在计算机中不表示，小数的零不表示，计算机中只有一个符号位

##### 定点原码小数

最高位仍然是符号位，其范围就是：
$$
-(1 - 2^{-7})[1,1111111] \le a\le 1 - 2^{-7}[0, 1111111]
$$

上面的逗号就是小数点的意思，逗号左边的数并不是个位，而是符号位

##### 定点补码小数

补码还是先转成原码，然后再看范围，转换规则不变，正数跟原码一样；负数就是除了符号位之外其他位取反加一

因此范围是：
$$
-1[1,0000000] \le a \le 1 - 2^7[0,1111111]
$$
还是将原来的-0变成了最小的数

##### 定点反码表示

除了符号位，其他位按位取反即可

### 浮点数

#### 移码表示

移码就是在数的真值的基础上加上$2^n$，移码只用于定点整数的表示，这里的n是移码表示法中数值位的个数，也就是原码表示中数值位的个数

**其实移码与补码相比就是符号位相反，数值位相同**，记住这个就行了，移码就是和补码是一一对应的，移码的范围就是补码的范围

#### 浮点数表示法

计算机中的3.1415926这样整数和小数结合的数字就不能用定点表示法来表示了，这里就需要用到浮点数，浮点数的表示如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106112904626.png" alt="image-20241106112904626" style="zoom:50%;" />

注意浮点数写成$r^{E}*M$这种形式要保证E，M都必须是真值形式，而如果是机器数形式就必须写成类似下面这种：
$$
[X]_{阶移尾原} = 00,XXXXX;00,XXXXXX
$$
这里用的是双符号位

#### 浮点数的表示范围原理

浮点数的表示范围原理如下所示，这里以原码为例，阶码和尾数采用不同的码制表示有不同，这里转换成十进制了

![image-20241106113333295](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106113333295.png)

#### 浮点数的溢出

浮点数仍然是有表示范围的，在数轴上表示并且指示出溢出如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106113913271.png" alt="image-20241106113913271" style="zoom:50%;" />

对于上图的精度溢出，其实十进制的小数表示成二进制的小数的时候有时是无法用二进制的小数准确表示的，可能会出现无限循环的二进制小数的情况，并且由于浮点数的尾数是定点小数，因此有些十进制的数就是不能用浮点数精确表示出来，所以就需要规定一些数的阶码和尾数的部分：

![image-20241106114618398](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106114618398.png)

#### 浮点数的规格化以及左规和右规

所谓的规格化其实就是同一浮点数的表示其实有多种不同的表示方式，可以按照科学计数法的形式来进行理解，因此规划化就就规定：

![image-20241106155411350](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106155411350.png)

比如基数是2的时候，这里的要求最高有效位是1，**必须是真值情况下的尾数的最高有效位是1**，因此也是原码情况下的尾数最高有效位为1，所以补码或者反码表示的时候的范围其实影响挺大的，直接记忆的话就是：

**规格化：**

（1）原码情况下必须是X.1XXXXXX这种形式

（2）补码情况下必须是0.1XXXXXXXX以及1.0XXXXXXX这种形式

上面两个是规定，直接记死即可，规格化这个东西只在浮点数的尾数中有定义，其他的没有规格化一说

注意对于规格化的原码和补码其范围是不一样的，不是一一对应关系，比如原码的1.10000是原码规格化的最大负数值，但是对应补码就没有1.10000，此时规格化补码的负数最大值是1.01111比不存在的负数补码规格化的最大值1.10000小1

以原码为例：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106162026899.png" alt="image-20241106162026899" style="zoom:67%;" />

我们可以通过左移或者右移尾数部分使得最高有效位是1，这就称为左规或者右规，左规或者右规的操作如下所示，左规和右规对于原码和补码的处理是一样的，都是算术移位，移动的时候对阶码的加减操作也是一致的

**左规：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106162452155.png" alt="image-20241106162452155" style="zoom: 33%;" />

右规跟左规一样，就不再多说了，另外需要注意的是如果基数是4，那就说明尾数的扩大其实是按4的倍数扩大，因为尾数是二进制，因此尾数的小数点每移动2位表示扩大或者缩小4倍，此时就是尾数移动两位，阶码加减1：

![image-20241106163013329](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106163013329.png)

看一个例子如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106164343917.png" alt="image-20241106164343917" style="zoom: 33%;" />

![image-20241106192429178](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106192429178.png)



浮点数的原码，反码，补码表示其实默认是对阶码和尾数进行各种原反补的表示

#### 浮点数规格化的表示范围

[计算机组成原理，浮点数的表示以及对其范围的理解 - 知乎](https://zhuanlan.zhihu.com/p/400006735)

## C语言中的数据类型

C语言中常见的整型数据如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108173215351.png" alt="image-20241108173215351" style="zoom:50%;" />

C语言中的浮点数类型如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108180912391.png" alt="image-20241108180912391" style="zoom: 33%;" />

C语言中，或者说计算机中一串机器码到底是什么其实取决于其数据类型

计算机中存储的整数分为有符号数和无符号数，有符号数一律以补码形式存储，无符号数不多数，就是一串没有符号的正数

计算机中存储的浮点数一律以IEEE754格式存储，他们的阶码用移码表示，尾数用原码表示

### C语言中的整型变量的取值范围

在C语言中以char型变量为例

对于unsigned char类型的变量这是无符号整数，也就是8位无符号整数的取值范围：
$$
0 \sim 2^8 - 1
$$
对于 char类型的变量，是有符号数，有符号数在计算机中一律是按照补码形式存储的，因此范围就是8位补码的范围：
$$
-2^7 \sim 2^7 - 1
$$
这里就不多说了

### C语言中的类型转换

#### 整型类型的互相转换

**相同字长之间的转换（以char为例）**

（1）char 转换成unsigned char

机器码都不变，char的补码符号位被解释为unsigned char中的一个数值位，比如0, 1111110其转换成unsigned char 机器码仍然是1，1111110

（2）unsigned char 转换成char

仍然是机器码不变，只不过这时的机器码被解系为8位无符号整数补码

反正相同字长之间的数据类型转换机器码都是不变的，怎么解释机器码就看类型是什么

**小字长转换成大字长**

如果小字长是无符号整数，转换成大字长的时候机器码进行0扩展，比如unsigned char 数据1111 1111，转换成short的时候机器码扩展就是0000 0000 1111 1111

如果小字长是有符号整数，转换成大字长的时候机器码进行符号扩展，比如char 数据是1111 1111，转换成short的时候机器码扩展就是：1111 1111 1111 1111

反正这里记住机器码的转换即可，至于怎么解释机器码就是数据类型应该做的事情

**大字长转换成小字长**

这时编译器会直接将机器码的高位截断，比如一个short类型的机器码是0000 0010 1111 1111其转换成char的时候直接截断了前八位：

1111 1111，变成一个char类型的机器码

不过这样做一般都会出现错误

#### int, float, double类型之间的互相转换（了解一下就好）

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108180809120.png" alt="image-20241108180809120" style="zoom:50%;" />

# 数据计算

## 分数转化为定点小数的方法

**（1）一般处理方式**

一般题目中给定的分数都是分母是2的幂次方，这种情况直接分子用一堆2的幂的和表示，分母用二进制的幂表示，比如29/128：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025162614724.png" alt="image-20241025162614724" style="zoom:50%;" />

最高位是符号位，因此结果就是：`0,0011101`

如果是-29/128，结果是`1,0011101`

然后再将其转化为补码进行各种运算

**（2）十进制小数转化为二进制**

这种方式应该仅仅对于纯小数转化为二进制比较有意义，带整数的小数可以直接用浮点数表示

## 十进制小数转化位定点小数的方法

用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止

比如0.375转化为二进制小数

乘2，得到0.75，得到整数0

0.75乘2，得到1.5，得到整数1

0.5乘2，得到1.0，得到整数1

因此二进制小数就是0.011

## 移位运算：逻辑移位，算数移位

**逻辑移位：**

逻辑移位的对象是无符号数

逻辑左移，高位移除，低位补零

逻辑右移，低位移除，高位补零

**算数移位：**

算数移位的对象是有符号数（主要针对的是定点数），不论是正数还是负数，**只对数值位进行移位，符号位不变**

**如果是正数**：不论是原码还是反码还是补码，不管是左移还是右移，一律都是移出来的空位补零，如果高位有1被移出说明精度丢失很大，表示出错，如果低位有1被移出，说明有精度丢失

**如果是负数**，还得分情况：

如果是原码，不管是左移还是右移，空位一律补零，如果高位有1被移出说明精度丢失很大，表示出错，如果低位有1被移出，说明有精度丢失

如果是反码，其与原码正好相反，不管是左移还是右移，空位一律补1，如果高位有0被移出说明精度丢失很大，表示出错，如果低位有0被移出，说明有精度丢失

如果是补码，左移的时候低位出现空位补0，右移的时候高位出现空位补1，如果左移最高位丢0，说明出错，如果右移最低位丢1，说明精度丢失：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107114030032.png" alt="image-20241107114030032" style="zoom:50%;" />

**双符号位的算数移位运算：**

双符号数的最高位看作真正的符号位，其他的看作数值位，左移或者右移都只对数值位进行移动

**对于双符号原码**

无论正负，无论左移还是右移，都是空位补零

**对于双符号补码**

与单符号位一样，右移补最高符号位，左移补零

## 移码加减运算以及溢出判断

$$
[A + B]_移 = [A]_移 + [B]_补；[A - B]_移 = [A]_移 + [-B]_补
$$

注意$[A + B]_移$与$[A]_移 + [B]_移$不是一样的，对于这两个有如下公式：

**移码的溢出判断：**

这里仍然采用双符号位判断溢出，但是这里的移码双符号位与补码不一样

（1）规定移码无论正负，其最高符号位始终为0，并且00，表示负数，01表示正数

（2）当最高的符号位为1的时候说明发生了溢出

其中10表示出现了正溢出，因为10一定是由01进位而来的，由正数破坏就是上溢出；

其中11表示出现了负溢出，因为11一定是由10进位而来的，由负数破坏就是下溢出；

（3）移码的双符号位同样参与运算



## 补码加减法运算

**补码加法公式：**
$$
[X + Y]_补 = [X]_补 + [Y]_补
$$
**补码减法公式：**
$$
[X - Y]_补 = [X]_补 + [-Y]_补 = [X]_补 - [Y]_补
$$


<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025163550267.png" alt="image-20241025163550267" style="zoom:67%;" />

**补码加法运算过程：**

（1）求出每个操作数的补码：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025163608830.png" alt="image-20241025163608830" style="zoom:67%;" />

> 题目中真值小数点前的不是符号位，但是转换成补码之后小数点前面的就是符号位了，建议原码，补码符号位后面的小数点用逗号代替，真值中再用小数点，后文正文中都是逗号前面表示符号位，小数点的位置另说

（2）按照二进制的加法进行相加，进位，符号位同样参与运算，得到$[X + Y]_补 ([X]_补 + [Y]_补)$，最高位产生的进位丢掉，虽然符号位位可能改变，不过没关系：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025163842555.png" alt="image-20241025163842555" style="zoom:67%;" />

（3）将$[X + Y]_补$转换回X + Y，上面的结果就是一个正的，因此就是结果了：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025164155825.png" alt="image-20241025164155825" style="zoom:80%;" />

**补码减法运算：**

（1）求出X和-Y的补码，对于-Y的补码的求法，先变符号位，然后按照取反加一变成补码即可：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025164329776.png" alt="image-20241025164329776" style="zoom:67%;" />

（2）按照二进制的加法进行相加，进位，符号位同样参与运算，得到$[X - Y]_补 ([X]_补 + [-Y]_补)$，最高位产生的进位丢掉

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025164715364.png" alt="image-20241025164715364" style="zoom:67%;" />

（3）将$[X - Y]_补$转化为X - Y真值，上面结果也还是一个正的，就是结果了



上面都是小数运算，不过整数也是一样处理的

## 补码加减运算中的溢出

**溢出只有两种**

（1）负溢出（下溢出），两个负数相加但是结果符号位为正

（2）正溢出（上溢出），两个正数相加但是结果符号位为负

> 溢出的产生是因为固定位数表示数的大小是固定的，当数的绝对值过大导致进位跑到符号位对符号位产生了破坏

**判断溢出的方法：**

直接用双符号位进行运算，如过两个符号位不一样，则说明发生了溢出

对于单个符号位来讲，只要两个正数相加（一个正数减负数）或者两个负数相加，结果变号了，那就说明发生了溢出	

## 补码的双符号位加减运算以及溢出的处理

双符号位就是两个符号位，其基本流程与单符号位一样，需要注意下面几点：

（1）正数的符号位就是00，负数的符号位是11

（2）计算的时候符号位更左边的更高位进位仍然舍去

（3）如果符号位不一样，则说明发生了溢出

（4）如果发生了溢出，比如符号位出现了01，或者10，此时最高的符号位仍然是正确的符号，第二个符号位作为正确补码数据的一部分 

> 如果如果是纯小数，第二个符号位作为小数中的个位，其后面才是小数点
>
> 如果是整数，第二个符号位作为数据位的最高位

**举例如下：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025174348217.png" alt="image-20241025174348217" style="zoom:67%;" />
$$
[X + Y]_补 = 00,0110
$$
这里最高位舍弃，因此结果就是X + Y = 00, 0110，真值就是+0.0110
$$
[X - Y]_补 = 01,0000
$$
显然，这里出现了正溢出，此时最高位就是正确的符号位，1这个进位作为数值的一部分，正确的补码应该是$[X - Y]_补 = 0,1.0000$这里只有第一位是符号位，小数点默认在第二位的后面；小数溢出肯定要多出一个个位的1

所以其正确的原码就是X - Y = 0,1.0000，真值就是+1.0000

同理，如果小数计算得到的补码结果是10,1100，那此时补码是一个负数，真实的补码应该是1, 0.1100，第一位是真实符号位，取反加一得到原码：1, 1.0100，因此真值就是-1.0100

> 注意只有溢出的时候符号位的第二位才能作为一个单独的最高数值位，比原来的结果多一位，但是如果没有溢出则还是原来的位数，这里我们主要是想得到真实的真值，至于计算机能不能表示又是另外一回事

**如果是整数举例如下：**

（1）X = +1100, Y = +1000，求X + Y

我们算得$[X + Y]_补 = 01,0100$，此时出现正溢出，但是最高的符号位仍然是正确的，第二个符号位作为最高位，因此原码是：
$$
[X + Y]_原 = 0,10100
$$
 真值就是+10100

（2）X = -1100, Y = -1000，求X + Y

我们算得$[X + Y]_补 = 10,1100$，此时出现负溢出，但是最高的符号位仍然是正确的，第二个符号位作为最高位，因此原码是：
$$
[X + Y]_原 = 1,10100
$$
 真值就是-10100

这里整数的小数点默认在最后，溢出后多出来的一位符号位在最高数值位

## 原码一位乘

![image-20241028204932038](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028204932038.png)

以这个乘法为例子

**（1）首先是符号位，通过异或得到**

这里的符号位S = 0^1 = 1

**（2）剩下数值的计算用的是绝对值，这里符号位仍然是两位**

|X| = 00, 1101, |Y| = 00, 1011

**（3）第一步，初始化，写出初始部分积和乘数，逗号表示前面是符号位，数值位的位数与被乘数一样**

![image-20241028205353665](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028205353665.png)

**（4）进行操作，每一步操作包含三步**

i 看乘数的末尾是1还是0

ii 如果是1，则部分积加上被乘数，这里是加上|X|，如果是0，则加上0，得到中间结果，哪怕溢出也要保留

iii 第二步得到的中间结果与乘数一起右移，这里是算数右移，部分积的左边补零，乘数的最后一位移出去

比如上述一次操作之后：

![image-20241028211006853](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028211006853.png)

（5）一直执行这个操作，直到乘数的剩下几位全部移出去：

![image-20241028211846934](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028211846934.png)

加上符号位和小数点，因此结果就是1,10001111.这个是原码，真值就是-10001111了

对于小数也是一样，只不过小数点写在逗号位置处

## 补码一位乘

以下面这个为例子：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028214331489.png" alt="image-20241028214331489" style="zoom:67%;" />

**（1）求出$X_补，(-X)_补，Y_补$，这里的符号位还是用双位，逗号表示符号位与数值位的分界：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028215108288.png" alt="image-20241028215108288" style="zoom:50%;" />

**（2）初始化，写出部分积，乘数还有附加值0：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028215322349.png" alt="image-20241028215322349" style="zoom:67%;" />

**（3）进行一次操作，一次操作包含下面三步**

i 附加值减去乘数最后一位小于零还是大于零还是等于零

ii 如果小于零，则部分积加上$[-X]_补$得到中间结果，如果大于零，则加上$[X]_补$得到中间结果，如果等于零则加上零得到中间结果，符号位参与运算，中间结果超出两位符号位的进位丢掉

iii 中间结果和乘数整体右移一位，这里是算数右移，乘数的逗号也跟着移动，部分积右移补第一个符号位，并且最后一位移出去当作新的附加值

进行一次操作后的结果为：

![image-20241028221349272](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028221349272.png)

**（4）反复操作直到乘数Y补的数值位全部移出去，此时乘数部分只剩下Y补的符号位：**

![image-20241028223646683](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028223646683.png)

**（5）进行最后一次操作，但是不右移：**

![image-20241028223730251](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028223730251.png)

这样就得到结果了，至于小数点的位置，反正小数乘小数就是小数，整数乘整数就是整数，小数点按乘法的数的类型直接加上去即可，这里是小数，因此结果就是：
$$
[XY]_补 = 11, 01110001；XY = 11,10001111；XY_真 = -0.10001111
$$

## 补码两位乘

以下面的计算为例：

![image-20241029183744266](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241029183744266.png)

**（1）分别算出$[X]_补，[-X]_补，[Y]_补，[2X]_补，[-2X]_补$，其中X有关的式子用三位符号位表示，如果有进位，符号位最低位表示进位：**
$$
[X]_补 = 000, 110011;[-X]_补 = 111,001101;[Y]_补 = 11,010110;[2X]_补 = 001,100110;[-2X]_补 = 110,011010
$$

> 关于三位符号位，上面的小数点的位置其实应该是逗号，表示符号与数值位的分界，如果是正数符号位是000, xxxxx；如果是负数符号位是111, xxxxx，负号取补的时候仍然是符号位不变，数值位取反加一，取反加一这个运算只有原码是111, 000000的时候数值位才会有进位，这个进位舍去，1111,00000这个补码就当作补码可以表示的最小的数
>
> 补码二位乘的时候计算2X的补码，进位保留在符号位的最后一位上，其实就是在原来的补码基础上数值整体左移一位，低位补零

**（2）初始化有下面几个操作：**

i 部分积部分的符号位为三位

ii 如果乘数部分的数值位是奇数个，则其符号位只有1位，乘数部分的数值位是偶数个，符号位设为2位；反正保证乘数的总位数（符号位加上数值位是偶数个）

iii 附加位初始设为0

比如上述例子中乘数的数值位是偶数，因此乘数Y的符号位就是2位，所以初始化如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241029185929018.png" alt="image-20241029185929018" style="zoom: 50%;" />

**（3）进行一次操作，一次操作包含下面几步：**

i 观察乘数的最低两位$Y_{n-1}Y_n$和附加位$Y_{n + 1}$组成的三位，根据三位不同的值进行不同的加法操作

ii 进行加法操作，对应表如下所示，需要背下来：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241029203031873.png" alt="image-20241029203031873" style="zoom: 67%;" />

上表中的$[Z_{i + 2}]_补，[Z_i]_补$分别是本次操作的中间结果和上一次操作结束得到的部分积

iii 中间结果带着乘数一起右移两位，中间结果右移左边补第一个符号位（算数右移），乘数右移逗号也跟着右移，得到新的部分积

上面例子进行一次操作如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241029204045303.png" alt="image-20241029204045303" style="zoom:67%;" />

**（4）反复执行操作，直到结束，结束分两种情况**

i 如果乘数的数值位是偶数，比如这里是6位，那么每次操作右移两位，因此3次操作后数值位全部移出去，此时再进行一次操作但是不移位得到结果，因此如果数值位是2n位，则进行n + 1次操作，最后一次操作不移位

ii 如果乘数的数值位是奇数，比如是5位，那么每次操作右移两位，2次操作之后还剩下一个数值位，此时再进行一次操作但是只右移一次得到结果，因此如果数值位是2n + 1位，则进行n + 1次操作，最后一次操作右移一位

上述例子一直操作到最后如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241029210428091.png" alt="image-20241029210428091" style="zoom:67%;" />

有的课本教材最后还有将符号位清零，其实这个不用管，反正我们算的都是定点数，小数乘小数是小数，整数乘整数是整数

因此这道题目：
$$
[XY]_补 = 111, 011110100010;[XY]_原 = 111,100001011110;[XY]_真 = -0.100001011110
$$

## 原码恢复余数除法

首先，进行原码除法的时候符号位是由两个操作数的符号位异或得到

然后为了跟前面的乘法一样保证都是定点数，规定定点小数除法是小的除以大的得到定点小数，定点整数的除法是大的除以小的得到定点整数，就是反正操作数和结果要么都是定点小数，要么都是定点整数

其包括下面的步骤，以下面的为例子：

![image-20241104162606730](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104162606730.png)

这里是定点小数用小的除以大的因此X是除数

**（1）算出$[|X|]_补，[|Y|]_补，[-|Y|]_补$**：

![image-20241104162832121](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104162832121.png)

下面的操作一律都是按照补码进行的

**（2）初始化，写出初始余数和商，初始余数就是$[|X|]_补$，商为0000，这里的商的位数与X的数值位数一样**：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104163418219.png" alt="image-20241104163418219" style="zoom:50%;" />

**（3）进行一次操作，一次操作包含下面几步：**

i 算中间余数，加上$[-|Y|]_补$，得到中间余数

ii 算商，观察中间余数的正负来决定商的一位，如果中间余数小于零，则商0，如果中间余数大于零，则商1，商的一位放在Q的末尾

iii 恢复余数，如果中间余数小于零，则中间余数需要再加上$[|Y|]_补$恢复；如果中间余数大于零，则不变

iv 中间余数和商统一左移一位，这里的左移低位补零，这里的左移不是算数移位，余数的符号位也要参与左移

上面例子进行一次操作如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104164308075.png" alt="image-20241104164308075" style="zoom:67%;" />

**（4）重复n次操作，这里的n是余数的数值位的位数，这里就是重复四次操作：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104173615906.png" alt="image-20241104173615906" style="zoom: 50%;" />

这里的第四次移位一定会将0移动到小数点前面，但是不要紧，因为这里的定点小数除法一定是小数除以大数，所以我们第一次上的商一定是0

**（5）最后一次操作**

i 算中间余数，加上$[-|Y|]_补$，得到中间余数

ii 算商，如果此时的中间余数为正，商1，如果此时的中间余数为负，商0

iii 恢复余数，如果中间余数小于零，则中间余数需要再加上$[|Y|]_补$恢复；如果中间余数大于零，则不变

iv **商和余数都不左移**，最后的结果余数一共左移了n次需要乘$2^{-n}$，这里乘$2^{-4}$

上面的例子如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104174910059.png" alt="image-20241104174910059" style="zoom:50%;" />

符号位单独计算，由两个数的符号位异或得到，因此这里的结果就是：
$$
R = 0.0001 * 2^{-4}；[x]_原 / [y]_原 = 1.1101
$$
注意最后的结果就是数值位，不用再取补什么的

## 原码加减交替除（不恢复余数除）

不恢复余数除法是对恢复余数除法的改进，讲真的完全没有必要去学恢复余数除法的

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106083621936.png" alt="image-20241106083621936" style="zoom:67%;" />

下面还是以这个例子来说明过程：

![image-20241106083830876](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106083830876.png)

符号位是两个数异或的结果，仍然需要保证小数除以小数是小数，整数除以整数是整数

**（1）算出$[|X|]_补，[|Y|]_补，[-|Y|]_补$：**

![image-20241106084019750](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106084019750.png)

**（2）初始化：跟恢复余数除法一样，余数初始化为$[|X|]_补$，商初始化为0，位数应该与本来的操作数的数值位一样：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106084943082.png" alt="image-20241106084943082" style="zoom:50%;" />

**（3）进行一次操作，一次操作包含如下几步：**

i 第一次操作一定是加上$[-|Y|]_补$得到中间余数，后面的操作根据上一次操作的中间余数的正负来决定，上一次中间余数为正则此时操作加$[-|Y|]_补$，上一次中间余数为负，则此时操作加$[|Y|]_补$，得到此时操作的中间余数

ii 算商，如果中间余数大于零，商1，如果中间余数小于零，商0

iii 中间余数和商统一左移一位，注意这里的左移不是算术移位，余数的符号位也得参与移位

进行第一次操作后的结果如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106090037932.png" alt="image-20241106090037932" style="zoom:67%;" />

**（4）重复n次操作，这里的n是余数的数值位的位数，这里就是重复四次操作：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106090924982.png" alt="image-20241106090924982" style="zoom:67%;" />

**（5）最后一次操作，包含如下几个步骤，但是商和余数都不左移：**

i 根据上一次中间余数的正负来决定是加Y还是-Y，这道例子中上一次中间余数是负，因此是加Y，得到这一次操作的中间余数

ii 算商，根据这一次的中间余数来决定是商1还是商0，如果中间余数>0，商1，如果中间余数<0，商0

iii 恢复余数，注意不恢复余数除法是恢复余数的改进，因此最后一步应该和恢复余数一样，如果本次操作的中间余数>0拿不用管此时的中间余数就是最终的余数，但是如果本次中间余数<0，那此时必须将中间余数进行+Y恢复

iii 不进行左移

最后一次操作如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241106091831964.png" alt="image-20241106091831964" style="zoom:67%;" />

## 浮点数的加减计算

上面的各种什么一位乘，二位乘，加减交替除法处理的都是定点数的计算，下面先来介绍浮点数的加法计算

以下面的例子为例：

![image-20241107110609435](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107110609435.png)

**（1）分别写出两个数字的阶码和尾数的补码双符号位形式：**

![image-20241107110703723](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107110703723.png)

这里用双符号位主要是后面判断溢出的时候容易判断，并且后面的计算以及移位都是默认是补码形式下的运算

**（2）对阶，将两个数字的阶码变成一样的，方便计算，这样加减操作只用在尾数部分进行就可以了**

注意对阶的时候**始终是小阶向大阶看齐，小阶变大，同时小阶对应的尾数算数右移**，这样会导致小阶对应的尾数丢失一部分精度，但是不要紧

> 如果是大阶向小阶看齐，那么大阶的尾数移动的时候是左移的，为了保证尾数始终是小数，那么大阶的尾数就会出现高位丢失，那这个精度丢失就很严重了

在本例中，判断两个数的阶码的大小，这里直接将两个阶码相减就可以了，按照补码减法的法则：
$$
[X - Y]_补 = [X]_补 + [-Y]_补 = [X]_补 - [Y]_补
$$
看看哪个大，哪个小，得到阶码的差值，这就是小阶的尾数需要右移的位数：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107111525163.png" alt="image-20241107111525163" style="zoom: 50%;" />

从而得到对阶的结果，注意此时尾数的低位先别直接丢弃，先保留参与下面的运算，一直到最后的时候再进行舍入，这样精度会最高：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107111725481.png" alt="image-20241107111725481" style="zoom:50%;" />

**（3）尾数进行运算**

这里尾数直接进行补码加法运算：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107111937065.png" alt="image-20241107111937065" style="zoom:50%;" />

**（4）结果规格化以及溢出处理**

**尾数溢出处理：**

当尾数是正常情况时，比如符号位11或者00，此时只需要单纯左规即可，此时阶码减一

> 注意这里的左规并不会导致高有效位的丢失，它与最开始对阶的时候不能左移是不一样的，最开始如果按大阶向小阶看齐，那么大阶递减，尾数左移，此时尾数可能已经是规格化数了，最高有效位就在数值位的第一位，这时左移就会导致精度严重丢失
>
> 但是这里因为不是规格化的尾数才进行左移，目的就是将最高有效位移动到数值位的最左边，所以左规就是直接左移即可，并不会造成精度严重丢失

当尾数的符号位出现10，或者01，说明尾数出现的溢出，此时单纯右规即可，此时阶码加一

**阶码溢出处理：**

根据尾数的溢出以及尾数的规格化，阶码需要进行相应的加减操作，但是阶码的范围也是确定的，因此阶码也会出现溢出

当尾数正常左规的时候，阶码减一，阶码可能出现下溢，即阶码的符号位可能是10，此时直接认为浮点数的运算结果是0

当尾数溢出需要右规的时候，阶码加一，阶码可能出现上溢，即阶码的符号位可能是01，此时直接认为浮点数的运算结果是无穷

对于本例，我们先直接对尾数的补码进行左规，左移两位，注意附加位也要参与移位：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107115003911.png" alt="image-20241107115003911" style="zoom:50%;" />

然后阶码-2，当然也是补码运算：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107115046516.png" alt="image-20241107115046516" style="zoom:50%;" />

因此就得到了规格化后的尾数和阶码的补码形式：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107115119219.png" alt="image-20241107115119219" style="zoom:50%;" />

**（5）舍入处理**

舍入处理有下面的三种：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107115246195.png" alt="image-20241107115246195" style="zoom:50%;" />

这里我们直接按照舍入规则得到尾数的最后结果：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107115329024.png" alt="image-20241107115329024" style="zoom:50%;" />

所以最后结果为：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107115414923.png" alt="image-20241107115414923" style="zoom:50%;" />

采用的是0舍1入

下面再来看看浮点数减法运算：

![image-20241107155250869](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107155250869.png)

**（1）写出两个数的阶码和尾数的所有双符号位的补码形式：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107155633786.png" alt="image-20241107155633786" style="zoom:50%;" />

**（2）对阶，小阶向大阶看齐，小阶变大，小阶对应的尾数算数右移：**

上例中y的阶码更小，其加一变大，且其尾数右移一位，移出位暂时保留，用来提高精度：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107155843139.png" alt="image-20241107155843139" style="zoom:50%;" />

**（3）尾数进行加减计算：**

这里x，y的尾数部分直接进行减法计算，我们要算的是$[M_x - M_y]_补$，因此根据公式：
$$
[M_x - M_y]_补 = [M_x]_补 - [M_y]_补 = [M_x]_补 + [-M_y]_补
$$
得到计算结果：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107160200844.png" alt="image-20241107160200844" style="zoom:50%;" />

**（4）结果规格化以及溢出处理：**

上述的计算结果表明尾数部分溢出了，不过不要紧，这里进行右规，尾数右移一位，同时阶码也要加一：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241107164312921.png" alt="image-20241107164312921" style="zoom:50%;" />

这里发现阶码溢出，是上溢，因此认为结果是无穷

**（5）舍入处理**

这里认为结果是无穷大，不作舍入处理

## 浮点数的乘法计算

浮点数的乘法其实很简单，包含以下几个步骤，我们以下面的两个数的例子为例：

![image-20241108103952332](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108103952332.png)

**（1）将浮点数写成机器数形式：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108104549430.png" alt="image-20241108104549430" style="zoom:50%;" />

**（2）阶码相加，并判断溢出**

这里使用移码的加法，移码的加法公式如下：
$$
[E_X + E_Y]_移 = [E_X]_移 + [E_Y]_补
$$
得到结果：

![image-20241108112551237](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108112551237.png)

没有出现溢出

**（2）尾数相乘**

这里使用定点小数乘法，因为尾数是原码，因此采用原码一位乘：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108114245189.png" alt="image-20241108114245189" style="zoom: 50%;" />

得到尾数：
$$
M = 11.011010(001101)
$$
当然原码的一位乘的符号位是异或单独运算，这里是-1

**（3）规格化和舍入**

这里与浮点加减法的规格化和舍入准则一样

可以看到尾数部分没有溢出，这里只需要左规一位即可，左规一位，阶码减一：

因此阶码就是：
$$
[E - 1]_移 = [E]_移 + [-1]_补 =01,111 + 11,111 = 01,110
$$
阶码没有发生溢出，同时尾数左规以及舍入之后的结果就是：
$$
11.110100
$$
因此最后浮点数的机器结果就是：
$$
[X*Y]_{阶移尾原} = 01,110;11,110100
$$
真值是：
$$
X*Y = 2^{110}*(-0.110100)
$$

## 浮点数的除法计算

![image-20241108103952332](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108103952332.png)

还是以下面两个数为例子

**（1）将两个浮点数写成机器数的形式并进行尾数调整：**

这里进行调整的意思是可能X的尾数|Mx| > |My|，因此X的尾数需要进行右移缩小，不过这个例子中不需要调整

![image-20241108151745974](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108151745974.png)

**（2）进行阶码相减，并判断溢出**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108152010723.png" alt="image-20241108152010723" style="zoom:50%;" />

没有溢出

**（3）尾数相除**

这里的除法就是原码一位除了，这里用原码交替除法计算，注意这里的原码除法左移的时候并不是算术移位，左移的时候符号位也要参与左移，或者这里可以直接用2符号位进行运算，如果用双符号位就是算术左移了，当然双符号位的最高位是0的时候是正数

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241108161256680.png" alt="image-20241108161256680" style="zoom:50%;" />

这里我们就得到了尾数：
$$
[M]_原 = 11,111010
$$
**（3）规格化和舍入**

这里不用规格化和舍入，因此结果的机器数表示为：
$$
[X/Y]_{阶移尾原} = 01,001;11,111010
$$
写成真值形式就是：
$$
2^{001}*(-0.111010)
$$

> 真的恶心，浮点数的除法算是计组中最最最最最恶心的东西了

