# 数据表示

## 机器数（以下均以8位为例）

机器数就是计算机内部的数据表示，最高位表示符号位，0（正）1（负）

> 我们这里按照每种不同表示类型的数据分别总结原码，补码，反码的真值范围
>
> 所谓真值就是符号用+-表示然后后面跟上数的书面写法，比如-4的二进制真值就是-100

计算机中的机器数表示用数的类型分的话其实就两种：

（1）定点表示法，只能表示纯小数和纯整数，这种方式的原码，补码理解很简单，并且定点整数就是一般的整数表示法

> 原码就是最高位是符号位，其他的位与真值一样
>
> 补码就是符号位与原码一样，其他位负数就是按位取反加一，正数就是不变

（2）浮点表示法

### 整数表示

#### 原码整数

原码整数就是在真值的基础上最高位变成了符号位，其范围就是：
$$
-(2^{7} -1)[1,1111111] \le a \le(2^{7} -1)[0,1111111]
$$
**原码零：**

0的表示不唯一，有$+ 0[0,0000000]$和$-0[1,0000000]$两种

#### 补码整数

负数补码对于原码来说就是符号位不变，其他位按位取反加一；正数就是补码原码一毛一样

> 算补码的真值的时候需要变换成原码，然后再计算真值，补码变成原码也是符号位不变，其他位按位取反加一

其范围是：
$$
-2^7[1,0000000] \le a\le 2^{7} -1[0,1111111]
$$
补码将原码中的$-0[1, 0000000]$当作了最小的数，补码的范围不对称

**补码零：**

补码零表示唯一，只有+0一种，即0, 0000000

#### 反码整数

其实就是每一位取反，这个范围不要求

### 定点表示（只能表示纯小数和纯整数）

需要注意的是，定点表示法只能表示纯小数和纯整数，整数定点表示默认小数点在最后一位后面，因此其实和上文的整数表示以及范围是一样的

> 另外，定点表示没有什么规划话的问题，定点表示非常简单，原码就是多了个符号位，补码就是负数按位取反加一，然后-0当作最小的数

下面只说一下定点小数的范围问题

#### 定点整数（跟整数表示一样）

#### 定点小数

定点小数默认小数点在符号位的后面

##### 定点原码小数

最高位仍然是符号位，其范围就是：
$$
-(1 - 2^{-7})[1,1111111] \le a\le 1 - 2^{-7}[0, 1111111]
$$

上面的逗号就是小数点的意思，逗号左边的数并不是个位，而是符号位

##### 定点补码小数

补码还是先转成原码，然后再看范围，转换规则不变，正数跟原码一样；负数就是除了符号位之外其他位取反加一

因此范围是：
$$
-1[1,0000000] \le a \le 1 - 2^7[0,1111111]
$$
还是将原来的-0变成了最小的数

##### 定点反码表示

除了符号位，其他位按位取反即可

# 数据计算

## 分数转化为定点小数的方法

**（1）一般处理方式**

一般题目中给定的分数都是分母是2的幂次方，这种情况直接分子用一堆2的幂的和表示，分母用二进制的幂表示，比如29/128：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025162614724.png" alt="image-20241025162614724" style="zoom:50%;" />

最高位是符号位，因此结果就是：`0,0011101`

如果是-29/128，结果是`1,0011101`

然后再将其转化为补码进行各种运算

**（2）十进制小数转化为二进制**

这种方式应该仅仅对于纯小数转化为二进制比较有意义，带整数的小数可以直接用浮点数表示

## 补码加减法运算

**补码加法公式：**
$$
[X + Y]_补 = [X]_补 + [Y]_补
$$
**补码减法公式：**
$$
[X - Y]_补 = [X]_补 + [-Y]_补
$$


<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025163550267.png" alt="image-20241025163550267" style="zoom:67%;" />

**补码加法运算过程：**

（1）求出每个操作数的补码：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025163608830.png" alt="image-20241025163608830" style="zoom:67%;" />

> 题目中真值小数点前的不是符号位，但是转换成补码之后小数点前面的就是符号位了，建议原码，补码符号位后面的小数点用逗号代替，真值中再用小数点，后文正文中都是逗号前面表示符号位，小数点的位置另说

（2）按照二进制的加法进行相加，进位，符号位同样参与运算，得到$[X + Y]_补 ([X]_补 + [Y]_补)$，最高位产生的进位丢掉，虽然符号位位可能改变，不过没关系：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025163842555.png" alt="image-20241025163842555" style="zoom:67%;" />

（3）将$[X + Y]_补$转换回X + Y，上面的结果就是一个正的，因此就是结果了：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025164155825.png" alt="image-20241025164155825" style="zoom:80%;" />

**补码减法运算：**

（1）求出X和-Y的补码，对于-Y的补码的求法，先变符号位，然后按照取反加一变成补码即可：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025164329776.png" alt="image-20241025164329776" style="zoom:67%;" />

（2）按照二进制的加法进行相加，进位，符号位同样参与运算，得到$[X - Y]_补 ([X]_补 + [-Y]_补)$，最高位产生的进位丢掉

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025164715364.png" alt="image-20241025164715364" style="zoom:67%;" />

（3）将$[X - Y]_补$转化为X - Y真值，上面结果也还是一个正的，就是结果了



上面都是小数运算，不过整数也是一样处理的

## 补码加减运算中的溢出

**溢出只有两种**

（1）负溢出（下溢出），两个负数相加但是结果符号位为正

（2）正溢出（上溢出），两个正数相加但是结果符号位为负

> 溢出的产生是因为固定位数表示数的大小是固定的，当数的绝对值过大导致进位跑到符号位对符号位产生了破坏

**判断溢出的方法：**

直接用双符号位进行运算，如过两个符号位不一样，则说明发生了溢出

对于单个符号位来讲，只要两个正数相加（一个正数减负数）或者两个负数相加，结果变号了，那就说明发生了溢出	

## 补码的双符号位加减运算以及溢出的处理

双符号位就是两个符号位，其基本流程与单符号位一样，需要注意下面几点：

（1）正数的符号位就是00，负数的符号位是11

（2）计算的时候符号位更左边的更高位进位仍然舍去

（3）如果符号位不一样，则说明发生了溢出

（4）如果发生了溢出，比如符号位出现了01，或者10，此时最高的符号位仍然是正确的符号，第二个符号位作为正确补码数据的一部分 

> 如果如果是纯小数，第二个符号位作为小数中的个位，其后面才是小数点
>
> 如果是整数，第二个符号位作为数据位的最高位

**举例如下：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025174348217.png" alt="image-20241025174348217" style="zoom:67%;" />
$$
[X + Y]_补 = 00,0110
$$
这里最高位舍弃，因此结果就是X + Y = 00, 0110，真值就是+0.0110
$$
[X - Y]_补 = 01,0000
$$
显然，这里出现了正溢出，此时最高位就是正确的符号位，1这个进位作为数值的一部分，正确的补码应该是$[X - Y]_补 = 0,1.0000$这里只有第一位是符号位，小数点默认在第二位的后面；小数溢出肯定要多出一个个位的1

所以其正确的原码就是X - Y = 0,1.0000，真值就是+1.0000

同理，如果小数计算得到的补码结果是10,1100，那此时补码是一个负数，真实的补码应该是1, 0.1100，第一位是真实符号位，取反加一得到原码：1, 1.0100，因此真值就是-1.0100

> 注意只有溢出的时候符号位的第二位才能作为一个单独的最高数值位，比原来的结果多一位，但是如果没有溢出则还是原来的位数，这里我们主要是想得到真实的真值，至于计算机能不能表示又是另外一回事

**如果是整数举例如下：**

（1）X = +1100, Y = +1000，求X + Y

我们算得$[X + Y]_补 = 01,0100$，此时出现正溢出，但是最高的符号位仍然是正确的，第二个符号位作为最高位，因此原码是：
$$
[X + Y]_原 = 0,10100
$$
 真值就是+10100

（2）X = -1100, Y = -1000，求X + Y

我们算得$[X + Y]_补 = 10,1100$，此时出现负溢出，但是最高的符号位仍然是正确的，第二个符号位作为最高位，因此原码是：
$$
[X + Y]_原 = 1,10100
$$
 真值就是-10100

这里整数的小数点默认在最后，溢出后多出来的一位符号位在最高数值位

## 原码一位乘

![image-20241028204932038](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028204932038.png)

以这个乘法为例子

**（1）首先是符号位，通过异或得到**

这里的符号位S = 0^1 = 1

**（2）剩下数值的计算用的是绝对值，这里符号位仍然是两位**

|X| = 00, 1101, |Y| = 00, 1011

**（3）第一步，初始化，写出初始部分积和乘数，逗号表示前面是符号位，数值位的位数与被乘数一样**

![image-20241028205353665](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028205353665.png)

**（4）进行操作，每一步操作包含三步**

i 看乘数的末尾是1还是0

ii 如果是1，则部分积加上被乘数，这里是加上|X|，如果是0，则加上0，得到中间结果，哪怕溢出也要保留

iii 第二步得到的中间结果与乘数一起右移，中间结果左边补零，乘数最后一位移出去

比如上述一次操作之后：

![image-20241028211006853](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028211006853.png)

（5）一直执行这个操作，直到乘数的剩下几位全部移出去：

![image-20241028211846934](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028211846934.png)

加上符号位和小数点，因此结果就是1,10001111.这个是原码，真值就是-10001111了

对于小数也是一样，只不过小数点写在逗号位置处

## 补码一位乘

以下面这个为例子：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028214331489.png" alt="image-20241028214331489" style="zoom:67%;" />

**（1）求出$X_补，(-X)_补，Y_补$，这里的符号位还是用双位，逗号表示符号位与数值位的分界：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028215108288.png" alt="image-20241028215108288" style="zoom:50%;" />

**（2）初始化，写出部分积，乘数还有附加值0：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028215322349.png" alt="image-20241028215322349" style="zoom:67%;" />

**（3）进行一次操作，一次操作包含下面三步**

i 附加值减去乘数最后一位小于零还是大于零还是等于零

ii 如果小于零，则部分积加上$[-X]_补$得到中间结果，如果大于零，则加上$[X]_补$得到中间结果，如果等于零则加上零得到中间结果，符号位参与运算，中间结果超出两位符号位的进位丢掉

iii 中间结果和乘数整体右移一位，中间结果左边补符号位，乘数的逗号也跟着移动，并且最后一位移出去当作新的附加值

进行一次操作后的结果为：

![image-20241028221349272](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028221349272.png)

**（4）反复操作直到乘数Y补的数值位全部移出去，此时乘数部分只剩下Y补的符号位：**

![image-20241028223646683](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028223646683.png)

**（5）进行最后一次操作，但是不右移：**

![image-20241028223730251](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028223730251.png)

这样就得到结果了，至于小数点的位置，反正小数乘小数就是小数，整数乘整数就是整数，小数点按乘法的数的类型直接加上去即可，这里是小数，因此结果就是：
$$
[XY]_补 = 11, 01110001；XY = 11,10001111；XY_真 = -0.10001111
$$

## 补码两位乘

## 原码恢复余数除法

## 原码加减交替除（不恢复余数除）
