# 数据表示

## 机器数（以下均以8位为例）

机器数就是计算机内部的数据表示，最高位表示符号位，0（正）1（负）

> 我们这里按照每种不同表示类型的数据分别总结原码，补码，反码的真值范围
>
> 所谓真值就是符号用+-表示然后后面跟上数的书面写法，比如-4的二进制真值就是-100

计算机中的机器数表示用数的类型分的话其实就两种：

（1）定点表示法，只能表示纯小数和纯整数，这种方式的原码，补码理解很简单，并且定点整数就是一般的整数表示法

> 原码就是最高位是符号位，其他的位与真值一样
>
> 补码就是符号位与原码一样，其他位负数就是按位取反加一，正数就是不变

（2）浮点表示法

### 整数表示

#### 原码整数

原码整数就是在真值的基础上最高位变成了符号位，其范围就是：
$$
-(2^{7} -1)[1,1111111] \le a \le(2^{7} -1)[0,1111111]
$$
**原码零：**

0的表示不唯一，有$+ 0[0,0000000]$和$-0[1,0000000]$两种

#### 补码整数

负数补码对于原码来说就是符号位不变，其他位按位取反加一；正数就是补码原码一毛一样

> 算补码的真值的时候需要变换成原码，然后再计算真值，补码变成原码也是符号位不变，其他位按位取反加一

其范围是：
$$
-2^7[1,0000000] \le a\le 2^{7} -1[0,1111111]
$$
补码将原码中的$-0[1, 0000000]$当作了最小的数，补码的范围不对称

**补码零：**

补码零表示唯一，只有+0一种，即0, 0000000

#### 反码整数

其实就是每一位取反，这个范围不要求

### 定点表示（只能表示纯小数和纯整数）

需要注意的是，定点表示法只能表示纯小数和纯整数，整数定点表示默认小数点在最后一位后面，因此其实和上文的整数表示以及范围是一样的

> 另外，定点表示没有什么规划话的问题，定点表示非常简单，原码就是多了个符号位，补码就是负数按位取反加一，然后-0当作最小的数

下面只说一下定点小数的范围问题

#### 定点整数（跟整数表示一样）

#### 定点小数

定点小数默认小数点在符号位的后面

##### 定点原码小数

最高位仍然是符号位，其范围就是：
$$
-(1 - 2^{-7})[1,1111111] \le a\le 1 - 2^{-7}[0, 1111111]
$$

上面的逗号就是小数点的意思，逗号左边的数并不是个位，而是符号位

##### 定点补码小数

补码还是先转成原码，然后再看范围，转换规则不变，正数跟原码一样；负数就是除了符号位之外其他位取反加一

因此范围是：
$$
-1[1,0000000] \le a \le 1 - 2^7[0,1111111]
$$
还是将原来的-0变成了最小的数

##### 定点反码表示

除了符号位，其他位按位取反即可

# 数据计算

## 分数转化为定点小数的方法

**（1）一般处理方式**

一般题目中给定的分数都是分母是2的幂次方，这种情况直接分子用一堆2的幂的和表示，分母用二进制的幂表示，比如29/128：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025162614724.png" alt="image-20241025162614724" style="zoom:50%;" />

最高位是符号位，因此结果就是：`0,0011101`

如果是-29/128，结果是`1,0011101`

然后再将其转化为补码进行各种运算

**（2）十进制小数转化为二进制**

这种方式应该仅仅对于纯小数转化为二进制比较有意义，带整数的小数可以直接用浮点数表示

## 补码加减法运算

**补码加法公式：**
$$
[X + Y]_补 = [X]_补 + [Y]_补
$$
**补码减法公式：**
$$
[X - Y]_补 = [X]_补 + [-Y]_补
$$


<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025163550267.png" alt="image-20241025163550267" style="zoom:67%;" />

**补码加法运算过程：**

（1）求出每个操作数的补码：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025163608830.png" alt="image-20241025163608830" style="zoom:67%;" />

> 题目中真值小数点前的不是符号位，但是转换成补码之后小数点前面的就是符号位了，建议原码，补码符号位后面的小数点用逗号代替，真值中再用小数点，后文正文中都是逗号前面表示符号位，小数点的位置另说

（2）按照二进制的加法进行相加，进位，符号位同样参与运算，得到$[X + Y]_补 ([X]_补 + [Y]_补)$，最高位产生的进位丢掉，虽然符号位位可能改变，不过没关系：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025163842555.png" alt="image-20241025163842555" style="zoom:67%;" />

（3）将$[X + Y]_补$转换回X + Y，上面的结果就是一个正的，因此就是结果了：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025164155825.png" alt="image-20241025164155825" style="zoom:80%;" />

**补码减法运算：**

（1）求出X和-Y的补码，对于-Y的补码的求法，先变符号位，然后按照取反加一变成补码即可：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025164329776.png" alt="image-20241025164329776" style="zoom:67%;" />

（2）按照二进制的加法进行相加，进位，符号位同样参与运算，得到$[X - Y]_补 ([X]_补 + [-Y]_补)$，最高位产生的进位丢掉

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025164715364.png" alt="image-20241025164715364" style="zoom:67%;" />

（3）将$[X - Y]_补$转化为X - Y真值，上面结果也还是一个正的，就是结果了



上面都是小数运算，不过整数也是一样处理的

## 补码加减运算中的溢出

**溢出只有两种**

（1）负溢出（下溢出），两个负数相加但是结果符号位为正

（2）正溢出（上溢出），两个正数相加但是结果符号位为负

> 溢出的产生是因为固定位数表示数的大小是固定的，当数的绝对值过大导致进位跑到符号位对符号位产生了破坏

**判断溢出的方法：**

直接用双符号位进行运算，如过两个符号位不一样，则说明发生了溢出

对于单个符号位来讲，只要两个正数相加（一个正数减负数）或者两个负数相加，结果变号了，那就说明发生了溢出	

## 补码的双符号位加减运算以及溢出的处理

双符号位就是两个符号位，其基本流程与单符号位一样，需要注意下面几点：

（1）正数的符号位就是00，负数的符号位是11

（2）计算的时候符号位更左边的更高位进位仍然舍去

（3）如果符号位不一样，则说明发生了溢出

（4）如果发生了溢出，比如符号位出现了01，或者10，此时最高的符号位仍然是正确的符号，第二个符号位作为正确补码数据的一部分 

> 如果如果是纯小数，第二个符号位作为小数中的个位，其后面才是小数点
>
> 如果是整数，第二个符号位作为数据位的最高位

**举例如下：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241025174348217.png" alt="image-20241025174348217" style="zoom:67%;" />
$$
[X + Y]_补 = 00,0110
$$
这里最高位舍弃，因此结果就是X + Y = 00, 0110，真值就是+0.0110
$$
[X - Y]_补 = 01,0000
$$
显然，这里出现了正溢出，此时最高位就是正确的符号位，1这个进位作为数值的一部分，正确的补码应该是$[X - Y]_补 = 0,1.0000$这里只有第一位是符号位，小数点默认在第二位的后面；小数溢出肯定要多出一个个位的1

所以其正确的原码就是X - Y = 0,1.0000，真值就是+1.0000

同理，如果小数计算得到的补码结果是10,1100，那此时补码是一个负数，真实的补码应该是1, 0.1100，第一位是真实符号位，取反加一得到原码：1, 1.0100，因此真值就是-1.0100

> 注意只有溢出的时候符号位的第二位才能作为一个单独的最高数值位，比原来的结果多一位，但是如果没有溢出则还是原来的位数，这里我们主要是想得到真实的真值，至于计算机能不能表示又是另外一回事

**如果是整数举例如下：**

（1）X = +1100, Y = +1000，求X + Y

我们算得$[X + Y]_补 = 01,0100$，此时出现正溢出，但是最高的符号位仍然是正确的，第二个符号位作为最高位，因此原码是：
$$
[X + Y]_原 = 0,10100
$$
 真值就是+10100

（2）X = -1100, Y = -1000，求X + Y

我们算得$[X + Y]_补 = 10,1100$，此时出现负溢出，但是最高的符号位仍然是正确的，第二个符号位作为最高位，因此原码是：
$$
[X + Y]_原 = 1,10100
$$
 真值就是-10100

这里整数的小数点默认在最后，溢出后多出来的一位符号位在最高数值位

## 原码一位乘

![image-20241028204932038](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028204932038.png)

以这个乘法为例子

**（1）首先是符号位，通过异或得到**

这里的符号位S = 0^1 = 1

**（2）剩下数值的计算用的是绝对值，这里符号位仍然是两位**

|X| = 00, 1101, |Y| = 00, 1011

**（3）第一步，初始化，写出初始部分积和乘数，逗号表示前面是符号位，数值位的位数与被乘数一样**

![image-20241028205353665](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028205353665.png)

**（4）进行操作，每一步操作包含三步**

i 看乘数的末尾是1还是0

ii 如果是1，则部分积加上被乘数，这里是加上|X|，如果是0，则加上0，得到中间结果，哪怕溢出也要保留

iii 第二步得到的中间结果与乘数一起右移，中间结果左边补零，乘数最后一位移出去

比如上述一次操作之后：

![image-20241028211006853](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028211006853.png)

（5）一直执行这个操作，直到乘数的剩下几位全部移出去：

![image-20241028211846934](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028211846934.png)

加上符号位和小数点，因此结果就是1,10001111.这个是原码，真值就是-10001111了

对于小数也是一样，只不过小数点写在逗号位置处

## 补码一位乘

以下面这个为例子：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028214331489.png" alt="image-20241028214331489" style="zoom:67%;" />

**（1）求出$X_补，(-X)_补，Y_补$，这里的符号位还是用双位，逗号表示符号位与数值位的分界：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028215108288.png" alt="image-20241028215108288" style="zoom:50%;" />

**（2）初始化，写出部分积，乘数还有附加值0：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028215322349.png" alt="image-20241028215322349" style="zoom:67%;" />

**（3）进行一次操作，一次操作包含下面三步**

i 附加值减去乘数最后一位小于零还是大于零还是等于零

ii 如果小于零，则部分积加上$[-X]_补$得到中间结果，如果大于零，则加上$[X]_补$得到中间结果，如果等于零则加上零得到中间结果，符号位参与运算，中间结果超出两位符号位的进位丢掉

iii 中间结果和乘数整体右移一位，中间结果左边补符号位，乘数的逗号也跟着移动，并且最后一位移出去当作新的附加值

进行一次操作后的结果为：

![image-20241028221349272](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028221349272.png)

**（4）反复操作直到乘数Y补的数值位全部移出去，此时乘数部分只剩下Y补的符号位：**

![image-20241028223646683](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028223646683.png)

**（5）进行最后一次操作，但是不右移：**

![image-20241028223730251](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241028223730251.png)

这样就得到结果了，至于小数点的位置，反正小数乘小数就是小数，整数乘整数就是整数，小数点按乘法的数的类型直接加上去即可，这里是小数，因此结果就是：
$$
[XY]_补 = 11, 01110001；XY = 11,10001111；XY_真 = -0.10001111
$$

## 补码两位乘

以下面的计算为例：

![image-20241029183744266](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241029183744266.png)

**（1）分别算出$[X]_补，[-X]_补，[Y]_补，[2X]_补，[-2X]_补$，其中X有关的式子用三位符号位表示，如果有进位，符号位最低位表示进位：**
$$
[X]_补 = 000, 110011;[-X]_补 = 111,001101;[Y]_补 = 11,010110;[2X]_补 = 001,100110;[-2X]_补 = 110,011010
$$

> 关于三位符号位，上面的小数点的位置其实应该是逗号，表示符号与数值位的分界，如果是正数符号位是000, xxxxx；如果是负数符号位是111, xxxxx，负号取补的时候仍然是符号位不变，数值位取反加一，取反加一这个运算只有原码是111, 000000的时候数值位才会有进位，这个进位舍去，1111,00000这个补码就当作补码可以表示的最小的数
>
> 补码二位乘的时候计算2X的补码，进位保留在符号位的最后一位上，其实就是在原来的补码基础上数值整体左移一位，低位补零

**（2）初始化有下面几个操作：**

i 部分积部分的符号位为三位

ii 如果乘数部分的数值位是奇数个，则其符号位只有1位，乘数部分的数值位是偶数个，符号位设为2位；反正保证乘数的总位数（符号位加上数值位是偶数个）

iii 附加位初始设为0

比如上述例子中乘数的数值位是偶数，因此乘数Y的符号位就是2位，所以初始化如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241029185929018.png" alt="image-20241029185929018" style="zoom: 50%;" />

**（3）进行一次操作，一次操作包含下面几步：**

i 观察乘数的最低两位$Y_{n-1}Y_n$和附加位$Y_{n + 1}$组成的三位，根据三位不同的值进行不同的加法操作

ii 进行加法操作，对应表如下所示，需要背下来：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241029203031873.png" alt="image-20241029203031873" style="zoom: 67%;" />

上表中的$[Z_{i + 2}]_补，[Z_i]_补$分别是本次操作的中间结果和上一次操作结束得到的部分积

iii 中间结果带着乘数一起右移两位，中间结果右移左边补第一个符号位，乘数右移逗号也跟着右移，得到新的部分积

上面例子进行一次操作如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241029204045303.png" alt="image-20241029204045303" style="zoom:67%;" />

**（4）反复执行操作，直到结束，结束分两种情况**

i 如果乘数的数值位是偶数，比如这里是6位，那么每次操作右移两位，因此3次操作后数值位全部移出去，此时再进行一次操作但是不移位得到结果，因此如果数值位是2n位，则进行n + 1次操作，最后一次操作不移位

ii 如果乘数的数值位是奇数，比如是5位，那么每次操作右移两位，2次操作之后还剩下一个数值位，此时再进行一次操作但是只右移一次得到结果，因此如果数值位是2n + 1位，则进行n + 1次操作，最后一次操作右移一位

上述例子一直操作到最后如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241029210428091.png" alt="image-20241029210428091" style="zoom:67%;" />

有的课本教材最后还有将符号位清零，其实这个不用管，反正我们算的都是定点数，小数乘小数是小数，整数乘整数是整数

因此这道题目：
$$
[XY]_补 = 111, 011110100010;[XY]_原 = 111,100001011110;[XY]_真 = -0.100001011110
$$

## 原码恢复余数除法

首先，进行原码除法的时候符号位是由两个操作数的符号位异或得到

然后为了跟前面的乘法一样保证都是定点数，规定定点小数除法是小的除以大的得到定点小数，定点整数的除法是大的除以小的得到定点整数，就是反正操作数和结果要么都是定点小数，要么都是定点整数

其包括下面的步骤，以下面的为例子：

![image-20241104162606730](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104162606730.png)

这里是定点小数用小的除以大的因此X是除数

**（1）算出$[|X|]_补，[|Y|]_补，[-|Y|]_补$**：

![image-20241104162832121](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104162832121.png)

下面的操作一律都是按照补码进行的

**（2）初始化，写出初始余数和商，初始余数就是$[|X|]_补$，商为0000，这里的商的位数与X的数值位数一样**：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104163418219.png" alt="image-20241104163418219" style="zoom:50%;" />

**（3）进行一次操作，一次操作包含下面几步：**

i 算中间余数，加上$[-|Y|]_补$，得到中间余数

ii 算商，观察中间余数的正负来决定商的一位，如果中间余数小于零，则商0，如果中间余数大于零，则商1，商的一位放在Q的末尾

iii 恢复余数，如果中间余数小于零，则中间余数需要再加上$[|Y|]_补$恢复；如果中间余数大于零，则不变

iv 中间余数和商统一左移一位，这里的左移低位补零

上面例子进行一次操作如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104164308075.png" alt="image-20241104164308075" style="zoom:67%;" />

**（4）重复n次操作，这里的n是余数的数值位的位数，这里就是重复四次操作：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104173615906.png" alt="image-20241104173615906" style="zoom: 50%;" />

这里的第四次移位一定会将0移动到小数点前面，但是不要紧，因为这里的定点小数除法一定是小数除以大数，所以我们第一次上的商一定是0

**（5）最后一次操作**

i 算中间余数，加上$[-|Y|]_补$，得到中间余数

ii 算商，如果此时的中间余数为正，商1，如果此时的中间余数为负，商0

iii 恢复余数，如果中间余数小于零，则中间余数需要再加上$[|Y|]_补$恢复；如果中间余数大于零，则不变

iv 商和余数都不左移，最后的结果余数一共左移了n次需要乘$2^{-n}$，这里乘$2^{-4}$

上面的例子如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241104174910059.png" alt="image-20241104174910059" style="zoom:50%;" />

符号位单独计算，由两个数的符号位异或得到，因此这里的结果就是：
$$
R = 0.0001 * 2^{-4}；[x]_原 / [y]_原 = 1.1101
$$
注意最后的结果就是数值位，不用再取补什么的

## 原码加减交替除（不恢复余数除）
