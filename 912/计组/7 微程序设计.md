# 7 微程序控制器

## 指令，微程序，微指令，微命令，微操作以及各自的关系

计算机的控制命令的产生是由控制器决定的，比如组合逻辑控制器，其通过计算机的当前状态利用组合逻辑来产生一条指令的执行所需要的控制命令，很显然，这样的设计会导致硬件非常复杂，这时就有了微程序控制的概念，也就是微程序控制器

**所谓微程序控制，就是给每一条指令编写一个程序，这个程序就称为微程序，指令执行的同时执行这个微程序，这个微程序产生了这条指令执行所需的所有的控制信号，这种方式就很偏软件，其执行过程很像指令的执行过程**

这种方式的控制器就称为微程序控制器

一条机器指令所需的所有控制信号用一个微程序执行来发出

一个微程序包含多条微指令

一条微指令浓缩了多个微命令，执行这条微指令也就产生了当前机器指令所需的微命令，逐条执行微指令也就产生了这条机器指令所需的所有微命令

其实微命令就是控制信号，控制部件再执行一条微指令之后发出微命令给各种部件，部件接收到微命令执行的操作就是一个微操作，微操作就是部件执行的最基本操作了

对于一条机器指令来说其对应一个微程序产生其执行过程所需的所有的控制命令

而不同的机器指令其实有些阶段是一个的，比如取值阶段，那么所有的机器指令对应的微程序中就必然有完全一样的微指令

我们可以将这些微指令取出来当作公共的微指令，这样可以省一些空间

> 比如有32条机器指令，公共的取值微程序包含2条微指令，平均一条指令对应4条微指令，那么所有的指令所对应的微指令的条数就应该是2 + 32 * 4 = 130条

## 微程序控制器的组成

微程序的执行是再微程序控制器中的，这种控制器显然与硬部件控制器是不同的

由于类似指令的执行，微程序控制器也非常类似CPU的组成，其包括下面几个部分

控存CM，这里存放的是微程序

微地址寄存器CMAR，类似MAR，用来暂存微程序中微指令的地址，因为指令只进行寻址不去找数据，所以其可以具有自增的功能，用来顺序寻址

微指令寄存器CIR或者CMDR，类似IR，用来暂存微程序中的微指令

微地址选择逻辑，这一堆硬件部件根据微指令的顺序控制字段来形成下一条微指令的地址

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119210809184.png" alt="image-20241119210809184" style="zoom:50%;" />

**微程序的执行流程：**

首先，一条机器指令进行取值过程，取值过程是通用的过程，因此需用通用的微程序形成控制信号

这时控制内部自动将取值的微程序的入口地址放入到CMAR中，这时CMAR从CM中取出取值所用的微微指令放到CIR中执行

当取值的微程序执行完毕的时候当前机器指令的OP会通过微程序控制器内部的部件产生当前机器指令所需的微程序的入口地址放入到CMAR中

接着就从CM中逐条取出微指令放绕CIR中执行

当执行完一条机器指令所需的微程序之后就又需要取值，机器自动将取值的微程序入口地址放入到CMAR中重复这个过程

## 微指令的结构

然后我们看看**微指令的基本格式**：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241118222058431.png" alt="image-20241118222058431" style="zoom:50%;" />

### **微操作控制字段：**

微操作控制字段这个字段产生全部的控制信号，注意这是一条微指令，一段时间的所有微命令组织在一起形成一个控制字，就是微指令

设计控制字段的方式主要有三种：

**（1）直接编码方式**

就是微指令中的每一位都表示一个微命令，0表示这个微命令无效，1表示微命令有效

**（2）字段直接编码方式**

> 首先微命令其实有互斥与相容之分
>
> 所谓互斥就是指不同同时出现的微命令，比如存储器的读和写就不能同时出现
>
> 所谓相容就是指可以同时出现的微命令，比如寄存器写和加法操作等；显然直接编码方式不能体现互斥与相容

所谓字段直接编码就是：

用控制字段中的一小段来表示一组互斥的微命令，而不同的小端之间表示可以相容的微命令，比如XXX YYY这两组字段，XXX三者在同一时间只能翻译成一个微命令，那XXX的二进制不同组合有8种，那就可以表示8种互斥的微命令，而YYY的编码可以与XXX共存，因此XXX和YYY分别表示的微命令就可以共存

当一个字段短到只有一位的时候就认为是混合编码方式，即直接编码和字段直接编码相结合的编码方式

注意每个字段除了表示互斥的一组微命令之外还应该留有一种编码表示无操作，因此一个字段如果有n位，则一般可以表示$2^n - 1$个微命令

**（3）字段间接编码方式**

字段直接编码方式的一个字段的一种编码就表示一个微命令，而间接编码则是一个字段还要兼容其他的字段来共同编码一个微命令，显然这种编码方式进一步压缩了微指令的长度，但是因为多个字段才能确定一条微命令，因此同时能够并行的微命令就少了很多

### **顺序控制字段：**

这个字段指出下一条微指令的地址，用于顺序控制

下一条指令，也就是下一条微地址的形成方式有如下几种：

**（1）直接表示方式**

也就是在顺序控制字段中直接给出下一条微指令的地址

**（2）增量方式**

所谓增量方式，就是将微指令CMAR当作PC一样让其具有自增的功能，这时寻址的话就必须要给出顺序控制字段了，直接CMAR自动增加即可，下面是顺序型微指令的格式，其省去了顺序控制字段：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119200540370.png" alt="image-20241119200540370" style="zoom:50%;" />

不过这里只有顺序微指令才能这样寻址，很显然类似于指令，还有一种是转移型的微指令，跟一般的指令一样，其需要满足条件之后进行跳转，地址就是顺序控制字段给出的地址，因此其就需要一个条件字段和转移地址字段，这两类字段都放在顺序控制字段中，其结构如下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119200737118.png" alt="image-20241119200737118" style="zoom:50%;" />



**（3）增量和下址字段相结合的方式**

这种方式其实跟增量方式是差不多的，这种方式与增量方式不同之处在于统一了指令的格式：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119200940910.png" alt="image-20241119200940910" style="zoom:50%;" />

此时CMAR仍然保留有自增的功能，当满足条件的时候进行条件转移，当不满足条件的时候直接自增

显然，（2）（3）两种方式只能实现两路转移

> 这里的条件选择字段的设计原理是一种编码表示一种条件，也就是一种编码选择一种条件进行测试
>
> 比如00表示顺序转移
>
> 比如11表示无条件转移
>
> 比如01表示测试条件C，C = 1转移，C = 0顺序执行
>
> 比如10表示测试条件B，B = 1转移，B = 0顺序执行
>
> 不过这里不管是哪一种编码，都只能进行两路转移，并且必须预留00和11表示顺序转移和无条件转移

**（4）断定方式**

所谓断定方式，就是通过机器的状态来得到地址，他与前面的区别在于CMAR没有自增功能了，所有的微指令地址都是由顺序控制字段产生的

顺序控制字段分为两个部分

一个部分作为产生的微指令地址的高位，是非测试字段

另一个部分作为测试字段，用来测试机器的状态，即断定机器的状态来得到后继的低位地址：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241119201434704.png" alt="image-20241119201434704" style="zoom: 50%;" />

显然，这种方式可以实现多路转移