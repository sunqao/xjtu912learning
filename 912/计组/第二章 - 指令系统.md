# 2-指令系统

## 2.1 概述

**定义：**

指令系统是指一台计算机所具有的全部机器指令的集合，它反映了该机所拥有的基本功能，是软件和硬件的接口或者交界面；为了使指令系统中的每条指令都可以在计算机上执行， 计算机硬件相应地就具有执行这些指令的逻辑线路， 所以指令系统表征了计算机硬件的基本功能，是对计算机硬件功能的具体描述。

如果在计算机的一个基本操作是由硬件实现，那就应该在指令系统中设置一条专用的指令，如果这个操作是由软件实现，那么这个操作就是通过一条条指令组成的子程序来实现的。

**分类：**

从计算机系统的层次结构来说， 计算机的指令有宏指令、机器指令和微指令之分：

**宏指令**是由若干条机器指令组成的软件指令，它属于软件。

**微指令**是微程序级的命令，它属于硬件。

**机器指令**（通常简称为指令） 介于微指令与宏指令之间，每条指令可完成一个独立的操作，如一个算术运算或一次数据传送操作，机器指令就是一条二进制数，早起程序员就用一条打孔纸带上的机器指令来控制计算机

指令格式则是指令字用二进制代码表示的结构形式，由操作码字段和地址码字段组成。操作码字段表征指令的操作特性与功能；地址码字段通常指定参与操作的操作数的地址

## 2.2 指令系统的发展

**指令系统发展的三个特征：**

（1）软件硬化，用一条功能复杂的新指令来取代原先需要一串指令完成的功能，这是为了避免反复访存带来的时间损耗

（2）不断增加功能复杂的指令和复杂的寻址方式来支持高级语言的高效实现

（3）为了兼容系列机软件，指令系统不断扩大

**CISC（复杂指令系统计算机）的主要问题：**

（1）指令系统庞大，指令功能和寻址方式以及指令格失复杂，导致编译程序复杂，速度慢，难以通过编译优化生成高效的目标代码程序

（2）指令功能复杂，且每种指令都可访存，占用多个机器周期

（3）为了实现复杂的指令系统，采用了微程序控制技术，由微程序解释执行机器指令，这样又影响了指令的执行速度

（4）有80%左右的指令只有在20%的cpu时间才会被用到，即存在大量不经常使用的指令，这就导致cpu的研发制造周期非常长，难以调试以及可维护性差

**计算机执行程序所需的时间：**

![image-20240724173312945](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240724173312945.png)

RISC指令与CISC相比，由于其简化了指令复杂功能，因此一个程序的指令条数会比CISC多一些，但是由于RISC指令大多由一个机器周期实现，所以CPI比CISC低很多，并且由于RISC指令结构更加简单，所以完成一个同样的操作经过CPU内部数据通路更短，因此一个机器周期也比CISC指令对应的硬件结构小很多

**RISC（精简指令系统计算机）的特点：**

（1）指令长度固定，格失少，寻址方式少，指令各个字段划分一致，各个字段功能规整

（2）指令中只有取数/存数指令访存，其余指令都在寄存器之间进行

（3）控制单元直接以硬件布线为主，很少采用微程序控制

（4）优先选取了使用频率高的指令，避免复杂指令，采用编译优化技术，减少程序执行时间

（5）cpu中的通用寄存器数量很多，大多数的算数逻辑运算指令的操作数都在寄存器中存取

（6）cpu采用流水线结构，大部分指令都可以在一个机器周期中完成

mips32是RISC结构的经典代表，下文中都将以mips32作为RISC指令系统的范例进行介绍

## 2.3 指令系统的功能

### 2.3.1 指令系统的设计原则

**（1）完整性**

其要求通用计算机应该具备完善的指令功能，这时CISC指令系统的特点，许多指令的功能完全可以通过使用基本指令编写程序实现，因此完整性但不是RISC指令的特点

**（2）规整性**

规整性包括三个方面：

1. 对称性，指所有的运算部件都能够同等的访问所有的的寄存器和存储器单元，所有的指令都可以使用各种寻址方式
2. 匀齐性，指一种操作性质的指令可以支持各种数据类型，比如算术运算指令可以支持字节，字，双整形，以及十进制和单双精度浮点数的运算
3. 一致性，指指令格式和数据格式的一致性，也就是指令长度和数据长度应该有一定的关系而方便存取，比如指令长度和数据长度通常都是字节的整数倍

**（3）高效性**

通常CISC是通过复杂的指令完成指令工作减少程序中指令的条数来提供效率；而RISC更强调减少单条指令的执行时间来提高效率

**（4）兼容性**

指系列机种之间应该具备相同的基本结构和共同的指令系统，从而保证各个机种之间的软件应该可以通用；不过通常只能做到向后兼容和向上兼容

### 2.3.2 数据类型

数据类型，数据表示，操作数的定义如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240724180638135.png" alt="image-20240724180638135" style="zoom:50%;" />

操作数构成了指令的一部分，注意操作数和数据表示有些不一样，操作数单指指令的一部分，一般而言这一部分（指操作数类型）可以包括地址，数字，字符，逻辑数等等；但是数据表示是指硬件可以直接识别的数据类型，它可以作为操作数从而变成指令的一部分，也可以是存储器中存放的指令可以直接操作硬件可以识别的数据类型；操作数是指令中的概念，数据表示意义更广一些

在机器中一律使用二进制表示这些操作数，为了让硬件区分不同的操作数类型，通常使用操作码来区分指定不同的操作数

#### 操作数类型

下面我们主要介绍的就是操作数类型

**（1）地址**

地址就是指令或是操作数被存放在存储设备中的位置编码（注意指令也是放在存储器中存放的），主要的存储设备包括通用寄存器，主存和IO设备；地址是一种比较特殊的操作数，指令中可以直接给出地址，当然大多数情况是需要计算得到的，下文细嗦

**（2）数字**

数字型数据是计算机处理的最基本操作数类型。计算机中常用的数字类型有定点数和浮点数

**（3）字符**

文本或者字符串也是常见的数据类型

**（4）逻辑数**

不赘述

需要注意的是，MIPS32指令中存数或取数指令分别有字节，半字，和字的操作，并且对于字节或者半字的数据载入到32位寄存器时是载入到低位的，高位部分需要进行扩充，对于有符号数的扩充是用符号位扩充，对于无符号数的扩展需要用零扩展

#### 地址空间

下面介绍指令中的**地址空间**，地址空间也是又一串二进制的地址操作数形成的：

首先是计算机中的主要存储设备，主要包含三个，寄存器，主存储器，和IO设备，它们各自都包含多个可编址的数据单 元。对这些单可以 **统一编址** 或者 **单独编址**，从而形成了单地址空间或这多个地址空间

![image-20240727171055976](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240727171055976.png)

对于三个地址空间，也就是主存，寄存器和IO设备三者都独立编址，在RISC机器中，规定所有的运算，移位测试等操作只能在通用寄存器中进行，只有访问操作（读写）才可以在三种存储设备中进行；而对于CISC系统，所有的操作都可以在三种存储器中进行，这就导致指令非常复杂

对于两个地址空间，即对通用寄存器编址，以及对主存和IO设备编址；通常做法是将主存和IO设备的地址空间的高端划出给IO设备；将主存和io一起编址可以简化指令系统，因为不需要再另设指令分别取访问主存和IO，但是统一编址后需要译码器区分到底是访问主存还是IO设备，因此这样编址会影响指令执行的速度

对于一个地址空间，就是三个存储设备统一编址，一般指令空间的最低端划分给通用寄存器，最高端划分给io设备，中间部分给主存；这里的高端和低端的意思大概是地址空间的低地址部分，和高地址部分（毕竟访存的时候还是通过二进制数形成一个地址的）

对于无地址空间，也成为隐含编址，在堆栈计算机中，运算指令是不需要地址的

#### 编址方式

计算机硬件可以支持指令按照不同的长度访问存储设备中的数据，比如按照字，半字，字节，所以指令访问存储设备中的最小单位也可以是字或半字或字节，我们将指令可以访问的最小数据位数构成一个编址单位；而编址方式就是指主存单元的地址编排方式（其实也不一定是主存），其决定了主存的最小访问单元，即决定了一个编址单位是字还是字节还是半字，一般而言常用的编址单位有字和字节

**（1）按字编址**

这种编址方式就是一个编址单位是一个字，以8086为例，其字长位16位，并且数据总线也是16位，这样编址单位的二进制位数就与访问一次设备得到数据的二进制位数一样了

如果指令字长（就是指令的长度，取决于操作码长度，操作数地址和操作数地址的个数）和数据字长（计算机中存储一个数据所占用的位数，也就是数据单位的位数，数据字长的长短决定了计算机在一次操作中能够处理的数据量大小）和机器字长（cpu可以一次处理的位数，就是通用寄存器的位数）三者相等（早期计算机中就是三者相等）；那么每次取值之后PC（程序计数器）自动加一，每次取数据之后数据指针也是自动加一减一的（后面细嗦）

但是按字编址显然是不灵活的，数据的空间占有率不高，且特别是非数值领域

对于按字编址的主存大小，其容量为：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240727175236559.png" alt="image-20240727175236559" style="zoom:50%;" />

**（2）按字节编址**

为了适应非数值的数据，比如一个字符ASCII码就是一个字节的长度，一般而言信息的基本单位就是一个字节，所以现在的普遍编址方式就是按字节编址；但是一般计算机的字长（指通用寄存器的位数）都是字节的4倍以上，所以计算机中编址单位所含的信息量（一个字节）就与访问一次存储器所获得的信息是不同的，这就产生了字节在存储器中的存放问题

对于存储器按字节编址，那么存储器就既有字节地址也有字地址，字节地址是连续的（也就是最小存储单元）按0， 1， 2...这样递增下去；但是字地址不是连续的，比如一个32位机器其字的长度就是32位是字节的$2^2$倍，所以字的地址就是0, 4, 8, 16....

所以如果对于一个32位的地址编码，如果按照字节寻址那么寻址空间大小就是$2^{32} B = 4GB$，如果按照字来寻址，字长位32位，因此4个字节构成一个字长，字的个数就是字节的个数除以4，因此字的寻址空间大小就是$2^{32} / 4 (Word) = 1G(Word)$

按字节编址的存储器中有两个问题

**字节编址存放顺序问题**

对于多字节的数据存放在存储器中有两种存放顺序，一种是低字节放在低地址（小端存放），一种是低字节放在高地址（大端存放）；两种存放示意图如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240727181249797.png" alt="image-20240727181249797" style="zoom:50%;" />

**不同字长数据存放的边界问题**

对于程序中的不同数据其字长也是不一样的，这些数据在主存中混合存放其存放方式有两种，边界对齐和边界不对齐

所谓边界对齐，就是严格规定了字节，字，半字，双字存放的其实位置，比如假设机器字长为32位，规定半字长数据的存放起始位置必须是偶地址，单字长的数据存放起始地址必须是4的倍数，并且按照小端存放方式存放数据如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240727182517450.png" alt="image-20240727182517450" style="zoom:50%;" />

第二行的字数据显然不能再存放再第一行了，因为其存放的地址必须为4的倍数，因此这就会造成空间的浪费，如上图的阴影所示

所谓边界不对其，就是一个数据挨着一个数据存放将空间都占满，如下所示（还是小端存放方式）：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240727182704211.png" alt="image-20240727182704211" style="zoom:50%;" />

上图中的阴影是一个字数据，可以看到它的存放被拆成了两段

但是这就带来两个问题，一个是上图字数据跨越了两个字单元，因此如果是16位的数据总线访存的时候就必须得访问两次主存才可以将数据取出，同样一个字节，半字，都可能跨越两个字单元，这样就造成了访问速度下降了一半；另外一个问题就是存储器的读写控制很麻烦，因为这种存放的边界问题不规整，很难判断相邻的两位是否是真的属于一个完整的数值

对于MIPS处理器，其要求严格的边界对齐，以32位机器字长为例，要求半字数据必须放在偶字节地址上，字数据必须放在4倍字节地址上，双字数据必须放在8倍字节地址上

### 2.3.3 操作类型

所谓的操作类型就是把指令系统按功能进行分类，一般来讲指令系统包含五大指令：数据传送，数据运算，程序控制，输入输出，其他这五大指令

#### 数据传送指令

这类指令的功能就是在寄存器之间，寄存器和主存之间，以及主存之间传送数据

#### 数据运算指令

需要注意的是CISC指令支持支持源操作数和目的操作数在内存单元的运算类指令，但是RISC指令只有存数和取数可以访问内存，运算类指令的源操作数和目的操作数都在寄存器中（至于什么是源操作数什么是目的操作数，后文细嗦）

数据运算指令包括下面四类：

**（1）算数运算指令**

也就是算数运算，包括加减乘除等等

**（2）逻辑运算指令**

与或非操作

**（3）移位指令**

移位指令包括算数移位，逻辑移位，循环移位三种；

对于算数移位而言有算数左移（高位移除，低位补零）算数右移（低位移除，高位补符号位）

对于逻辑移位而言有逻辑左移（高位移除，低位补零）逻辑右移（低位移除，高位补零）

对于循环移位而言有循环左移（循环左移将二进制数的所有位向左移动一个或多个位置，移出的高位重新插入到低位）

```c
原数：  00101100
左移1位：00101100 -> 01011000
```

循环右移（循环右移将二进制数的所有位向右移动一个或多个位置，移出的低位重新插入到高位）：

```c
原数：  00101100
右移1位：00101100 -> 00010110
```

**（4）程序控制指令**

程序控制指令也被称为转移指令，其包括无条件转移，条件转移，调用与返回，陷阱和陷阱指令

对于无条件转移就是直接将程序转移到一条需要执行的指令

对于条件转移就是条件满足，就转移，一般机器都可以提供条件码作为某些指令的执行结果，比如零标志，如果结果为零就将这个位置为零等

对于调用与返回指令，也就是CALL和RETURN指令，CALL表示转移到子程序的入口来执行子程序，RETURN表示返回调用的位置即源程序的调用子程序的断点位置，CALL和RETURN指令都是成对出现的；此外需要注意的是为了能够正确返回到源程序，在调用子程序的时候需要记住返回到源程序的地址以便子程序执行结束的时候可以正确返回；一般在调用子程序的时候返回地址可以存放在寄存器中，但是这种方式难以实现子程序嵌套（即子程序调用子程序，因为寄存器的数量是有限的，一般只能记住源程序的地址）；或者放在子程序的开始地址单元处，然后从第二个单元开始执行子程序，这种方式可以实现子程序的嵌套，但是不能实现递归子程序；最好的方法是存放在堆栈中，当调用结束的时候就从堆栈弹出返回地址

对于陷阱和陷阱指令，所谓陷阱就是程序在执行过程中发生了意外事故导致程序不能正常运行，比如电压不稳定或执行了除以零的操作，此时计算机就发出陷阱信号，转入处理程序进行相应的故障处理；一般而言陷阱指令不是直接提供给用户使用的，但是IA-32的软中断指令是提供给用户使用的陷阱指令

**（5）输入输出指令**

对于输入输出单独编址的计算机而言设有输入输出指令，这个指令完成从IO接口中的寄存器读入一个数据到cpu中的寄存器，或者从cpu中的寄存器写入到io接口寄存器中

**（6）其他**

不再赘述

## 2.4 指令格式

指令格式就是指令的二进制表示形式

### 2.4.1 指令的组成

指令格式就是二进制代码表示的指令结构形式，其包括操作码和地址码两个部分，如下所示：

![image-20240728161439978](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728161439978.png)

操作码指出了指令完成的功能，地址码指出操作数的地址，也就是操作对象所处的位置，或者下一条指令在主存中的位置

#### 操作码

指令的操作码需要给出两部分信息

（1）指令的操作类型，比如加减乘除移位，存储读取等等

（2）所需操作数的类型，计算机中存放的数据就是单纯的一堆二进制的数，如果解读这一串二进制数就需要指令的操作码给出解释字段

#### 地址码

指令中涉及的地址包括寄存器地址，主存地址，和IO设备地址；

#### 指令的分类（CPU的结构）

指令中的地址码的形式实际上取决于cpu结构，一般而言cpu分为堆栈型，累加器型和通用寄存器三种cpu结构，相应的指令结构也分为三种：堆栈型，累加器型和通用寄存器型；对于不同结构的指令系统，其操作数的位置，个数，以及给出方式（显式给出，即操作数直接在指令中或者明确给出了操作数的地址，隐式给出即操作数放在某个位置处，这个位置是固定的，不需要给出地址，比如push ax, 自动将ax内容放入到堆栈顶的位置处，或者total += 5，默认有一个操作数就是在total的位置）；下面来分别介绍这几种cpu结构：

**首先是堆栈型的cpu结构：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728164114467.png" alt="image-20240728164114467"  />

上图中的灰色是源操作数，TOS即栈顶，堆栈寄存器中的两个源操作数都是隐式给出的，即约定存放在栈顶和次栈顶，当结果得出之后再将结果放入到栈顶，上图中原来是有两个灰色块的，黑色块是运算结果，放在栈顶，此时TOS应该指向黑色块才对；在这种cpu结构中，只能通过push/pop操作访问存储器

**然后是累加器型cpu结构：**

![image-20240728164736574](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728164736574.png)

其中累加器AC是隐式的，这个存储单元既作为源操作数又作为运算结果，也就是累加，在这个单元上不断加上一个存储器中的另一个操作数

**然后是通用寄存器结构（RS，指寄存器存储器类型）：**

![image-20240728165628001](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728165628001.png)

在通用寄存器结构中所有的操作数都显示给出，对于RS型的结构，也就是指一个源操作数存放在通用寄存器中，另一个来自存储单元中，然后运算结果放入到通用寄存器中

**最后是RR型的通用寄存器结果（指寄存器寄存器类型）：**

![image-20240728165731454](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728165731454.png)

在RR型的cpu结构中，两个源操作数，运算结果全部放在通用寄存器中；对于通用寄存器结构的cpu，所有的操作数都是显示给出的

通过上述分析，很显然对于堆栈型和累加器型的计算机，其指令的长度比较短，程序占用空间小，但是堆栈类型的计算机不能随机访问堆栈（固定在栈顶和次栈顶）；累加器型还有一个累加器作为中间单元，因此程序需要频繁访问存储器，降低了程序的执行效率；所以目前大多数计算机都采用的是通用寄存器型的结构

对于通用寄存器的指令系统，ALU可以最多三个操作数，包括两个源操作数和一个结果操作数，因此通用寄存器的指令系统中存储器操作数可以为0个，1个，或者2个3个；**这样我们可以根据存储器操作数的个数对通用寄存器的指令系统进行进一步的划**分：RR(寄存器寄存器型，没有存储器操作数)，RS（有一个存储器操作数），SS（全部都是存储器操作数）

一般而言，指令的格式和长度越单一（比如RR型的指令系统，操作数只考虑几个寄存器即可），编译器需要做的优化工作就越简单，但是目标代码长度就很长，而指令的格式和长度越丰富，目标代码的长度就越短（因为可以用一条指令完成一段简单指令程序的功能），但是这种多样性会增加编译器和cpu硬件的实现难度；目前SS型的指令系统已经弃用，上述三种指令系统的优缺点如下所示：

| 指令系统类型             | 优点                                                         | 缺点                                                         |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| RR（寄存器，寄存器类型） | 字长固定，结构简单，各个指令执行时钟周期数相近               | 指令条数多，目标代码复杂，占用空间大                         |
| RS（寄存器，存储器类型） | 不需要load指令加载到寄存器中，可直接对存储器中数据引用，目标代码紧凑 | 指令中的操作数不对称，对存储器中的操作数编码会影响可使用的寄存器个数（存储器很大，可能占用寄存器对应的二进制位）；不同指令的时钟周期差异很大 |
| SS（存储器，存储器类型） | 目标代码最紧凑，不需要寄存器保存变量了                       | 由于存储器很大，所以指令的字长变化很大，并且频繁访问存储器很影响效率，现在已经弃用 |

#### 指令的分类（地址的个数）

如上文所述，对于一个指令系统而言最多包含三个操作数，一元操作包含一个源操作数和一个目的操作数，二元操作涉及三个操作数，两个源操作数和一个目的操作数；每一个操作数都可以定位在寄存器或者存储器中，比如对于通用寄存器的指令系统而言要求每个操作数地址都必须显示的给出，所以一条指令所包含的地址数是不同的，因此指令可以根据包含的不同的操作数地址进行划分

**（1）三地址指令**

指令格式如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728174438872.png" alt="image-20240728174438872" style="zoom:67%;" />

其中，A1, A2称为源操作数地址，A3称为目的操作数地址，运算关系就是：`A3 <- A1 OP A2`，运算完成之后A1, A2对应的操作数不变

**（2）两地址指令**

两地址指令对应的是一元操作，对应格式如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728174712591.png" alt="image-20240728174712591" style="zoom:50%;" />

两地址指令格式其实就是在三地址指令的基础上将一个源操作数与目的操作数结合了，这就表示一个源操作数将会被一个目的操作数取代，指令字长缩小；两地址和三地址的指令都与基于通用寄存器指令系统相对应

**（3）一地址指令**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728175227394.png" alt="image-20240728175227394" style="zoom:67%;" />

在两地址的基础上，如果一个源操作数或者目的操作数约定为一个固定的位置，比如累加寄存器ACC中，这就是一地址指令，支持一地址指令的计算机称为累加器结构（上文有过介绍）一地址指令的长度进一步缩短

对于程序转移类的指令，上图中的A是下一条指令的地址

**（4）零地址指令**

零地址指令是省略了两地址指令的两个操作数的地址，将其全部变成隐含的，比如堆栈机结构的指令系统，默认两个操作数位于栈顶和次栈顶，并将结果放入到栈顶

当然零地址指令也包括空操作，还有子程序的返回和中断在形式上都是零地址指令，它们的操作数地址隐含在堆栈指针SP中（后文细嗦）



对于CISC指令中，多个地址以及以及指令长度都是混用的，这样可以增强指令的功能；但是在RISC指令中，除了专门的访问指令（load/store)是RS型的指令，其他的指令一律是RR型的，地址结构单一；对于地址个数的选取有两个标准：一是总程序的长度尽可能小，即所有指令所占的位数尽可能短；二是程序执行速度尽可能快，即执行过程中访问存储器的信息量总和尽可能小

我们举个例子对比一下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728181124711.png" alt="image-20240728181124711" style="zoom: 67%;" />

上图中的A, B, C, D, E, F分别表示不同的操作数所在的地址，可以理解为寄存器地址，也可以理解为存储器地址（按需要在上述不同指令系统中理解）

零地址的堆栈机不再赘述

一地址的累加器结构

```assembly
load E : 将E加载到累加器中
mul F ： 将累加器中的数据乘F并放入到累加器中
store G : 将累加器中的数据放入存储器G位置处
load D : 将D中的数据放入到累加器中
sub G : 即用累加器中的数据减去原来E * F的结构，得到D - E * F
...,后面不再赘述
```

对于二地址和三地址的汇编代码，因为是RS型，所以其中X， Y， Z只有一个是存储器地址，其他都是寄存器地址，这里不再赘述

### 2.4.2 指令字长

一条指令中包含的二进制码位数称为指令字长。指令字长取决于操作码的长度、地址码的长度和地址码的个数

#### 常见指令字长结构

**（1）等长指令字结构（一般是单子长）**

所有的指令字长均相等，并且有指令字长 = 机器字长 = 存储字长（计算机中一个字所占的位数）；这样指令的读取和分析的硬件结构简单

**（2）可变指令（变长指令字结构）**

一般包括半字长指令，单字长指令，双子长指令

控制这种指令的硬件电路比较复杂，并且多字长指令的话cpu需要读取多次才能取得一个完整的指令；一般CISC指令系统采用的就是变成指令字结构，而RISC指令系统采用的一般是固定字长（一般就是单字长指令了）；MIPS32采用的指令字结构就是单字长指令32位

#### 字长的选取

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728183430877.png" alt="image-20240728183430877" style="zoom:67%;" />

### 2.4.3 操作码扩展技术

指令格式中（也就是一串二进制位）需要安排一个唯一的操作码，这个操作码的位数选取的原则就是能够表示指令系统中的全部指令功能

操作码的长度可以是固定的也可以是变长的

定长的操作码指令系统中，所有指令的操作码位数相同，并且字段的位置也是固定的，这样指令的译码就会变得很简单，但是很多信息位被浪费了；RISC系统普遍采用的就是定长的操作码指令系统

变长的操作码指令系统中，各个指令的操作码的位数不一致，并且操作码分散在指令字的不同字段中；这种结构可以很好利用指令结构中的二进制位，压缩操作码的长度，IA-32采用的就是这种结构（好恶心啊，这傻逼中文教科书真的搁着分类列点呢）



