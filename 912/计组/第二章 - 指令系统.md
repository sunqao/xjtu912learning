# 2-指令系统

## 2.1 概述

**定义：**

指令系统是指一台计算机所具有的全部机器指令的集合，它反映了该机所拥有的基本功能，是软件和硬件的接口或者交界面；为了使指令系统中的每条指令都可以在计算机上执行， 计算机硬件相应地就具有执行这些指令的逻辑线路， 所以指令系统表征了计算机硬件的基本功能，是对计算机硬件功能的具体描述。

如果在计算机的一个基本操作是由硬件实现，那就应该在指令系统中设置一条专用的指令，如果这个操作是由软件实现，那么这个操作就是通过一条条指令组成的子程序来实现的。

**分类：**

从计算机系统的层次结构来说， 计算机的指令有宏指令、机器指令和微指令之分：

**宏指令**是由若干条机器指令组成的软件指令，它属于软件。

**微指令**是微程序级的命令，它属于硬件。

**机器指令**（通常简称为指令） 介于微指令与宏指令之间，每条指令可完成一个独立的操作，如一个算术运算或一次数据传送操作，机器指令就是一条二进制数，早起程序员就用一条打孔纸带上的机器指令来控制计算机

指令格式则是指令字用二进制代码表示的结构形式，由操作码字段和地址码字段组成。操作码字段表征指令的操作特性与功能；地址码字段通常指定参与操作的操作数的地址

## 2.2 指令系统的发展

**指令系统发展的三个特征：**

（1）软件硬化，用一条功能复杂的新指令来取代原先需要一串指令完成的功能，这是为了避免反复访存带来的时间损耗

（2）不断增加功能复杂的指令和复杂的寻址方式来支持高级语言的高效实现

（3）为了兼容系列机软件，指令系统不断扩大

**CISC（复杂指令系统计算机）的主要问题：**

（1）指令系统庞大，指令功能和寻址方式以及指令格失复杂，导致编译程序复杂，速度慢，难以通过编译优化生成高效的目标代码程序

（2）指令功能复杂，且每种指令都可访存，占用多个机器周期

（3）为了实现复杂的指令系统，采用了微程序控制技术，由微程序解释执行机器指令，这样又影响了指令的执行速度

（4）有80%左右的指令只有在20%的cpu时间才会被用到，即存在大量不经常使用的指令，这就导致cpu的研发制造周期非常长，难以调试以及可维护性差

**计算机执行程序所需的时间：**

![image-20240724173312945](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240724173312945.png)

RISC指令与CISC相比，由于其简化了指令复杂功能，因此一个程序的指令条数会比CISC多一些，但是由于RISC指令大多由一个机器周期实现，所以CPI比CISC低很多，并且由于RISC指令结构更加简单，所以完成一个同样的操作经过CPU内部数据通路更短，因此一个机器周期也比CISC指令对应的硬件结构小很多

**RISC（精简指令系统计算机）的特点：**

（1）指令长度固定，格失少，寻址方式少，指令各个字段划分一致，各个字段功能规整

（2）指令中只有取数/存数指令访存，其余指令都在寄存器之间进行

（3）控制单元直接以硬件布线为主，很少采用微程序控制

（4）优先选取了使用频率高的指令，避免复杂指令，采用编译优化技术，减少程序执行时间

（5）cpu中的通用寄存器数量很多，大多数的算数逻辑运算指令的操作数都在寄存器中存取

（6）cpu采用流水线结构，大部分指令都可以在一个机器周期中完成

mips32是RISC结构的经典代表，下文中都将以mips32作为RISC指令系统的范例进行介绍

## 2.3 指令系统的功能

### 2.3.1 指令系统的设计原则

**（1）完整性**

其要求通用计算机应该具备完善的指令功能，这时CISC指令系统的特点，许多指令的功能完全可以通过使用基本指令编写程序实现，因此完整性但不是RISC指令的特点

**（2）规整性**

规整性包括三个方面：

1. 对称性，指所有的运算部件都能够同等的访问所有的的寄存器和存储器单元，所有的指令都可以使用各种寻址方式
2. 匀齐性，指一种操作性质的指令可以支持各种数据类型，比如算术运算指令可以支持字节，字，双整形，以及十进制和单双精度浮点数的运算
3. 一致性，指指令格式和数据格式的一致性，也就是指令长度和数据长度应该有一定的关系而方便存取，比如指令长度和数据长度通常都是字节的整数倍

**（3）高效性**

通常CISC是通过复杂的指令完成指令工作减少程序中指令的条数来提供效率；而RISC更强调减少单条指令的执行时间来提高效率

**（4）兼容性**

指系列机种之间应该具备相同的基本结构和共同的指令系统，从而保证各个机种之间的软件应该可以通用；不过通常只能做到向后兼容和向上兼容

### 2.3.2 数据类型

数据类型，数据表示，操作数的定义如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240724180638135.png" alt="image-20240724180638135" style="zoom:50%;" />

操作数构成了指令的一部分，注意操作数和数据表示有些不一样，操作数单指指令的一部分，一般而言这一部分（指操作数类型）可以包括地址，数字，字符，逻辑数等等；但是数据表示是指硬件可以直接识别的数据类型，它可以作为操作数从而变成指令的一部分，也可以是存储器中存放的指令可以直接操作硬件可以识别的数据类型；操作数是指令中的概念，数据表示意义更广一些

在机器中一律使用二进制表示这些操作数，为了让硬件区分不同的操作数类型，通常使用操作码来区分指定不同的操作数

#### 操作数类型

下面我们主要介绍的就是操作数类型

**（1）地址**

地址就是指令或是操作数被存放在存储设备中的位置编码（注意指令也是放在存储器中存放的），主要的存储设备包括通用寄存器，主存和IO设备；地址是一种比较特殊的操作数，指令中可以直接给出地址，当然大多数情况是需要计算得到的，下文细嗦

**（2）数字**

数字型数据是计算机处理的最基本操作数类型。计算机中常用的数字类型有定点数和浮点数

**（3）字符**

文本或者字符串也是常见的数据类型

**（4）逻辑数**

不赘述

需要注意的是，MIPS32指令中存数或取数指令分别有字节，半字，和字的操作，并且对于字节或者半字的数据载入到32位寄存器时是载入到低位的，高位部分需要进行扩充，对于有符号数的扩充是用符号位扩充，对于无符号数的扩展需要用零扩展

#### 地址空间

下面介绍指令中的**地址空间**，地址空间也是由一串二进制的地址操作数形成的：

首先是计算机中的主要存储设备，主要包含三个，寄存器，主存储器，和IO设备，它们各自都包含多个可编址的数据单 元。对这些单可以 **统一编址** 或者 **单独编址**，从而形成了单地址空间或这多个地址空间

![image-20240727171055976](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240727171055976.png)

对于三个地址空间，也就是主存，寄存器和IO设备三者都独立编址，在RISC机器中，规定所有的运算，移位测试等操作只能在通用寄存器中进行，只有访问操作（读写）才可以在三种存储设备中进行；而对于CISC系统，所有的操作都可以在三种存储器中进行，这就导致指令非常复杂

对于两个地址空间，即对通用寄存器编址，以及对主存和IO设备编址；通常做法是将主存和IO设备的地址空间的高端划出给IO设备；将主存和io一起编址可以简化指令系统，因为不需要再另设指令分别取访问主存和IO，但是统一编址后需要译码器区分到底是访问主存还是IO设备，因此这样编址会影响指令执行的速度

对于一个地址空间，就是三个存储设备统一编址，一般指令空间的最低端划分给通用寄存器，最高端划分给io设备，中间部分给主存；这里的高端和低端的意思大概是地址空间的低地址部分，和高地址部分（毕竟访存的时候还是通过二进制数形成一个地址的）

对于无地址空间，也成为隐含编址，在堆栈计算机中，运算指令是不需要地址的

#### 编址方式

计算机硬件可以支持指令按照不同的长度访问存储设备中的数据，比如按照字，半字，字节，所以指令访问存储设备中的最小单位也可以是字或半字或字节，**我们将指令可以访问的最小数据位数构成一个编址单位**；而编址方式就是指主存单元的地址编排方式（其实也不一定是主存），其决定了主存的最小访问单元，即决定了一个编址单位是字还是字节还是半字，一般而言常用的编址单位有字和字节

**（1）按字编址**

这种编址方式就是一个编址单位是一个字，以8086为例，其字长位16位，并且数据总线也是16位，这样编址单位的二进制位数就与访问一次设备得到数据的二进制位数一样了

如果指令字长（就是指令的长度，取决于操作码长度，操作数地址和操作数地址的个数）和数据字长（计算机中存储一个数据所占用的位数，也就是数据单位的位数，数据字长的长短决定了计算机在一次操作中能够处理的数据量大小）和机器字长（cpu可以一次处理的位数，就是通用寄存器的位数）三者相等（早期计算机中就是三者相等）；那么每次取值之后PC（程序计数器）自动加一，每次取数据之后数据指针也是自动加一减一的（后面细嗦）

但是按字编址显然是不灵活的，数据的空间占有率不高，且特别是非数值领域

对于按字编址的主存大小，其容量为：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240727175236559.png" alt="image-20240727175236559" style="zoom:50%;" />

**（2）按字节编址**

为了适应非数值的数据，比如一个字符ASCII码就是一个字节的长度，一般而言信息的基本单位就是一个字节，所以现在的普遍编址方式就是按字节编址；但是一般计算机的字长（指通用寄存器的位数）都是字节的4倍以上，所以计算机中编址单位所含的信息量（一个字节）就与访问一次存储器所获得的信息是不同的，这就产生了字节在存储器中的存放问题

对于存储器按字节编址，那么存储器就既有字节地址也有字地址，字节地址是连续的（也就是最小存储单元）按0， 1， 2...这样递增下去；但是字地址不是连续的，比如一个32位机器其字的长度就是32位是字节的$2^2$倍，所以字的地址就是0, 4, 8, 16....

所以如果对于一个32位的地址编码，如果按照字节寻址那么寻址空间大小就是$2^{32} B = 4GB$，如果按照字来寻址，字长位32位，因此4个字节构成一个字长，字的个数就是字节的个数除以4，因此字的寻址空间大小就是$2^{32} / 4 (Word) = 1G(Word)$

按字节编址的存储器中有两个问题

**字节编址存放顺序问题**

对于多字节的数据存放在存储器中有两种存放顺序，一种是低字节放在低地址（小端存放），一种是低字节放在高地址（大端存放）；两种存放示意图如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240727181249797.png" alt="image-20240727181249797" style="zoom:50%;" />

**不同字长数据存放的边界问题**

对于程序中的不同数据其字长也是不一样的，这些数据在主存中混合存放其存放方式有两种，边界对齐和边界不对齐

所谓边界对齐，就是严格规定了字节，字，半字，双字存放的其实位置，比如假设机器字长为32位，规定半字长数据的存放起始位置必须是偶地址，单字长的数据存放起始地址必须是4的倍数，并且按照小端存放方式存放数据如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240727182517450.png" alt="image-20240727182517450" style="zoom:50%;" />

第二行的字数据显然不能再存放再第一行了，因为其存放的地址必须为4的倍数，因此这就会造成空间的浪费，如上图的阴影所示

所谓边界不对其，就是一个数据挨着一个数据存放将空间都占满，如下所示（还是小端存放方式）：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240727182704211.png" alt="image-20240727182704211" style="zoom:50%;" />

上图中的阴影是一个字数据，可以看到它的存放被拆成了两段

但是这就带来两个问题，一个是上图字数据跨越了两个字单元，因此如果是16位的数据总线访存的时候就必须得访问两次主存才可以将数据取出，同样一个字节，半字，都可能跨越两个字单元，这样就造成了访问速度下降了一半；另外一个问题就是存储器的读写控制很麻烦，因为这种存放的边界问题不规整，很难判断相邻的两位是否是真的属于一个完整的数值

对于MIPS处理器，其要求严格的边界对齐，以32位机器字长为例，要求半字数据必须放在偶字节地址上，字数据必须放在4倍字节地址上，双字数据必须放在8倍字节地址上

### 2.3.3 操作类型

所谓的操作类型就是把指令系统按功能进行分类，一般来讲指令系统包含五大指令：数据传送，数据运算，程序控制，输入输出，其他这五大指令

#### 数据传送指令

这类指令的功能就是在寄存器之间，寄存器和主存之间，以及主存之间传送数据

#### 数据运算指令

需要注意的是CISC指令支持支持源操作数和目的操作数在内存单元的运算类指令，但是RISC指令只有存数和取数可以访问内存，运算类指令的源操作数和目的操作数都在寄存器中（至于什么是源操作数什么是目的操作数，后文细嗦）

数据运算指令包括下面四类：

**（1）算数运算指令**

也就是算数运算，包括加减乘除等等

**（2）逻辑运算指令**

与或非操作

**（3）移位指令**

移位指令包括算数移位，逻辑移位，循环移位三种；

对于算数移位而言有算数左移（高位移除，低位补零）算数右移（低位移除，高位补符号位）

对于逻辑移位而言有逻辑左移（高位移除，低位补零）逻辑右移（低位移除，高位补零）

对于循环移位而言有循环左移（循环左移将二进制数的所有位向左移动一个或多个位置，移出的高位重新插入到低位）

```c
原数：  00101100
左移1位：00101100 -> 01011000
```

循环右移（循环右移将二进制数的所有位向右移动一个或多个位置，移出的低位重新插入到高位）：

```c
原数：  00101100
右移1位：00101100 -> 00010110
```

**（4）程序控制指令**

程序控制指令也被称为转移指令，其包括无条件转移，条件转移，调用与返回，陷阱和陷阱指令

对于无条件转移就是直接将程序转移到一条需要执行的指令

对于条件转移就是条件满足，就转移，一般机器都可以提供条件码作为某些指令的执行结果，比如零标志，如果结果为零就将这个位置为零等

对于调用与返回指令，也就是CALL和RETURN指令，CALL表示转移到子程序的入口来执行子程序，RETURN表示返回调用的位置即源程序的调用子程序的断点位置，CALL和RETURN指令都是成对出现的；此外需要注意的是为了能够正确返回到源程序，在调用子程序的时候需要记住返回到源程序的地址以便子程序执行结束的时候可以正确返回；一般在调用子程序的时候返回地址可以存放在寄存器中，但是这种方式难以实现子程序嵌套（即子程序调用子程序，因为寄存器的数量是有限的，一般只能记住源程序的地址）；或者放在子程序的开始地址单元处，然后从第二个单元开始执行子程序，这种方式可以实现子程序的嵌套，但是不能实现递归子程序；最好的方法是存放在堆栈中，当调用结束的时候就从堆栈弹出返回地址

对于陷阱和陷阱指令，所谓陷阱就是程序在执行过程中发生了意外事故导致程序不能正常运行，比如电压不稳定或执行了除以零的操作，此时计算机就发出陷阱信号，转入处理程序进行相应的故障处理；一般而言陷阱指令不是直接提供给用户使用的，但是IA-32的软中断指令是提供给用户使用的陷阱指令

**（5）输入输出指令**

对于输入输出单独编址的计算机而言设有输入输出指令，这个指令完成从IO接口中的寄存器读入一个数据到cpu中的寄存器，或者从cpu中的寄存器写入到io接口寄存器中

**（6）其他**

不再赘述

## 2.4 指令格式

指令格式就是指令的二进制表示形式

### 2.4.1 指令的组成

指令格式就是二进制代码表示的指令结构形式，其包括操作码和地址码两个部分，如下所示：

![image-20240728161439978](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728161439978.png)

操作码指出了指令完成的功能，地址码指出操作数的地址，也就是操作对象所处的位置，或者下一条指令在主存中的位置

#### 操作码

指令的操作码需要给出两部分信息

（1）指令的操作类型，比如加减乘除移位，存储读取等等

（2）所需操作数的类型，计算机中存放的数据就是单纯的一堆二进制的数，如果解读这一串二进制数就需要指令的操作码给出解释字段

#### 地址码

指令中涉及的地址包括寄存器地址，主存地址，和IO设备地址；

#### 指令的分类（CPU的结构）

指令中的地址码的形式实际上取决于cpu结构，一般而言cpu分为堆栈型，累加器型和通用寄存器三种cpu结构，相应的指令结构也分为三种：堆栈型，累加器型和通用寄存器型；对于不同结构的指令系统，其操作数的位置，个数，以及给出方式（显式给出，即操作数直接在指令中或者明确给出了操作数的地址，隐式给出即操作数放在某个位置处，这个位置是固定的，不需要给出地址，比如push ax, 自动将ax内容放入到堆栈顶的位置处，或者total += 5，默认有一个操作数就是在total的位置）；下面来分别介绍这几种cpu结构：

**首先是堆栈型的cpu结构：**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728164114467.png" alt="image-20240728164114467"  />

上图中的灰色是源操作数，TOS即栈顶，堆栈寄存器中的两个源操作数都是隐式给出的，即约定存放在栈顶和次栈顶，当结果得出之后再将结果放入到栈顶，上图中原来是有两个灰色块的，黑色块是运算结果，放在栈顶，此时TOS应该指向黑色块才对；在这种cpu结构中，只能通过push/pop操作访问存储器

**然后是累加器型cpu结构：**

![image-20240728164736574](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728164736574.png)

其中累加器AC是隐式的，这个存储单元既作为源操作数又作为运算结果，也就是累加，在这个单元上不断加上一个存储器中的另一个操作数

**然后是通用寄存器结构（RS，指寄存器存储器类型）：**

![image-20240728165628001](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728165628001.png)

在通用寄存器结构中所有的操作数都显示给出，对于RS型的结构，也就是指一个源操作数存放在通用寄存器中，另一个来自存储单元中，然后运算结果放入到通用寄存器中

**最后是RR型的通用寄存器结果（指寄存器寄存器类型）：**

![image-20240728165731454](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728165731454.png)

在RR型的cpu结构中，两个源操作数，运算结果全部放在通用寄存器中；对于通用寄存器结构的cpu，所有的操作数都是显示给出的

通过上述分析，很显然对于堆栈型和累加器型的计算机，其指令的长度比较短，程序占用空间小，但是堆栈类型的计算机不能随机访问堆栈（固定在栈顶和次栈顶）；累加器型还有一个累加器作为中间单元，因此程序需要频繁访问存储器，降低了程序的执行效率；所以目前大多数计算机都采用的是通用寄存器型的结构

对于通用寄存器的指令系统，ALU可以最多三个操作数，包括两个源操作数和一个结果操作数，因此通用寄存器的指令系统中存储器操作数可以为0个，1个，或者2个3个；**这样我们可以根据存储器操作数的个数对通用寄存器的指令系统进行进一步的划**分：RR(寄存器寄存器型，没有存储器操作数)，RS（有一个存储器操作数），SS（全部都是存储器操作数）

一般而言，指令的格式和长度越单一（比如RR型的指令系统，操作数只考虑几个寄存器即可），编译器需要做的优化工作就越简单，但是目标代码长度就很长，而指令的格式和长度越丰富，目标代码的长度就越短（因为可以用一条指令完成一段简单指令程序的功能），但是这种多样性会增加编译器和cpu硬件的实现难度；目前SS型的指令系统已经弃用，上述三种指令系统的优缺点如下所示：

| 指令系统类型             | 优点                                                         | 缺点                                                         |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| RR（寄存器，寄存器类型） | 字长固定，结构简单，各个指令执行时钟周期数相近               | 指令条数多，目标代码复杂，占用空间大                         |
| RS（寄存器，存储器类型） | 不需要load指令加载到寄存器中，可直接对存储器中数据引用，目标代码紧凑 | 指令中的操作数不对称，对存储器中的操作数编码会影响可使用的寄存器个数（存储器很大，可能占用寄存器对应的二进制位）；不同指令的时钟周期差异很大 |
| SS（存储器，存储器类型） | 目标代码最紧凑，不需要寄存器保存变量了                       | 由于存储器很大，所以指令的字长变化很大，并且频繁访问存储器很影响效率，现在已经弃用 |

#### 指令的分类（地址的个数）

如上文所述，对于一个指令系统而言最多包含三个操作数，一元操作包含一个源操作数和一个目的操作数，二元操作涉及三个操作数，两个源操作数和一个目的操作数；每一个操作数都可以定位在寄存器或者存储器中，比如对于通用寄存器的指令系统而言要求每个操作数地址都必须显示的给出，所以一条指令所包含的地址数是不同的，因此指令可以根据包含的不同的操作数地址进行划分

**（1）三地址指令**

指令格式如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728174438872.png" alt="image-20240728174438872" style="zoom:67%;" />

其中，A1, A2称为源操作数地址，A3称为目的操作数地址，运算关系就是：`A3 <- A1 OP A2`，运算完成之后A1, A2对应的操作数不变

**（2）两地址指令**

两地址指令对应的是一元操作，对应格式如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728174712591.png" alt="image-20240728174712591" style="zoom:50%;" />

两地址指令格式其实就是在三地址指令的基础上将一个源操作数与目的操作数结合了，这就表示一个源操作数将会被一个目的操作数取代，指令字长缩小；两地址和三地址的指令都与基于通用寄存器指令系统相对应

**（3）一地址指令**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728175227394.png" alt="image-20240728175227394" style="zoom:67%;" />

在两地址的基础上，如果一个源操作数或者目的操作数约定为一个固定的位置，比如累加寄存器ACC中，这就是一地址指令，支持一地址指令的计算机称为累加器结构（上文有过介绍）一地址指令的长度进一步缩短

对于程序转移类的指令，上图中的A是下一条指令的地址

**（4）零地址指令**

零地址指令是省略了两地址指令的两个操作数的地址，将其全部变成隐含的，比如堆栈机结构的指令系统，默认两个操作数位于栈顶和次栈顶，并将结果放入到栈顶

当然零地址指令也包括空操作，还有子程序的返回和中断在形式上都是零地址指令，它们的操作数地址隐含在堆栈指针SP中（后文细嗦）



对于CISC指令中，多个地址以及以及指令长度都是混用的，这样可以增强指令的功能；但是在RISC指令中，除了专门的访问指令（load/store)是RS型的指令，其他的指令一律是RR型的，地址结构单一；对于地址个数的选取有两个标准：一是总程序的长度尽可能小，即所有指令所占的位数尽可能短；二是程序执行速度尽可能快，即执行过程中访问存储器的信息量总和尽可能小

我们举个例子对比一下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728181124711.png" alt="image-20240728181124711" style="zoom: 67%;" />

上图中的A, B, C, D, E, F分别表示不同的操作数所在的地址，可以理解为寄存器地址，也可以理解为存储器地址（按需要在上述不同指令系统中理解）

零地址的堆栈机不再赘述

一地址的累加器结构

```assembly
load E : 将E加载到累加器中
mul F ： 将累加器中的数据乘F并放入到累加器中
store G : 将累加器中的数据放入存储器G位置处
load D : 将D中的数据放入到累加器中
sub G : 即用累加器中的数据减去原来E * F的结构，得到D - E * F
...,后面不再赘述
```

对于二地址和三地址的汇编代码，因为是RS型，所以其中X， Y， Z只有一个是存储器地址，其他都是寄存器地址，这里不再赘述

### 2.4.2 指令字长

一条指令中包含的二进制码位数称为指令字长。指令字长取决于操作码的长度、地址码的长度和地址码的个数

#### 常见指令字长结构

**（1）等长指令字结构（一般是单子长）**

所有的指令字长均相等，并且有指令字长 = 机器字长 = 存储字长（计算机中一个字所占的位数）；这样指令的读取和分析的硬件结构简单

**（2）可变指令（变长指令字结构）**

一般包括半字长指令，单字长指令，双子长指令

控制这种指令的硬件电路比较复杂，并且多字长指令的话cpu需要读取多次才能取得一个完整的指令；一般CISC指令系统采用的就是变成指令字结构，而RISC指令系统采用的一般是固定字长（一般就是单字长指令了）；MIPS32采用的指令字结构就是单字长指令32位

#### 字长的选取

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240728183430877.png" alt="image-20240728183430877" style="zoom:67%;" />

### 2.4.3 操作码扩展技术

指令格式中（也就是一串二进制位）需要安排一个唯一的操作码，这个操作码的位数选取的原则就是能够表示指令系统中的全部指令功能

操作码的长度可以是固定的也可以是变长的

定长的操作码指令系统中，所有指令的操作码位数相同，并且字段的位置也是固定的，这样指令的译码就会变得很简单，但是很多信息位被浪费了；RISC系统普遍采用的就是定长的操作码指令系统

变长的操作码指令系统中，各个指令的操作码的位数不一致，并且操作码分散在指令字的不同字段中；这种结构可以很好利用指令结构中的二进制位，压缩操作码的长度，IA-32采用的就是这种结构（好恶心啊，这傻逼中文教科书真的搁着分类列点呢）

当采用等长指令字格式的时候，可以将空闲的地址码当作操作码来使用从而增加操作码的位数，这就是操作码的扩展技术

一般而言操作码的扩展分为两种，一种是等长操作码扩展，一种是不等长操作码扩展，**这里着重介绍等长操作码扩展**

所谓等长操作码扩展，就是每次给操作码增加的位数是一样的，比如4-8-16扩展法，意思就是操作码的长度分别是4位，8位，16位，每次增加等长的4位；当然还有3-6-9扩展法了

当使用等长操作码扩展的时候，根据不同的扩展标致还可以有不同的扩展方法，所谓扩展标志的意思就是不同位数的扩展码比如4位扩展码和8位扩展需要一个标志进行区分，这就是扩展标志；以4-8-16扩展法为例，它可以有一个码点标志位的15/15/15扩展法和一个标志位的8/64/512扩展法

对于一个码点标志位的15/15/15扩展法，其扩展示意图如下所示，以16位的指令字长为例，注意操作码的位数才决定了指令功能从而决定了指令的条数，地址码只是用来取数据的，同一条指令可以对应不同的数据进行运算：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240729181446530.png" alt="image-20240729181446530" style="zoom:67%;" />

对于一个码点标志位的15/15/15扩展法，所谓的一个码点标志位，如上图所示对于三地址指令，其操作码的取值范围是0000 ~ 1110，没有1111，说明如果前4位如果是1111就不是三地址指令了，而变成了8位操作码的而地址指令，这里的前四位的1111就作为一个码点标志位表明不再是三地址指令了；同理，从前8位的1111 1111开始就不再是二地址指令而变成了一地址指令；因此各个指令的条数也就很容易解释了，这里不再赘述

对于一个标志位的8/64/512扩展法，其扩展示意图如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240729181427279.png" alt="image-20240729181427279" style="zoom:67%;" />

所谓一个标志位指的是用一个位来区分操作码的位数（也就是几地址指令），上图中，第一位为零九表示是三地址指令，那么这里的第一位就是一个标志位；同理，第一位为一，第五位为零就表示的是二地址指令，那么显然而地址指令的个数就是8 * 8 = 64条了；依次类推，将每次增加4位的第一位作为一个标志位，因此零地址指令的条数就是8 * 8 * 8 * 16 = 8192条了

我们来看一个例子理解一下：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240729182051754.png" alt="image-20240729182051754" style="zoom:67%;" />

这个例子中，先是二地址指令，地址码有12位因此操作码就有4位，二地址条数有15条，而操作码4位最多16条，因此而地址的操作码的范围应该是0000 ~ 1110；这里用前四位1111表示不再是二地址指令了

对于一地址指令，地址码有6位，因此操作码有10位，而前四位必须是1111，所以可变动的操作码部分就只有6位，最多有64种编码，但是一地址指令只用了34位，所以我们从小到大对齐进行编排

1111(000000) ~ 1111(011111)，这是32条编码方式，一个32条；然后再增加两条1111(100000)和1111(100001)，形成了34条指令

对于零地址指令，操作码一共16位，但是根据上文，显然前五位一定是11111（因为1110已经被二地址占用），而中间五位有两条00000和00001也被二地址占用，所以中间五位必须从00010到11111，至于后面六位就随便了，因此零地址的范围就是：

11111(00010 ~ 11111)(000000~111111)一共30*2^6条

**所以指令编码需要考虑的有：**

**（1）分配的操作码从小到大来编排指令**

**（2）需要有标志位或标志码进行区分，上例中前四位1111表示不再是三地址指令，11111 00000与11111 00001表示前五位为11111仍然是一地址指令，其他的前五位11111都是零地址指令，标志码可以不止一个**

**（4）计算指令的条数，需要考虑编码，不能简单将所有二进制的排列组合减去题中给的其他指令条数**

我们再看一个例子：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240729183902165.png" alt="image-20240729183902165" style="zoom: 67%;" />

（1）这是定长的操作码字段，直接就是$2^8 - m - n$

（2）有扩展的情况下就得考虑标志码了，对于二地址的情况，其操作码的位数为8位，可以有2^8条指令，由于有m条二地址指令，所以前四位就剩下了$2^8 - m$个用来表示不是二地址指令来作为标志码；对于一地址而言有16位的操作码，前四位有m条被二地址使用，所以一地址最多形成的指令有$(2^8 - m) * 2^8$条，当然前16位操作码不一定全形成一地址指令，还可能有一些是零地址值的标识码，比如上面的例子，11111 00010 到11111 11111就是是零地址的标志码；我们这里假设这16位有k个类型组成了零地址指令，那么对于零地址指令有$k * 2^8 = n$，所以k就是n除以$2^8$取整，所以前16位作为一地址指令就是$(2^8 - m) * 2^8 -  \left \lceil  n/2^8 \right \rceil$个了

（3）二地址指令达到最大，那么8位操作码只留下一个作为一地址的标志码，所以二地址最大就是$2^8 - 1$个；而一地址有16位操作码，前8位只能是11111111，后八位有得留出一个作为零地址的标志码，所以一地址也最多有$(1 * (2^8 - 1) )$个；对于零地址，其前16位只被留下了11111111 11111111作为标志码，其后八位不用留下标志码了，所以零地址的个数就是$2^8$个

### 2.4.4 指令格式举例

#### IA 32 指令格式

IA32是标准的CISC指令体系，其指令的长度可变，并且还可以带有一些前缀，如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240729191158614.png" alt="image-20240729191158614" style="zoom:67%;" />

上图中的前缀是指令的可选项，它们的作用是对后面的指令本身做一个显示的约定，四个前缀各占一个字节8位

**指令前缀：**包括锁定前缀和重复前缀，锁定前缀是为了解决资源冲突问题，即对存储器的排他性访问；重复前缀是为了用于字符串中的重复操作，依次加快字符串处理速度

**段取代前缀：**一般而言一条指令使用的段寄存器可以不必出现在指令格式中，可以默认，当我们不想默认的时候就得使用段取代寄存器明确指明这条指令使用哪一个段寄存器

**操作数长度取代前缀和地址长度取代前缀：**在实地址模式下，操作数和地址默认长度都是16位，在保护地址模式操作数和地址也有默认地址，所谓实模式和保护模式的区别就是保护设置，实质上就是屏蔽一些地址的访问防止程序间胡乱访问地址带来的问题，当一条指令不想使用默认长度的时候通过这两个前缀来指定

下面是指令本身

**OP_Code**不再多说

**Mod ~ R/M字段**规定了存储器的寻址方式，给出了寄存器操作数的寄存器地址号

**SIB字段**与Mod ~ R/M字段一起对操作数的来源做出一个完整明确的说明

其他的不再赘述

#### MIPS 32 指令格式

MIPS 32的指令字长固定，操作码长度固定，并且没有专门的寻址方式字段而是由指令格式本身来决定寻址方式，MIPS32指令有如下几类

**R-型指令：**

也就是RR（寄存器寄存器类型）的指令，其结构如下所示：

![image-20240729192706405](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240729192706405.png)

其操作码是固定的000000六位，操作类型由Func字段指定，Rs, Rt分别是两个源操作数，其结果送到Rd中，如果是移位指令的话就对Rt中的内容进行移位，位移量由Shamt指定，这种类型的寻址方式只有一种，就是寄存器寻址

**I-型指令：**

这个指令就是立即数指令，具体操作由OP_Code指定，结构如下所示：

![image-20240729193054743](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240729193054743.png)

如果是双操作数类型的指令，Rs内容和立即数作为第一第二源操作数，结果放入Rt中

如果是load/store指令，则将Rs中的内容和立即数扩展后的内容相加作为存储单元的地址，load指令将存储单元数据放入Rt中，store指令将Rt中的数据放入存储单元

如果是条件分支指令，则对Rt和Rs内容进行指定运算，根据运算结果决定是否转移到目标地址，目标地址的得出是将PC中的内容与立即数扩展之后的内容相加得到

I-型指令的寻址方式有寄存器寻址，立即数寻址，相对寻址，基址或变址寻址（后文细嗦寻址方式）

**J-型指令：**

这个指令就是无条件跳转指令，指令中给出的是26位的直接地址，将当前PC的高4位拼接上26位直接地址，然后加上两个零就得到了跳转的目标地址：

![image-20240729193746458](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240729193746458.png)

## 2.5 寻址方式

所谓寻址方式，就是计算源操作数，目的操作数以及下一条指令在数据存储设备中的位置的方式，数据存储设备主要包括寄存器，主存储器，IO设备；下文中主要介绍寄存器和主存储器，并且寄存器和主存储器分别具有独立的编址空间；并且由于寄存器本来个数就很少，所以存储器的地址空间远远大于寄存器的地址空间，即主存的编址位数远大于寄存器的编址位数；并且主存储器中可以存放数据也可以存放指令，数据或指令所在的存储单元的编号就是其在主存中的地址

**形式地址**（符号地址），指令中显式给出的地址

**有效地址**，其是由形式地址根据某种变换规则得到，怎么变换取决于寻址方式；有效地址是由寻址方式和形式地址共同决定的；**通过形式地址求有效地址的方法就是寻址方式**，有效地址可能直接是物理地址（不采用虚拟内存机制）；也可能不是物理地址而是虚拟地址（采用虚拟内存机制）；有的地方将逻辑地址中的偏移地址也称为有效地址，这里别纠结，一般在开发中，**统一将计算得到的地址就称为有效地址**

**物理地址**，物理存储器按照8位字节序列加以编址，每个字节都有唯一的地址与之对应，也就是存储单元的**实际地址**，物理地址空间就是物理地址的大小，也就是指所有能被cpu直接寻址访问的存储器。包括内存条、显存和一些ROM；物理地址空间的大小受限于总线条数，m条地址线所对应的物理地址空间的范围为`0 ~ 2^m - 1`

**虚拟地址**：

首先是**虚拟存储器（虚拟内存）**，这不是任何实际的物理存储器，而是借助磁盘等辅助存储器来扩大主存容量，使之为更大或更多的程序所使用，**虚拟地址**就是虚拟存储器的地址，而**逻辑地址**就是虚拟地址的形式表示方式，一般以**段地址：偏移地址**的形式给出，当然程序指令中使用的地址（程序员使用的）也可称为逻辑地址，因为段地址通常由系统指定；逻辑地址与虚拟地址通常是一个东西

寻址方式有两类，指令寻址方式和数据寻址方式，寻址方式就是根据形式地址得到有效地址的过程，如果没有虚拟内存机制那么得到的有效地址就是实际的物理地址，否则就是虚拟地址，至于虚拟地址再转换成物理地址，那就是MMU（一个硬件单元，称为内存管理单元）要做的事情；下文默认计算得到的有效地址就是物理地址（对理解寻址方式不影响）

### 2.5.1 指令寻址

指令寻址就是确定下一条将要执行的指令所在主存单元地址的方法；指令的执行分为顺序和跳跃两种，因此指令的寻址方式也分为顺序和跳跃两种

#### 顺序寻址

顺序寻址不需要在指令中显示给出下一条指令地址信息，而是通过程序计数器PC + 1自动形成下一条指令的地址，注意这里的+ 1并不是指的是加一个地址单元，而是加n，n取决于指令字长，如果指令字长是单个字，那就是加单字长，如果指令字长是双字，那就加两个字长即加2

PC的初始值通常由操作系统的加载程序设定，设定位第一条指令在主存单元中的地址

#### 跳跃寻址

跳跃寻址由转移类指令直接显示给出下一条指令的信息，转移类指令可以采用类似数据寻址的多种方式

### 2.5.2 数据寻址

数据寻址可以分为两类，基本寻址方式和符合寻址方式，下面介绍的前四种为基本寻址方式，最后一种寻址方式为复合寻址方式

#### **（1）立即寻址**

所谓立即寻址就是操作数直接在指令的地址码字段中给出，形式地址不是操作数的地址而是操作数本身，又称为立即数，立即数以补码的形式放在操作数的位置处

这种寻址方式只能用于源操作数，通常用在给寄存器赋初值，或者作为立即数作为常数参与运算；比如IA32中的指令mov eax, 100；或者MIPS32中的I指令，`addi $s1, $s2, 100`（立即数100提供一个源操作数）如下是一个立即寻址的一地址格式，#表示这个操作数采用的是立即寻址，是寻址方式的标志：

![image-20240731161718081](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240731161718081.png)

#### **（2）寄存器寻址**

这种寻址方式对于源操作数和目的操作数都适用，一般用在源操作数在通用寄存器中或者运算结果需要存到通用寄存器中；这时操作数的地址码字段给出的是寄存器的编号，如下所示，其中Ri是寄存器的编号，Ri前面的符号表示寄存器寻址的特征，#表示的是立即寻址的特征，I是一个立即数（补码形式）：

![image-20240731161907651](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240731161907651.png)

IA32指令中的`mov eax, 100`以及MIPS32中的`add $s1, $s2, $s3`就是这种寻址方式，寄存器寻址无需访问主存（主存其实就是内存条+ cache)，所以执行时间短，并且由于寄存器数量比较少，所以地址编号就比较短，节省了指令的存储空间，这种寻址方式在CISC和RISC中广泛应用

#### **（3）存储器寻址**

顾名思义，其实就是需要根存储器打交道的寻址方式，其包括直接寻址，存储器间接寻址，寄存器间接寻址，偏移寻址和段寻址；这些寻址方式对于指令的跳跃寻址也是适用的

**i 直接寻址**

直接寻址就是指令的地址码字段的形式地址直接就是数据或是一条指令的有效地址（在存储器中的地址），其寻址速度快，但是寻址范围比较小，指令格式如下所示，地址A之前的符号就是直接寻址的标志，并且形式地址A就是有效地址EA：

![image-20240731165902432](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240731165902432.png)

在MIPS32中跳转指令`j 200`就是直接寻址的方式，这个机器指令有32位，其中6位操作码，26位地址码，200就是指令的地址，由于MIPS32中的指令以4字节对齐，因此所有的指令地址的最后两位一定是00，所以这里的26位地址码其实可以看作指令地址的前26位，默认最低两位是00，从而表示28位的指令地址

直接寻址寻址速度快，因为只访问了一次内存，但是地址直接就在指令中从而限制了地址空间的大小，因此寻址范围就比较小

**ii 间接寻址（存储器间接寻址）**

间接寻址的地址码给出的不是操作数也不是操作数的地址，而是操作数地址的地址，因此就需要多次访问内存才可以得到实际的操作数，间接寻址可以只进行一次间接，也可以进行多次间接

大多数的计算机采用的是一次间接寻址，通过指令中的地址码去访问内存，内存中的内容就是操作数的地址，这里我们用(A)表示地址A中的内容，(Ri)表示寄存器Ri中的内容，一次间接寻址的示意图如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240731171241999.png" alt="image-20240731171241999" style="zoom: 67%;" />

A上方两个点这个符号就是间接寻址的标识；当采用多级间接寻址时，第一次间接寻址的标志由指令给出，而后面内存中的数据是有效地址或仍是间接地址，是由这个内存单元中的内容给出，比如，如果我们从内存中取出的数据的间接寻址标志位（通常为最高位）为1，说明我们需要将标志位去除后的数据作为地址码继续访问内存，一直到取出的数据的标志位为0，表示这个数据剔除掉标志位0之后就是实际的有效地址，此时根据这个有效地址再访问一次内存取出的数据就是实际的操作数，比如两次间接寻址的有效地址就是EA = ((A))，A是指令中给出的形式地址

假设存储器存储字长（也就是存储器中一个字的长度）是m，通常等于机器字长，如果使用的是一次间接寻址，那么第一次访问存储器的时候得到的有效地址就是m位，因此一次寻址空间大小就是$2^m$；如果是多次间接寻址，那么最后得到的一个数据必须剔除掉一位标志位才能作为有效地址，所以寻址空间大小就是$2^{m - 1}$；注意这里的寻址空间大小与指令中的形式地址A无关，因为不管A怎么取，得到的有效地址就是那m位，这m位所对应的存储单元地址就是固定的，不管A怎么取，实际的操作数只能对应在0 ~ $2^{m - 1}$这些存储单元中，操作数所处的地址空间没有发生变化

间接寻址可扩大寻址范围，但是因为多次访存，所以指令执行速度慢；并且MIPS指令系统由于流水线的结构限制，不支持间接寻址的方式

**iii 寄存器间接寻址**

寄存器间接寻址与存储器间接寻址的区别在于指令中的形式地址给出的是寄存器的编号，而有效地址则放在寄存器中，即EA = (Ri)，下图是寄存器间接寻址的示意图，指令中Ri左侧的R上方一个帽子的符号表示的是寄存器间接寻址的标志：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240731174153705.png" alt="image-20240731174153705" style="zoom:67%;" />

寄存器间接寻址所需的地址码相比于间接寻址的地址码更短，并且寻址空间大小取决于寄存器的长度，也就是机器字长

同样MIPS系统由于流水线结构限制不支持寄存器间接寻址

**iv 偏移寻址**

偏移寻址是直接寻址与寄存器间接寻址的结合，在指令中得给出一个偏移地址A（A是有符号整数，通常用补码表示），以及一个寄存器的编号Ri，偏移地址和Ri中存放的地址加起来构成了实际有效地址：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240731175407485.png" alt="image-20240731175407485" style="zoom:67%;" />

常见的偏移寻址有如下几种：

- **相对寻址**

相对寻址使用专门的程序计数器PC，即有效地址EA = (PC)  + A，指令中只需要给出偏移地址A即可，所以地址码部分可以很短，其寻址范围取决于A的范围，假设A是k位，其作为补码的范围为$-2^{k - 1} 到 2^{k-1} - 1$之间，因此相对寻址的寻址空间大小就是$(PC) - 2^{k - 1} 到 (PC) + 2^{k - 1} - 1$

相对寻址可用于操作数寻址也可用于指令寻址，并且只要操作数或指令与当前指令的相对位置不变，那么不论程序在主存中的哪里都可以正确执行，一般PC始终指向当前指令的下一条指令的地址，所以只要操作数或者指令与当前指令的相对位置不变（与自己的绝对位置无关），那么无论当前指令在内存中的哪里都可以取到正确的操作数和下一条应该执行的指令，程序可以正确运行，而操作数以及这条指令的绝对位置可以随当前指令程序变动，因此相对寻址可以编写与位置无关的程序

- **变址寻址**

变址寻址需要一个编址寄存器Rx，这个寄存器可以是一个通用寄存器，也可以是一个专用的寄存器；变址寻址通常用在数据和字符串的处理中

它的原理是指令中给出一个基本地址A，也就是数组或字符串的起始地址，通常为无符号整数，当然也是以补码形式放在指令中，然后编址寄存器中存放地址的修改量；操作数在数组中的变化由编址寄存器的修改来完成，并且这是由硬件自动完成的；也就是某个操作数编址寻址得到之后编址寄存器自动加上或减去一个量，即Rx = (Rx) + Delta

如果是一个专用的编址寄存器，那么寄存器不需要在指令中给出，EA = (Ex) + A，如果是通用寄存器，则需要在指令中给出寄存器的编号Ri, EA = (Ri) + A

- **基址寻址**

基址寻址需要一个基址寄存器Rb，这个寄存器可以是一个通用寄存器，也可以是一个专用的寄存器，指令中的形式地址给出偏移地址A，有效地址为EA = (Rb) + A；基址寻址用于实现操作系统对用户程序的动态定位

基址寄存器中存放的是基本地址值（基地址），这是由系统设定的且用户不能更改；程序中指令或数据的改变由不同的偏移量A（一个带符号整数，以补码形式存放在指令中，可以有正偏移和负偏移）来完成

基址寻址和变址寻址的硬件实现完全相同，但是两者在程序中的作用是不同的，变址寻址用于数组和字符串的处理运算，而基址寻址则用于将逻辑地址（这里的逻辑地址特指偏移量，也就是程序中使用的地址）转变为物理地址，实现程序的动态定位

> 当操作系统将一个程序加载到内存中时，它通常不会将程序加载到固定的地址，而是将程序加载到一个可用的内存区域。操作系统会确定程序的基地址（加载基址），然后利用程序中给出的偏移地址A（特指逻辑地址）来确定操作数的有效地址，进而得到物理地址

MIPS 32中的load/store指令采用的就是类似的基址寻址的方式，指令中指定一个基址寄存器（32位）和一个16位的偏移量，然后对16位的偏移量进行符号扩展，然后与基址寄存器中的内容相加得到有效地址，如指令`lw $s1, 100($s2)`，就特指s2是基址寄存器，100就是程序中使用的偏移地址，这里也就是逻辑地址，计算得到的就是有效地址

**v 段寻址**

段寻址其实是基址寻址的一种特例，其用于地址长度超过机器字长的场合，也就是存储器很大，大到机器字长也无法表示存储单元的地址了；此时系统将主存空间分段，对于一个指令或者操作数，需要指出所在的段以及段内的偏移量；其中段地址以及段内偏移是与机器字长相等的，两者错位相加从而得到更大的存储器地址

段地址存放在段寄存器Rs中，并且段寻址相对于其他的寻址过程其实是一个附加的过程，即我们先通过其他寻址方式得到一个暂时的有效地址EA，然后将EA作为段的偏移地址再加上段地址得到真实的物理地址；所以网上很多内容说的有效地址就是偏移地址其实是针对段寻址而言的，广义上的有效地址就是计算得到的地址；并且段寻址最后将段地址和偏移地址相加得到的地址就是真实的存储器单元的物理地址：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240731193212787.png" alt="image-20240731193212787" style="zoom:80%;" />

#### **（4）堆栈寻址**

堆栈是一种存储设备，栈顶是数据的唯一出入口，栈顶指针（SP）始终指向栈顶，栈顶浮动变化，而栈底始终不变；堆栈的设置有两种：

一种是栈顶设置在区域的低地址端，栈底在高地址端，栈顶向下生长，数据入栈栈顶地址减小（存储器的编址画图，从下到上地址增加）

一种是栈顶设置在区域的高地址端，栈底在低地址端，栈顶向上生长，数据入栈栈顶地址增加（存储器的编址画图，从下到上地址增加）

存储器堆栈有两种实现方式：

**（1）SP指向栈顶的一个空单元**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240731194558402.png" alt="image-20240731194558402" style="zoom:67%;" />

如果是向上生长的栈（上图所示）

数据入栈(PUSH)操作：

1. (SP) <- 数据，箭头左侧有一个括号默认省略，这里的箭头表示放到了左侧作为地址对应的单元中，这里的意思是将数据放入到[(SP)]这个地址对应的存储单元中
2. SP <- (SP) + 1，SP中的地址加一，向上涨一个单元，然后放入到SP中

数据出栈(POP)操作：

1. SP <- (SP) - 1
2. [(SP)]出栈

如果是向下生长的栈

数据入栈(PUSH)操作：

1. (SP) <- 数据
2. SP <- (SP) - 1

数据出栈操作：

1. SP <- (SP) + 1
2. [(SP)]出栈

**（2）SP指向栈顶，栈顶非空**

![image-20240731212647712](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240731212647712.png)

如果是向上生长的栈（上图所示）

数据入栈(PUSH)操作：

1. SP <- (SP) + 1
2. (SP) <- 数据

数据出栈(POP)操作：

1. [(SP)]出栈
2. SP <- (SP) - 1

如果是向下生长的栈

数据入栈(PUSH)操作：

1. SP <- (SP) - 1
2. (SP) <- 数据

数据出栈操作：

1. [(SP)]出栈
2. SP <- (SP) + 1



注意上述中的+1 -1的意思也是加一个或建一个操作数的长度，不一定是一个存储单元地址

**堆栈寻址实例：**

对于Pentium 4中有专门的堆栈指针寄存器ESP(SP)，栈中的每个元素可以是16位或是32位，其指令系统中有专门的入栈指令push和出栈指令pop；push或pop操作后ESP变化的长度自动根据入栈或出栈的操作数的长度进行调整；其堆栈向下生长，栈顶指针指向栈顶空的存储单元，每入栈一个32位操作数就有ESP <- (ESP) - 4，每出栈一个32位操作数就有ESP <- (ESP) + 4

同样，在Pentimu中还支持特殊的堆栈指令:

pushf/popf：将程序的状态字入栈和出栈

pusha/popa：将8个16位通用寄存器内容入栈和出栈

pushad/popad：将8个32位通用寄存器内容入栈和出栈



MIPS中也有一个堆栈指针寄存器SP，栈中的每个元素为固定的32位，其没有专门的入栈和出栈指令，其入栈和出栈的操作只能通过lw/sw来实现，所以不能自动进行栈指针调整，只能通过addi来调整SP的值，堆栈向下生长，栈顶指针指向栈顶空的存储单元，每入栈一个操作数就有SP <- (SP) - 4，每出栈一个32位操作数就有SP <- (SP) + 4

#### （5）复合寻址

将两种以上寻址方式联合起来使用，称为复合寻址；一般从复合寻址的名称中反应寻址方法的顺序；

**比如变址间接寻址：**

也就是先变址寻址然后再间接寻址，EA = [(Rx) + A]，先是变址寄存器加上形式地址A得到一个一个中间结果地址，然后将这个地址所对应的存储单元中的内容作为有效地址，然后变址寄存器加上一个偏移量，Rx = (Rx) + Delta

**比如间接变址寻址：**

EA = (Rx) + (A)，先是形式地址所对应的存储单元的内容作为偏移地址，然后再加上变址寄存器中的内容作为有效地址，然后变址寄存器加上一个偏移量，Rx = (Rx) + Delta

#### 一个关于指令的例题

不过上述的寻址方式介绍都是原理性的，不同机器不同指令系统可能是不一样的，要根据需要具体而定

接下来我们来看一个例子：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240731221844760.png" alt="image-20240731221844760" style="zoom:67%;" />

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240731221912548.png" alt="image-20240731221912548" style="zoom:67%;" />

按字编址，即存储器中最小存储单元是一个字，16位，字长指令格式，即单子长指令，指令字长为一个字长度，为16位

（1）操作码有4位，显然可以有16条指令；指令中的Ms/Md是寻址方式的标志位，根据表格可以看到是3位二进制数，因此寄存器的地址码就只有3位， 所以最多有8个寄存器；MDR（主存数据寄存器）用来保存要写入地址单元，或是从地址单元读到的数据，因此MDR至少是16位，因为存储器是按字编址的，一个存储单元数据至少就是16位，MAR（主存地址寄存器）用来保存数据传输到的地址以及数据来源的地址，由于主存空间的大小是128KB，但又是按字编址的，所以主存空间最多有128 * 1024 * 8 / 16 = 2^16个字，即字的编址空间应该是16位，用一串16位的二进制就可以表示所有字的地址了，所以MAR也至少是16位



（2）转移指令采用的是相对寻址的方式（题中说的），偏移地址存放在寄存器Rn中，而Rn是16位的寄存器，所以寻址范围就是：
$$
(PC) - 2^{15} 到(PC) + (2^{15} - 1)
$$
而PC的范围为$0到2^{16} - 1$，但是整个主存的地址空间大小才$2^{16}$，所以总的寻址范围就是$0到2^{16} - 1$



（3）add (R4), (R5)+，根据题意，add的机器码为0010，所以机器码的前四位是0010，而(R4)表示寄存器间接，寻址标志是001，且R4的编号是100，所以前10位就是0010  001100，同理(R5)+表示寄存器间接且自增，寻址标志是010，且R5的编号是101，所以16位的机器码为0010(add) 001(寄存器间接）100(R4编号) 010(寄存器间接且自增）101(R5编号) B

对于这条指令，首先是源操作数 = ((R4)) = 5678H；然后是目的操作数 = ((R5)) = 1234H

然后相加结果是5678H + 1234H = 68ACH；并存放到(R5)作为地址对应的单元中，即5678H存储单元处的数据变为68ACH

加法操作完成之后R5中的内容加一存放到R5之中，即(R5) = 5678H + 1 = 5679H；注意add指令的作用就是将两个操作数相加然后放入到目的操作数中

### 2.5.3 程序定位方式

注意程序员在编写高级语言程序时使用的地址并不是里面指令或是数据的真实物理地址，而是使用的一个符号空间中的符号，这样编写得到的程序称为源程序

得到源程序之后编译器需要对源程序进行编译，将符号元素转换成指令和数据，并把符号地址转换成存储器的地址，这里的地址也不是实际的物理地址，而是每个程序自己虚拟出来的地址空间中的地址，也称为逻辑地址或相对地址；并且每个源程序的逻辑地址空间都是从0开始的；这样做是为了保证程序的模块化以及处理程序大小大于主存空间大小的情况

对于现代计算机而言，代码编写完成，甚至编译完成都是无法知道程序的实际位置的，只有等到操作系统将其装入主存或是程序开始运行了，这时操作系统才会根据编译得到的逻辑地址确定程序的物理地址；注意程序在运行之前必须先要装入主存中

这样将指令和数据的逻辑地址转换为物理地址的过程称为程序的定位，所谓定位方式就是确定程序中指令和数据的主存物理地址的时间和实现方式

程序的定位方式分为三种：

（1）直接定位方式，只程序装入主存之前就已经确定了指令和数据的物理地址

（2）静态定位方式，程序装入主存的过程中进行地址变换确定了指令和数据的物理地址

（3）动态定位方式，程序在执行过程中，访问到相应的指令或是数据的时候才进行地址转换

#### 直接定位方式

采用直接定位方式时在编写程序或是编译程序的时候使用的直接就是物理地址，不需要进行地址变换

对于单任务系统，一个程序运行的时候计算机的所有资源都被其独占，直接使用物理地址编程是可行的

对于多任务系统，可以将整个物理地址空间分块，每个程序独占一个块，因此对于程序员来说每个程序对应的主存物理空间分块就是已知的，就可以在装入内存的时候确定物理地址

但是如果程序很大，其大小超过了给其分配的物理空间，那就只能把程序分块，在程序运行的时候逐段调入到物理地址空间中，这样的操作称为覆盖

#### 静态定位方式

静态定位方式是由加载程序（操作系统程序）来完成地址转换的，其要求被加载的程序本身是可以被重定位的，即程序中需要被修改的地址需要有某些标识

程序被加载到主存储器的过程中集中一次完成地址转换，将那些带有标识的指令和数据引用的逻辑地址全部转换为物理地址，并且程序一定进入到主存之后就不能再进行移动

直接定位方式的程序每次进入主存的时候只能进入到一个固定的物理空间中，而静态定位方式每次运行的时候可以进入到不同的物理空间中

静态定位方式是在执行之前一次装入到主存中，因此在执行期间不能在主存储器中移动，其无法提高主存储器的利用率，并且如果程序大小超过了分配给它的物理空间，就必须使用覆盖操作了

并且由于程序在物理空间中的地址固定，所以多个用户如果使用同一个程序就很容易造成数据冲突以及各种数据操作不一致，所以静态定位方式不支持多个用户共享一个程序，如果多个用户非要使用同一个程序，那就必须在物理地址空间中分配一个新的空间给另一个用户使用，这个空间中放入此程序的副本

#### 动态定位方式

动态定位是在程序的执行过程中进行地址变换的，动态定位必须要有硬件的支持，并且其通常是采用基址寻址的方式确定物理地址，一个简单的例子是程序在装入到主存储器之前指令和数据的地址不做任何修改，而将主存的起始地址存入这个程序对应的地址寄存器中，在程序执行的时候通过基址寄存器加上程序中的逻辑地址从而形成物理地址，当然指令中并不是所有的数据都需要这样做，某些采用相对寻址的地址码不需要加上基址寄存器，不过这样需要在指令中给出说明

程序中的实际物理地址是在执行的过程中由硬件（地址加法器和基址寄存器）形成的，所以整个程序当然就不需要一次全部放入内存，并且装入内存之后也不用任何修改，所以其装在内存哪个位置也无所谓，这就可以充分利用主存空间中的碎小内存块，可以让主存空间得到充分利用

并且如果用户采用动态定位方式，这样他们面对的程序块就可以是一样的（反正这一块只读的程序中的地址需要自己的程序对应的硬件做一次地址变换，将对应数据放入自己的程序对应的空间中，但是静态就不行了，所有程序的地址放入后都定死了，地址不能根据不同用户进行更改了），因此一个程序段就可以被多个程序所共享

同时动态定位方式支持虚拟存储器，可以给每个用户提供一个比实际空间大得多的虚拟内存空间（逻辑空间地址），这一部分在OS中细嗦

#### 重定位的一个例子

以实模式下的一段汇编程序为例，Pentium 4采用的是静态定位模式：

![image-20240801171438815](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240801171438815.png)

这段代码的意思是将data数据段的段地址赋值给段寄存器ds，在汇编的时候会识别需要重定位的指令，在生成的.exe文件的开头标注这些需要重定位的的地点（即在文件中的偏移），操作系统将.exe文件装入到内存中时读取.exe文件头部的的重定位表，根据其装入的实际地址重写这些重定位项，上述程序中mov ax, data中的data值就是需要重定向的内容，因此在.exe文件中data的值就没有任何意义，操作系统将其装入到物理内存中时如果给data分配的数据段的段地址是1000，那么mov ax, data就被修改成了mov ax, 1000，这样就完成了静态定位



