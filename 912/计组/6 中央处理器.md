# 分散互联CPU

## 分散互联结果的完整数据通路

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241111112955392.png" alt="image-20241111112955392" style="zoom:50%;" />

（1）分散互联结构没有MAR

（2）分散互联结果的MDR只用作数据的读出存储器的时候暂存，写入数据到存储器的时候是直接写入的

（3）分散互联结构有A和B两个暂存器，A指向ALU的源操作数一端，B指向ALU的目的操作数一端

## 分散互联结构的指令周期流程

**分散互联结构的指令执行流程：**

### **（1）取指，并修改PC的值，这一步所有的指令都是一样的**

这里先不写微命令，微命令一般是看图直接写的

```
M[PC] -> IR
(PC) + 1 -> PC
```

### **（2）指令译码和读寄存器**

指令译码就是IR[XX - XX]将IR的一部分取出来即可，也就是将指令中的一部分取出来

读寄存器，就是直接将寄存器中的东西读到暂存器中，比如，如果ALU的两个输入端如果有两个寄存器，那么就直接根据指令内容将寄存器中的东西读到两个寄存器中：

i 其他指令：

```
RF[IR[XX-XX]] -> A		读取源操作数
RF[IR[XX-XX]] -> B		读取目的操作数
```

ii 条件转移指令：

这里条件转移指令需要事先算出结果到ALUOut中，为了在下个时钟周期中直接结束条件转移指令，反正这时候ALU也是空闲的

```
RF[IR[XX-XX]] -> A
RF[IR[XX-XX]] -> B
(PC) + (SigExt(IR[XX-XX])) -> ALUOut
```

### **（3）指令执行，ALU进行计算得到结果，或者转移指令得到转移地址（还是经过计算得到转移地址），反正就是算就完事了！**

这里不同的指令有不一样的执行序列

i 存取指令，这个周期是算出地址

```
(A) + (SigExt(IR[XX])) -> ALUOut
```

ii 算术指令，这个周期是算出结果

```
(A) OP (B) -> ALUOut
```

iii 分支指令（条件转移指令），这个周期是算出程序地址

```
if((A) == (B)) then 
	(ALUOut) -> PC
```

iv 跳转指令（无条件转移），这个周期是算出程序地址

```
(PC[XX-XX] || IR[XX-XX] << 2) -> PC 
```

在这个周期中其实分支指令和跳转指令就已经结束了，但是存取指令和算术指令还没有，还需要将数据存取到寄存器，存储器中

### **（4）访问一次存储器或者写寄存器堆**

这个周期就是根据上个周期的运算结果来执行的，这里只进行一次存储器或者寄存器访问

i load指令，根据ALU结果访问存储器：

```
M[ALUOut] -> MDR
```

ii store指令，根据ALU结果访问存储器

store指令在上一个周期中计算出来的是存储器的地址，这一步直接将数据放到存储器中，并且在第二个时钟周期读寄存器的时候顺便将第二个寄存器的内容读到了暂存器中，所以相比load指令省去了访问寄存器的一步

```
(B) -> M[ALUOut]
```

iii 算术指令，将上个周期的结果放到寄存器中

```
(ALUOut) -> RF[IR[XX-XX]]
```

这个周期中的运算指令和存数指令就结束了，但是加载指令在这个周期中只访问了一次存储器，还需要将数据取出放入寄存器中，因此还需要一个周期，这里的存数指令之所以会少一个周期是因为在第二个时钟周期的时候其实是顺便将存数指令的数据放入到了B中，这样就减少了一次访问寄存器的时间

### （5）访问寄存器（写寄存器堆）

```
(MDR) -> RF[IR[XX-XX]]
```



## 以三类MIPS 32指令为例子分别写出他们的指令周期（背）

### **存数取数指令：**

`lw Rt, Imm16(Rs)`，根据立即数`SigExt(Imm16)`和寄存器`Rs`算出存储器地址，然后将存储器中的内容取出放到`Rt`寄存器中

`sw Rt, Imm16(Rs)`，根据立即数`SigExt(Imm16)`和寄存器`Rs`算出存储器地址，然后将`Rt`寄存器中的内容放入存储器中

Rs这里是源操作数的意思，Rt这里是目的操作数的意思

（1）取指周期：

```
M[PC] -> IR
(PC) + 1 -> PC
```

（2）访问寄存器，译码周期，取出寄存器中的两个数据到暂存器中

```
(Rs) -> A
(Rt) -> B
```

（3）指令执行周期，计算得到存储器地址

```
(A) + ExtSig(Rs) -> ALUOut
```

（4）访问一次存储器或者寄存器

```
取数指令：
M[ALUOut] -> MDR

存数指令：
(B) -> M[ALUOut]
```

这里存数指令sw就执行完毕了，其在第二个时钟周期已经事先访问了一次寄存器，将数据存放到了暂存器B中

（5）访问一次存储器或者寄存器，只剩下了load指令，这里存数指令sw在第二个时钟周期事先访问了一次寄存器，因此取数指令比存数指令多了一个时钟周期用来访问寄存器

```
(MDR) -> Rt
```

### **算术指令：**

`op Rd, Rs, Rt`，这条指令完成(Rs) op (Rt)并将结果放入到Rd中

（1）取数周期：

```
M[PC] -> IR
(PC) + 1 -> PC
```

（2）译码，访问寄存器周期：

```
(Rs) -> A
(Rt) -> B
```

（3）执行指令周期，进行运算得到结果

```
(A) OP (B) -> ALUOut
```

（4）进行一次寄存器或者存储器访问

```
(ALUOut) -> Rd
```

### **跳转指令：**

`beq Rs, Rt, Addr16`，有条件跳转指令，当`(Rs) == Rt`的时候跳转到`(PC) + SigExt(Addr16) * 4`的位置处

`j Addr26`，无条件跳转指令，直接跳转到`PC[31 - 28] || (Addr26) * 4`的位置处

（1）取值周期：

```
M[PC] -> IR
(PC) + 1 -> PC
```

（2）译码周期，访问寄存器：

```
(Rs) -> A
(Rt) -> B
(PC) + SigExt(Imm16) << 2 -> ALUOut
```

这里多的`(PC) + SigExt(Imm16) << 2 -> ALUOut`这一步是为了在下个周期中直接结束条件跳转指令

（3）指令执行周期：

```
有条件转移：beq Rs, Rt, Addr16
if (Rs) == (Rt)
	then (ALUOut) -> PC

无条件转移: j Addr26
PC[31-28] + (Addr26 << 2) -> PC
```

直接结束了指令流程

## 指令周期流程图

上文中已经写出了每个时钟周期的微操作序列，流程图就是将一个时钟周期框起来打上箭头即可，不过最后要加上下面的符号表示结束：

![image-20241111111139167](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241111111139167.png)

# 单总线CPU

## 单总线CPU数据通路

单周期的数据通路结构比分散互联简单多了，下面是完整的数据通路：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241111113953263.png" alt="image-20241111113953263" style="zoom:50%;" />

完整的数据通路其实没啥用，控制信号一般都不考，这里直接记住简略版的即可：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20241111114043858.png" alt="image-20241111114043858" style="zoom:50%;" />

（1）单总线有一根总线，这个非常好辨认

（2）单总线有MAR和MDR，并且所有的数据（指令和操作数）都是需要经过MAR和MDR与存储器交互

（3）单总线的ALU有两个暂存器A，B

## 单总线CPU的指令周期流程

控制信号仍然不用写，做题的时候按图直接写即可，并且需要注意的是由于数据的交互需要用到总线，所以一般每传输一次数据都需要一个时钟周期，单总线指令的执行需要很多的时钟周期

### **（1）取指阶段**

这里将PC的内容放到ALU中是为了后面的PC自增，当然如果PC自己就有自增的功能这里就不需要将PC内容放到A中：

```
(PC) -> MAR
(PC) -> A
```

这里将MDR中的内容放入到IR中：

```
M[MAR] -> MDR
```

```
(MDR) -> IR
```

下面修改PC的内容：

```
4 -> B
```

```
(B) + (A) -> PC
```

当然如果PC自己就有自增的功能取值阶段会简单一些，只用四个时钟周期就好了：

```
(PC) -> MAR
```
```
M[MAR] -> MDR
```

```
(MDR) -> IR
```


```
(PC) + 4 -> PC
```

### **（2）读寄存器和译码阶段**

这个阶段的划分其实没有那么明显，为了保持前两个阶段所有的指令都统一，这里我们在这个阶段就只安排一个时钟周期，得到源操作数：

```
RF(IR[XXX-XXX]) -> A		不管什么指令，先得到源操作数
```

### **（3）指令执行阶段，这一阶段完成所有指令的执行**

这个阶段的不同指令的过程就不一样了

**lw指令：**先算出存储器地址，然后取数到寄存器中

首先读寄存器得到第二个操作数

```
RF[IR[XXX-XXX]] -> B
```

然后算出存储器地址：

```
(A) + (B) -> MAR
```

从存储器中取出数据到寄存器中：

```
M[MAR] -> MDR
```

```
(MDR) -> RF[IR[XXX-XXX]]
```



**sw指令：**先算出存储器地址，然后将寄存器内容放到存储器中

首先读寄存器得到第二个操作数

```
RF[IR[XXX-XXX]] -> B
```

然后算出存储器地址：

```
(A) + (B) -> MAR
```

寄存器数据放入到存储器中：

```
RF[IR[XXX-XXX]] -> MDR
```

```
(MDR) -> M[MAR]
```



**算术指令：**对两个操作数进行操作，结果放到寄存器中

首先读寄存器得到第二个操作数

```
RF[IR[XXX-XXX]] -> B
```

然后操作放入到寄存器中：

```
(A) OP (B) -> RF[IR[XXX-XXX]]
```



**有条件跳转指令：**如果两个操作数相等，则跳转到对应的地址

首先，先利用ALU进行一次比较操作：

送第二个操作数：

```
RF[IR[XXX-XXX]] -> B
```

进行比较，如果相等，则进行后面的操作，即对PC进行修正：

```
if Z == 0 then
	(PC) -> A
```

后面就是进行PC修正了，当然是利用ALU进行修正：

首先，送第二个操作数，这里的符号扩展以及移位操作根据完整的数据通路并没有用到总线，因此送操作数以及符号扩展只用一次时钟周期就可以完成：

```
(SigExt(IR[XXX-XXX]) << 2) -> B
```

进行操作得到PC修正值：

```
(A) + (B) -> PC
```



**无条件转移指令：**直接修正PC

同样，这里的或操作，以及扩展和移位操作没有用到总线，所以可以放在一个时钟周期完成

```
(PC[XXX-XXX] || IR[XXX-XXX] << 2) -> PC
```

## 以三类MIPS 32指令为例子分别写出他们的指令周期（背）

这里默认PC自己就有自增的功能

### **存数取数指令：**

`lw Rt, Imm16(Rs)`，根据立即数`SigExt(Imm16)`和寄存器`Rs`算出存储器地址，然后将存储器中的内容取出放到`Rt`寄存器中

`sw Rt, Imm16(Rs)`，根据立即数`SigExt(Imm16)`和寄存器`Rs`算出存储器地址，然后将`Rt`寄存器中的内容放入存储器中

（1）取指阶段：

这个阶段所有的指令都是一样的

```
(PC) -> MAR
```

```
M[MAR] -> MDR
```

```
(MDR) -> IR
```

```
(PC) + 4 -> PC
```

（2）读寄存器和译码阶段：

从寄存器堆中读取第一个操作数，这个阶段所有的指令也都是一样的

```
(Rs) -> A
```

（3）指令执行阶段：

`lw Rt, Imm16(Rs)`指令：

```
SigExt(Imm16) -> B		得到第二个操作数
```

```
(A) + (B) -> MAR		计算得到需要从存储器取得数据得地址
```

```
M[MAR] -> MDR		将存储器的数据存放到MDR中
```

```
(MDR) -> Rt		将MDR中的数据放到寄存器中，指令结束
```



`sw Rt, Imm16(Rs)`指令：

```
SigExt(Imm16) -> B		得到第二个操作数
```

```
(A) + (B) -> MAR		计算需要存放到存储器中的地址
```

```
(Rt) -> MDR		将数据放到MDR中
```

```
(MDR) -> M[MAR]		将MDR中的数据放入到存储器中，指令结束
```



### **算术指令：**

`op Rd, Rs, Rt`，这条指令完成(Rs) op (Rt)并将结果放入到Rd中

**（1）取指阶段：**

```
(PC) -> MAR
```

```
M[MAR] -> MDR
```

```
(MDR) ->  IR
```

```
(PC) + 1 -> PC
```

**（2）读寄存器以及译码阶段：**

```
(Rt) -> A
```

**（3）指令执行阶段：**

```
(Rs) -> B
```

```
(A) OP (B) -> Rd
```

### 转移指令：

`beq Rs, Rt, Addr16`，有条件跳转指令，当`(Rs) == Rt`的时候跳转到`(PC) + SigExt(Addr16) * 4`的位置处

`j Addr26`，无条件跳转指令，直接跳转到`PC[31 - 28] || (Addr26) * 4`的位置处

**（1）取指阶段：**

```
(PC) -> MAR
```

```
M[MAR] -> MDR
```

```
(MDR) ->  IR
```

```
(PC) + 1 -> PC
```

**（2）读寄存器以及译码阶段：**

```
(Rt) -> A
```
上面两个阶段所有的指令都是一样的过程

**（3）指令执行阶段：**

`beq Rs, Rt, Addr16`指令：

这里的有条件跳转指令需要比较一次，以及计算得到PC地址一次，所以需要使用两次ALU

```
(Rs) -> B		得到第二个操作数
```

```
if Z == 0 then
	(PC) -> A		如果Rs和Rt的值相等，则进行下面的操作，得到新的PC的地址
```

```
(SigExt(Addr16) << 2) -> B			得到第二个操作数
```

```
(A) + (B) -> PC		得到新的PC地址，指令执行结束
```



`j Addr26`指令：

```
PC[XXX-XXX] || (Addr26 << 2) -> PC
```

## 指令周期流程图：

上文中的每一个代码框都代表的是一个时钟周期，这里的指令周期流程直接用框框框起来即可
