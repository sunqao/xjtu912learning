# 第三章 - 存储器

存储器用于存放程序以及与程序有关的的各类数据，主存储器是存储系统的核心，其用来存储计算机运行期间所需的程序和数据，CPU可以直接对齐进行控制和访问

# 3.1 主存储器概述

## 3.1.1 存储器的分类

存储器是计算机系统中的记忆设备，用来存放程序和数据

### 存储器按在计算机系统中的作用分类

**（1）内部存储器**

内部存储器，简称内存，是一种可以直接和CPU交换数据的存储器，内存包括高速缓存存储器Cache和主存储器（简称主存）

主存主要放的是当前CPU正在执行的程序和数据；Cache是用来解决主存和CPU之间的速度差异的，Cache中的内容都是主存的副本，因此内存的容量只取决于主存的大小，与Cache的大小无关

**（2）外部存储器**

也成为辅助存储器，简称辅存，用来存放大量的，暂时不运行的数据和程序，以及一些需要永久保存的数据；外存可以当作内存的后援储存器

**（3）离线存储器**

也成为备份存储器，主要对在线的数据进行备份

**（4）控制存储器**

控制存储器称为微程序存储器，其用于在微程序控制的计算机中存放微程序，控制存储器位于CPU的内部

### 存储器按存储介质分类

存储介质就是存储器中存放信息的物理单元，作为存储器的物理介质其必须有两种区别明显的物理状态

**（1）半导体存储器**

用半导体器件来存取数据，体积小，功耗低，速度快，常用作内存

**（2）磁表面存储器**

用磁层来存取信息，用磁层依附的物质形状来命名，容量大，速度慢，价格低，非电易失，常用作外存

**（3）光盘存储器**

用磁光材料作为存储介质，利用激光进行信息的存取，非电易失，容量大，耐用性好，可靠，互换性强

### 存储器按存取方式分类

**（1）随机存储器（RAM，Random Access Memory）**

随机存储器中任何单元的内容都能被随机存取，并且存取时间与存取单元的物理位置无关

RAM可以分为动态随机存储器（DRAM），和静态随机存取器（SRAM）两种

其中DRAM中存储的信息如果长时间不访问会发生变化，因此需要定时刷新来维持信息的稳定；而SRAM在加电的情况下所存储的信息可以保持稳定



**（2）只读存储器（ROM，Read Only Memory）**

ROM采用的存取方式也是随机存取，但是ROM在正常工作的时候只能读不能写，其写入需要特殊手段进行，其最大的特点就是非易失性和高可靠性，因此ROM通常作为主存的一部分用于存放系统程序和各种固件

按照写入的方式不同，ROM可以分为

**i 可编程ROM，即PROM（Programmable ROM）**

可以进行一次编程写入

**ii 可擦除可编程ROM，即EPROM（Erasable Programmable ROM）**

可以借助紫外线或其他方式进行多次擦除和编程

**iii 电可擦除可编程ROM，即EEPROM（Electrical Erasable Programmable ROM）**

其与EPROM的区别在于擦除的过程中，不需要借助紫外线和其他方式



**（3）顺序存储器（SAM，Sequential Access Memory）**

顺序存储器中的读写完全按照其在存储介质中的顺序进行，因此在顺序存储器中信息的存取与信息所在的物理位置有关；顺序存储器的读写操作只能顺序的按数据所在的物理位置进行，因此这种存储器的平均存取速度很慢；磁带是典型的顺序存储器



**（4）直接存储存储器（DAM，Direct Access Memory）**

其工作原理与SAM类似，其读写操作分为两步，第一步快速定位到信息所在的一个区域，然后再这个小区域中按照顺序对信息进行准确定位，它的速度位于RAM和SAM之间，也被称为半顺序存储器；磁盘存储器和光盘存储器是典型的DAM



**（5）相联存储器（Associative Memory，AM）**

前面的存储器都是按地址访问存储单元的，但是相联存储器是一种不根据地址而是根据存储内容来进行存取的存储器，可以实现快速地查找快表。既可以按照地址寻址也可以按照内容寻址（通常是某些字段），为了与传统寄存器作区别，称为按内容寻址的存储器。

也就是它可以根据CPU给出的关键字与存储单元中的相应信息进行比较，定位到与关键字匹配的存储单元之后将此单元中的信息取出



以上就是存储器的分类了，目前主存储器主要采用半导体器件作为存储介质，下面来介绍一下半导体存储器的分类

### 半导体存储器的分类

**（1）按制造工艺进行分类**

**i 双极型存储器**

主要由TTL晶体管组成，工作速度快，集成度低，功耗大，价格高，通常用作高度缓存器

**ii 金属氧化物半导体存储器**

也就是MOS型存储器，其可以用来制造多种半导体存储器件，其集成度高，功耗低，价格低，速度比双极型慢，主存储器通常就是由MOS型的存储器构成的

**（2）按信息的可保存分类**

**i 电易失型存储器**

也就是断电后数据丢失，大多数的RAM属于这种存储器

**ii 非电易失型存储器**

断电后的数据保存，ROM就是这种存储器，也有一小部分的RAM属于这种

通常主存就是由ROM和RAM组成的，ROM的内容只能读不能写，断电后信息保存，因此就存放一些系统程序；RAM可读可写，断电后信息丢失，于是就存放一些系统运行过程中的用户数据；RAM和ROM共享主存空间，ROM一般占据较小的主存空间，RAM占据了大多数的主存空间

### RAM存储器的分类

RAM存储器按照其工作方式的不同可以分为以下三类

**（1）静态随机存储器（SRAM）**

SRAM的存储电路由MOS管触发器构成，用触发器的导通和截止状态来表示信息0和信息1，其速度快，信息稳定，不需要刷新电路（关于刷新后文细嗦）；但是集成度低，功耗大，成本高，在计算机系统中，SRAM常用于小容量的高速缓存器

**（2）动态随机存储器（DRAM）**

其利用MOS管的栅极分布电容的充放电来保存信息，其集成度高，功耗低，价格便宜，但是存在漏电，因此必须定时刷新来保证数据不丢失，主存储器通常由DRAM组成

**（3）非易失性存储器（NVRAM，Non Volatile RAM）**

在正常工作的时候NVRAM与SRAM的功能相同，可以随机读写，但是在发生停电等突然事件的时候它可以将SRAM中的信息保存到EEPROM（电可擦除可编程只读存储器）中，使得信息得到自动保护，NVRAM一般用于保护存储系统中的重要信息

## 3.1.2 存储器的层次结构

冯诺伊曼的计算机系统以存储器为中心的结构；计算机要求存储器，速度快，容量大以及价格低，但是这三者通常是矛盾的，为了解决这三者之间的矛盾，一个多层次的存储系统应运而生

剩下的内容比较简单，这里就不多说了

# 3.2 主存储器

## 3.2.1 主存储器的组成

主存储器由存储单元组成的存储体和一组控制电路组成，如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240801192857149.png" alt="image-20240801192857149" style="zoom:67%;" />

下面来一一介绍上述单元

### 存储体

存储体是存储单元的集合用来存放二进制信息；不过为了信息交换的效率，主存与计算机系统中的其他部件交换信息的时候不是以二进制的形式进行的，而是将若干个存储元（一个二进制位）组成一个存储单元，存储单元中的二进制信息被部分或完整的写入或读出

所以每个存储单元都有自己的独立地址，存储单元的位数（即存储字长）是字节的整数倍；一个存储器的就是由这样很多的存储单元组成的

### 寻址系统

寻址系统由驱动器，译码器，以及MAR（主存地址寄存器，用来保存数据传输到的地址以及数据来源的地址）组成，地址译码器接收到来自MAR的n位地址后进行译码，经过译码和驱动之后可以形成$2^n$种地址选择信号，每次选中一个存储单元，就可以对齐进行读或者写操作

每一条译码线都要与其所控制的存储单元相连，驱动器就是为了提高译码线的负载能力而设置的；地址译码线的输出端接入到驱动器的输入端，驱动器的输出端接到所有存储单元

### 读写系统

读写系统由读写电路以及MDR组成，MDR用来缓存CPU发过来的数据，或从主存种读到的数据，读写电路接到CPU的读或者写信号之后产生存储器内部的读写信号，将指定地址单元的数据读出送到MDR种供CPU使用，或者将来自CPU的已经写入到MDR的数据放入存储器的指定存储单元种

### 控制电路

控制电路根据CPU发来的读写命令产生存储器各个部件的时序控制信号

### 读写操作实例

在进行读操作的时候

（1）CPU首先在地址总线上给出访问的存储单元的地址

（2）主存的寻址系统对该地址进行译码，并通过驱动器选中指定的存储单元

（3）CPU在控制总线上发出读的命令

（4）主存的读写控制电路将存储单元中存放的数据发送到数据总线上，并通过数据总线送到CPU中

在进行写操作的时候

（1）CPU首先在地址总线上给出访问的存储单元的地址

（2）主存的寻址系统对该地址进行译码，并通过驱动器选中指定的存储单元

（3）CPU将需要写入的数据发送到数据总线上

（4）CPU在控制总线上发出写的命令，主存的读写控制电路将数据总线上的数据写入到指定的存储单元中

一般而言，存储器的芯片采用M * N位来描述其容量，N表示存储器芯片中每个存储单元的字长（称为片字长），存储单元是最小可寻址单位，M表示存储单元的个数；片字长一般取1, 4, 8, 16...k位，每一个存储单元都由存储体中的k位组成

### 寻址系统译码器译码的方式

所谓译码方式，其实就是寻址系统的译码器得到存储单元的地址后怎么通过译码器连接确定存储单元的过程，这里有两种方式，线选法确定存储单元和重合法确定存储单元

**（1）线选法**

线选法其实就是译码器得到存储单元的地址后输出的字线直接连接到对应的存储单元中，直接将这个地址处的存储单元全部取出

我们假设有一个1K * 8位的存储器芯片，其采用的是1024 * 8的存储矩阵，于是我们知道存储单元的个数应该为$2^{10}$个，所以地址位数应该为10位，因此线选法的硬件电路如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240803165010102.png" alt="image-20240803165010102" style="zoom:67%;" />

上图中一个存储元的左边一个数字是其所在存储单元的地址，右边是其在一个存储单元中的第几位，一个字线对应一个存储单元，一个字线对应一套驱动电路，因此就有1024套驱动电路

当地址输入到译码器中，译码器确定了存储单元地址然后读/写进CPU的过程如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240803165551433.png" alt="image-20240803165551433" style="zoom: 50%;" />

**（2）重合法，双译码结构**

重合法将给出的地址拆成了两个组，一组是行地址，一组是列地址，行地址得到的行选择线和列地址得到的列选择线重合的存储单元就是需要读写的单元

假设有一个1K*1位的存储芯片如下所示，这里一位是一个存储元，也是读写的一个存储单元，采用32 * 32的方式进行排列：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240803165903394.png" alt="image-20240803165903394" style="zoom:67%;" />

同样是1024个存储单元，所以地址线的数量应该是10根；有32行，所以行地址译码器分配5根地址线，输出32根行选择线，对应32套驱动电路；有32列，所以列地址译码器分配5根地址线，输出32根列选择线，对应32套驱动电路

所以总的驱动电路就是64套，译码选择过程如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240803170354136.png" alt="image-20240803170354136" style="zoom:50%;" />

## 3.2.2 主存储器的性能指标

### 存储容量

也就是主存可以容纳的存储单元的个数

如果按字编址，那么一个存储单元就是一个字，存储容量就是：存储单元个数 * 存储字长，单位是位(b)，这里存储字长一般等于机器字长

如果按字节编址，那么一个存储单元就是一个字节，存储容量就是存储单元个数，即存放的字节数，单位是字节(B)

需要注意的是，如果按字编址的话存储容量的写法得用存储单元个数 * 存储字长的写法，如果按字节编址就直接写成字节数；这样做是因为存储字长在不同的机器上是不一样的，统一用位表示，并且写成乘积的形式容易理解，而字节则是一个统一的单位

存储单位换算如下：

```c
1 TB = 1K GB
1GB = 1K MB
1MB = 1K KB
1KB = 1K B
1B = 8b
上述1K表示1024，即2^(10)
```

### 存储速度（读写速度）

通常用存取时间和存取周期表示

存取时间称为存储器的访问时间，就是指启动一次存储器写（或读）到完成该操作的时间

读出时间是存储器受到有效地址，到产生有效输出的时间

写入时间是存储器收到有效地址，到写入存储单元的时间；通常写入时间和读出时间相等，两者统称为存储器的读写时间

存取周期是指存储器完成一个完整的读写所需要的时间，其包括读写时间以及后面的电路恢复时间，它是一个更加完整的过程，因此其时间略大于读写时间

### 存储器带宽

指单位时间内存储器的存取信息量，单位为W/s, B/s, 或b/s，计算公式为：
$$
存储器带宽 = \frac{每个存储周期可访问的位数}{存取周期(s)}
$$
存储带宽就是以存储器为中心的计算机系统获取信息的速度，通常通过缩短存取周期，增加存储字长，增加存储体等方式增大带宽

## 3.2.3 SRAM

### SRAM存储元

SRAM即静态随机存储器，其静态的意义就是只要保持电源供电，SRAM就能稳定保存数据，SRAM的基本特征是使用一个双稳态的触发器作为存储元

不是重点，略，注意mos管中间一条线为高电平时是导通状态，然后导通状态下两边的线其实电流成比例，因此一条线是高电平另一条线也是高电平，记住这个就好，其他的先看书理解以下即可

### SRAM芯片举例

#### CY7C1011CV33 SRAM

这个芯片的存储容量为128K * 16位，结构如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240803185900655.png" alt="image-20240803185900655" style="zoom:67%;" />

其包括$IO_0 - IO_7$的低字节数据线部分，以及$IO_8 - IO_{15}$的高字节数据线部分，用来将数据读出写入

以及片使能$\bar{CE}$，主存一般是由若干个上图的芯片组成的，因此每次访存涉及的芯片也不一样，这里的片使能为低电平有效，也就是上图中$\bar{CE}$对应的那条细线为低电平的时候表示本次存储器的访问涉及这个芯片

输出使能$\bar{OE}$，低电平有效，即表示$\bar{OE}$对应的那根细线为低电平的时候是从存储器中读取数据

写使能$\bar{WE}$，低电平有效，即表示$\bar{WE}$对应的那根细线为低电平的时候是从存储器中写入数据

同样有高字节使能$\bar{BHE}$和低字节使能$\bar{BLE}$，分别表示要访问一个字中的高字节还是低字节

当$\bar{CE}$和$\bar{WE}$均为低电平的时候，数据线上的数据被写入存储单元，当$\bar{CE}$和$\bar{OE}$均为低电平的时候，存储单元上的数据被读出

一般这样一个芯片会使用一个逻辑符号框图表示：

![image-20240803190836533](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240803190836533.png)

这个框图的内部写上芯片名字以及片容量，还有在对应的引脚处写上引端名字，引端名字是芯片引脚的逻辑定义，是由厂家给出的

在方框的外部写上信号名字，这里的信号是用户自定义的，不过不管是引端名字还是信号名字，都指的是那根细线，而不是细线与圆圈组成的整体

当然，上述引脚线是逻辑引脚，当然还包括电气引脚，比如电源线和接地线等等，这里忽略



#### Intel 2114 SRAM

这个芯片的容量为1K * 4位，存储矩阵是64 * 64，结构如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240803191341971.png" alt="image-20240803191341971" style="zoom:67%;" />

其地址译码采用的是重合法，$A_3 \sim A_8$是行地址，$A_9, A_2 \sim A_0$是列地址

其同样有一个片选信号，是低使能有效

控制读写的只有一个写使能信号，同样是低使能有效，表示低使能写信号有效，表示写入数据

其逻辑框图如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240803191618280.png" alt="image-20240803191618280" style="zoom: 50%;" />

### SRAM的读写时序

对于一个确定的芯片而言其读写时序是确定的，这里以CY7C1011CV33 SRAM为例

**（1）其读数据的信号如下所示：**

![image-20240803194046108](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240803194046108.png)

上图中的地址线和数据线两根的原因是输入一串数据中有0也有1，这里变化一次表示有效无效的变化

首先是CPU在地址总线上发出有效地址，并且通过片选信号$\bar{CE}$选中这块芯片，如上图中的橙色线所示，此时存储器对地址信号进行译码并选中相应的存储单元

经过一段时间后，读使能信号和高低字节使能信号有效，如上图中的紫色直线，并经过一段延迟时间后数据有效输出相应的高低字节，上图红色线

读出过程中存在两个约束：

（1）从发出使能信号$\bar{CE}$橙色线，到数据有效真正读到数据上图红色线，注意是红色线，原图有误，需要经过一个时间tace

（2）从读使能有效紫色，到数据真正有效红色，同样有一个时间tdoe

tace的时间最短是10ns，因此如果cpu发出了使能有效后真正读到数据就得10ns之后了

并且撤销过程也有两个约束：

（1）从撤销使能信号$\bar{CE}$蓝色，到数据线上的数据无效有一个时间延迟thzce

（2）从撤销读使能信号$\bar{OE}$到数据上上数据无效（撤销数据）有一个时间延迟thzoe

这就说明CPU发出了撤销信号之后数据真正从数据线上撤销还需要有一个时延，在这个时延中数据线仍被占用不能被其他数据使用，所以从发出使用这个存储器的信号开始（橙色）到这个存储器真正可以被再次使用（绿色）这一段时间trc + thzce是这个存储器的恢复时间

从片使能信号发出，到片使能信号结束的时间trc，为存储器芯片的读出时间

只要不违反上述两个约束就可以随意使用这个芯片，比如可以让$\bar{CE}$和${\bar{OE}}$同时有效，然后等tace的时间读到数据

**（2）写时序信号**

不是重点，不再赘述

## 3.2.4 DRAM

### DRAM存储元

不是重点，不再赘述，看书即可

### DRAM刷新操作

DRAM存储元中的电荷会因为电荷泄露而引起DRAM所存的信息衰减，所以必须定期对电容补充电荷，这种操作被称为刷新操作

DRAM存储器能维持的信息的最长时间称为最大刷新间隔，一般为2ms, 8ms, 64ms等，最大刷新间隔其实也就是某个存储元两次刷新时间的最大间隔，对于一堆的存储元整体来看，一个最大刷新时间间隔中一个存储体的所有存储元至少要被刷新一次，在这个刷新间隔中刷新之外的时间可以对存储体进行读写操作

由于在进行读的操作时存储元会自动再生操作补充电荷，所以刷新就可以通过读的操作进行；一次刷新操作所需要的时间就是一次读操作所需要的时间

刷新操作是按照矩阵的行进行的，只需要送出行地址和刷新信号即可，只不过行地址不需要外部提供，DRAM内部有一个行刷新计数器用于产生行地址

为了保证正常工作，必须在最大刷新间隔中对所有的存储元进行一次刷新，安排存储元中的各行的刷新时间的策略称为刷新方式

**（1）集中式刷新**

集中式刷新是指将全部的存储单元集中在一段时间内刷新，在整个刷新间隔中，前一部分时间用于正常的存储器读写和保持操作，后一部分用于所有存储器的刷新操作

在进行集中式刷新的时候是对存储体逐行刷新的，因此不能进行正常的存储器读写操作，这个称为存储器的死时间或读写死区，目前很少采用这种方式

假设有一个64K * 1的DRAM芯片，存储体为256 * 256的矩阵，最大刷新间隔是2ms，也就是第一个存储元刷新间隔是2ms，存取周期是$0.5 \mu s$，每行刷新因此刷新一行就是一个读取周期，刷新256行就需要需要256个存取周期

注意刷新间隔的定义，并不是在一个刷新间隔内这个存储元始终不能被读取，而是这个存储元可以保持数据的最大间隔，在这个间隔中这个存储元不是一直处于无法读取的状态，对于整个存储体也是这样的，并不是一行行刷新完了之后直接开始从第一行又开始刷新，而是等到第一行的数据无法保持了之后再继续一行行刷新

在一个刷新间隔中，256个刷新存取周期存储器不能进行正常读写，也就是刷新间隔中的后一部分时间，然后刷新周期的前一部分时间都可以正常读取数据，所以其余的3744个存期可用于正常的读取

注意注意的是刷新时间和读取时间各自都是整块连在一起的时间，过程就是上一个刷新间隔结束，整个存储器可以正常读取数据，然后第一行的存储元数据无法保持了，就开始整个集中一行行开始刷新，这个集中一行行刷新就是死时间，结束之后就进入了下一个刷新间隔

**（2）分散式刷新**

分散式刷新是将刷新周期分散到每个存取周期中进行，每个存取周期的前半段用于读写保持数据，后半段用于刷新操作，分散式刷新将存取周期扩大到了两倍；意思就是本来正常存取周期都是0.5us，但是呢人为将其扩大到了1us，这样前半段用于读写，后半段用于刷新，将刷新操作融入到了每次读写操作中了；这样就克服了死时间，一个刷新周期中，不管哪个时间段都可以随便使用存储器（注意一般来讲存储器中在一个刷新间隔中的所有行都会被访问到，不必纠结哪一行一直不被访问无法刷新的问题）

仍然是上述64K * 1的DRAM芯片，存储体为256 * 256的矩阵，最大刷新间隔是2ms（指某一行的存储元可以保持信息的最大时间间隔，也就是某行刷新一次之后最多经过2ms必须再刷新一次），存取周期是1us，因此在这2ms中就包含有2000个存取周期，这2000个存取周期中存储器都可以正常读写，假设这2000个存取周期都在读写并且每行都被读写到了，那么就刷新了2000次，平均下来每行刷新了7.812次，比集中式每行多刷新了6.812次

但其实2ms中只需要保证每行刷新一次，即刷新256次即可，但是强迫每次读写时也进行刷新，这就造成了多次刷新，浪费了时间

**（3）异步式刷新**

异步式刷新是指，其将所有行的刷新操作平均分配在一个刷新间隔中，使得在一次最大刷新间隔中，每一行都会被刷新并且只被刷新一次

这样做首先就不存在时间的浪费了，因为每行都只刷新了一次，并且由于是分散到一个刷新间隔中，也就不存在有一整块时间不能读写使用的死时间问题了

仍然是上述64K * 1的DRAM芯片，存储体为256 * 256的矩阵，最大刷新间隔是2ms（指某一行的存储元可以保持信息的最大时间间隔，也就是某行刷新一次之后最多经过2ms必须再刷新一次），存储周期是0.5us，在这2ms的刷新间隔中将256次刷新平均分配，那就是2000us / 256 = 7.8us得刷新一行，这7.8us其实还是有0.5us是不能读写的，但是从宏观上看这个7.8us中大部分时间都是可以读写，而从概率上讲就必然比一个整块的死时间对存储器的使用影响小很多，也就克服了死时间的影响

### DRAM存储器芯片举例

DRAM一般集成度非常高，因此芯片的引脚就很多，为了减少芯片引脚一般讲地址分为行地址和列地址两部分，并且两部分分别在不同的时间段使用同一组地址引脚，这样就将实际的地址引脚减少为原来的一半了，因此每增加一根地址引脚其实是行列地址个增加了一位，芯片的总容量其实扩大了4倍

为了区分行列地址，又引入了行地址选通信号$\bar{RAS}$和列地址选通信号$\bar{CAS}$，同时为了进一步减少引脚，通常将片选信号$\bar{CE}$与行地址选通信号$\bar{RAS}$合在一起使用，下图是一个非常典型的DRAM内部结构示意图，我们需要再加上一个写使能$\bar{WE}$来区分是写入还是读出：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240805113337001.png" alt="image-20240805113337001" style="zoom:67%;" />

DRAM的逻辑框图如下所示：

![image-20240805113400474](https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240805113400474.png)

### DRAM的读写时序

不是重点，看看书即可

## 3.2.5 新型DRAM

不是重点

## 3.2.6 只读存储器和闪存存储器

只读存储器即ROM在前面已经介绍过，它比SRAM和DRAM的最大特点就是只能读处不能写入，并且其中的信息在断电之后不会消失，具有非电易失性，其通常用来保存一些重要的数据，比如计算机启动的时候的Bios芯片等等

其主要用途就是软件固化，**写到ROM中的软件以及芯片称为固件**

以下内容都不是重点，看看ppt知道概念即可，电路图原理什么的不用在意

### 只读存储器

**MROM（MASK ROM）**

掩模式ROM，也就是在生产过程中采用掩模式（光刻图形技术）一次性写入的，其一旦制成之后内容就不能再改写，因此只适用于存储永久性的程序和数据

**PROM（Programmable ROM）**

可编程ROM，出场之后用户可以使用专门的ROM写入器进行写入操作，但是只能写入一次

**EPROM（Erasable Programmable ROM）**

擦除可编程ROM，是一个可以多次写入的ROM，用户使用转变的编程器来完成

**EEPROM（Electrically Erasable Programmable ROM）**

电可擦除可编程ROM，其跟EPROM类似，只不过采用的是电擦除技术实现数据的擦除

### 闪速存储器

即Flash Memory，简称Flash存储器或者闪存，其与EEPROM非常类似，也是一种点可擦写ROM，其与EEPROM相比主要是速度快，成本低，容量大，低功耗，可以再联机的情况下进行电擦除和改写，因此又称为快擦型电可擦除可编程ROM

## 3.2.7 存储器容量的扩展

根据上文我们知道一个存储芯片的容量是有限的，因此想要获得更多的容量就必须将多个存储芯片组合起来满足实际容量的需要

扩展包括三种，位扩展，子扩展，和字位扩展；下文以SRAM为例来说明这三种扩展

### 位扩展

位扩展是增加存储器的存储字长，进行位扩展后的存储器的总字数与单个芯片的总字数保持一致，因此通过位扩展构成的存储器系统所需的总的存储器芯片个数就是：
$$
\frac{存储器字长}{单个芯片的字长}
$$
位扩展的基本方法：

（1）各个存储器芯片的地址线，片使能线，读写控制线分别按同名端并联起来，所谓并联就是多条线合在一起变成一条线进行控制

（2）各个存储器芯片的数据线分别引出串联起来作为总的存储器的数据线

如下图所示，是一个SRAM存储器位扩展的逻辑图：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240805152546692.png" alt="image-20240805152546692" style="zoom:67%;" />

上图中是一个用8片1K * 1位的SRAM芯片组成一个1K * 8位的存储器的例子，其片使能线，读写控制线分别并在一起用一条线控制，数据线引出当作存储器数据线

### 字扩展

字扩展与位扩展相对，是将多片存储芯片连在一起来扩充整个存储器的字数，进行字扩展之后的存储器字长与单个存储芯片的字长保持一致，所以组成一个存储器系统的总的存储器芯片的个数就是：
$$
\frac{存储器的总字数}{单个芯片的字数}
$$
字扩展的基本方式：

（1）将各个存储器芯片的读写控制线，数据线并联起来；注意这里数据线要并联起来，这里的并联意思是指用到哪一片芯片哪一片芯片的数据线就将其数据输入到并联之后的一条总的数据线上作为存储器输出的数据

（2）存储器的地址部分分为高地址和低地址部分，高地址连接一个译码器形成各个存储器芯片的片使能信号，低地址则与每个芯片的地址信号相连，这样扩展了字数之后高地址就形成了一个”段“用来选择使用哪一个芯片，低地址就跟芯片中的地址一样，用来选择存储单元

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240805155449352.png" alt="image-20240805155449352" style="zoom:67%;" />

上图就是一个字扩展的例子，用8片8K * 8的SRAM组成一个64K * 8的存储器，这些芯片的读写控制信号连在一起统一读写，然后每个芯片的数据线也是并联在一起，加粗的意思就是高地址译码后的片选信号选择了哪个芯片，哪个芯片的数据就作为存储器的8位数据输出

上图中的高三位地址译码之后分别连接8个芯片用来选择是哪一个芯片，低13位地址就作为每个芯片中的地址

### 字位扩展

字位扩展的意思就是即增加存储字数，又增加存储字长，因此所需的总的芯片数量就是：
$$
\frac{存储器的总容量 * 存储器的存储字长}{单个芯片的总容量*单个芯片的存储字长}
$$
其实也就是总的存储器位数除以单个芯片的总位数（上面两种也可以这样计算）

字位扩展的方法为：

（1）所有芯片的读写控制线并联在一起统一控制，跟上面两种扩展方式一样

（2）数据线沿着方向同名端，并联并引出作为总存储器的存储子长的一部分，下图中就是沿着横向并联引出作为存储器存储字长的低8位

（3）地址线仍然分为高地址和低地址，高地址线译码后作为片选信号选择纵向的某一列作为一个小段，因此纵向的片选信号应该并联在一起统一被选中，**所以横向的芯片摆在一起是作为字扩展使用，纵向的芯片摆在一起是作为位扩展使用**

（4）地址线的低地址部分用来选择纵向一列的芯片组成的一个位扩展的小段中的存储单元，因此纵向一列的芯片的地址线应该是并联在一起的，当传递某个地址时表示纵向所有芯片的这个地址对应的存储单元都被选中，需要将数据输出，只不过这些芯片的数据分别作为总的存储器的存储字长的高位和低位输出

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240805161157484.png" alt="image-20240805161157484" style="zoom:67%;" />

上图是16块8K * 8SRAM芯片组成的64K * 16存储器的逻辑图

上图中纵向一列芯片用于位扩展，上侧芯片的数据是整个存储器存储字长的第8位，下侧芯片是整个存储器存储字长的高8位；当地址从外界输入之后，上下两片芯片对应地址的存储单元都被选中取出结合一起之后形成总存储器的16位存储字长

上图中横向一串芯片用于字扩展，因此外界地址线的高两位连接译码器来进行片选，选中一列上下两个芯片组成了总存储器的一个存储字长；注意上图中的并联线（也就是上图中加粗的线）其表示是如果是从芯片读出数据，那么并联之后的总的一条线就是这个芯片上的数据，而如果是从外界来的数据，那么到每个芯片分支线上也都将是外界数据，只不过我们通过片选信号屏蔽了这些数据，使得只能写入到给定的地址对应的芯片中

### 其他芯片的扩展

对于ROM来说其通常没有$\bar{WE}$引脚，连接方式与SRAM基本一致

对于DRAM，其容量的扩展方式与SRAM基本一致，但是地址线，片使能线等连接还需要特殊处理，DRAM的扩展与SRAM的区别如下：

（1）根据上文介绍，DRAM的地址线通常采用多路复用，也就是其中的每个芯片都分为行地址和列地址，并且行列地址共用每个芯片的地址线，并且行列地址分时输入，而所有芯片组合在一起作为总的存储器的时候外界可不管分时不分时，而是统一将一个总的地址输给存储器，因此这就需要一个地址多路选择器来分时对总地址拆分，分时选择输给里面的芯片，地址多路选择器一般由DRAMC来控制，后文细嗦

（2）DRAM的芯片为了减少引脚通常将行选择信号$\bar{RAS}$作为片选信号，那么当采用字扩展之后，外界的高地址用来选择那一小段的芯片，同时呢外界还得跟内部的芯片一样有行选通信号和列选通信号用来控制整个芯片组的行选通和列选通；对于外界的行选通信号，其与外界地址的高位部分一起连接一个译码器，这个译码器的输出作为片选信号表示选择字扩展中一组芯片组成的一个小段，下图中的纵向就是字扩展，表示横向的四个芯片组成了一小段，外界的行选通信号和高地址位译码之后分为四条线，每一条线表示选择纵向的某一行，同时表示这一行的芯片行选通，此时的地址是行地址；对于列选通信号和读写控制信号，这两个信号所有的芯片都并联在一起统一控制；如果DRAMC有译码功能的话下图中的译码器可以省略

（3）DRAM芯片的刷新操作，需要有刷新地址计数以及刷新定时等外围电路，这些电路也通常由DRAMC芯片提供

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240805163838389.png" alt="image-20240805163838389" style="zoom:67%;" />

上图就是16个256K * 8的DRAM芯片组成的1M * 32位的存储器的逻辑图，横向一组表示位扩展，因此横向一组芯片的地址需要连在一起，表示当外界给出一个地址之后横向所有芯片都应该选择一样的存储单元，合在一起组成总的存储器的一个存储字长；横向的行选通信号也应该连在一起，行选通同时表示片选信号，表示这一行的芯片作为一小段，外界的低地址部分就在这一组芯片中选择存储单元，所以横向的四个芯片的数据线应该串在一起组成总的存储器的一个存储字长

纵向四个芯片表示的是字扩展，所以片选译码器应该分出4个片选信号（与行选通信号合并）分别连接纵向的四个芯片；同SRAM，纵向的四个芯片的地址线是并联在一起的，当外界的第地址部分给出地址之后纵向的四个芯片都会收到这个地址，根据片选信号决定纵向的哪个芯片得到的这个地址是有效的；其他的就不多说了

## 3.2.8 存储器与系统总线的连接

主要涉及地址线，数据线，和控制线的连接

### 数据线的连接

存储线的数据线必须与系统总线的位数一致，并且逐位连接，通过位扩展形成的存储器，扩展之后的总的存储器的存储字长，也必须与总线的位数一致

### 地址线的连接

单片存储器的地址线与系统总线的地址线一一对应，对于字扩展形成的芯片，外界的地址总线的位数肯定比存储器中的芯片的地址线位数多，这样可以将外界的地址总线的高地址位数作为片选信号，低地址用来字扩展中的每一段的地址，上文有说过，这里不再多嗦

### 控制线的连接

与存储器有关的控制线主要就是读写控制，其与总线中的读写控制直接相连即可

### SRAM/ROM与CPU的连接

对于CPU来讲，其发出的高位地址连接译码器作为片选信号，低位地址送到存储器确定存储单元的地址，但是CPU发出的地址不一定都是主存的地址，还有可能是访问IO的地址，因此需要有一个$\overline{MREQ}$作为访存控制信号，这个信号仍然是低电平有效，只有它有效了译码器发出的片选信号才有效

下面是一个ROM和SRAM结合与CPU连接的例子，2片1K * 8的ROM芯片，以及6片1K * 8的SRAM芯片采用字扩展，形成了一个8K * 8的存储器

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240805173847825.png" alt="image-20240805173847825" style="zoom:67%;" />

上图中的ROM一般存放系统程序，占据的是低地址空间，RAM存放用户程序通常放在第地址空间

上图的译码器采用的是74138译码器（3-8译码器），其中ABC是输入变量段，连接总线CPU发来的地址的高位，输出是8个片选信号；控制端是$\overline{G_{2A}}, \overline{G_{2A}}, G_1$，只有$\overline{G_{2A}}, \overline{G_{2A}}$都是低电平，G1是高电平，三者同时有效的时候译码器才能工作；上图其他部分就不多嗦了

### DRAM与CPU的连接

根据上文所述，DRAM由于刷新机制以及行列地址机制其不直接与CPU相连，而是通过一个DRAMC芯片（DRAM控制芯片）与CPU相连

如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240805180232851.png" alt="image-20240805180232851" style="zoom:67%;" />

上图的虚线框中就是DRAMC的逻辑控制框图，下面来分别介绍

（1）**刷新地址控制计数器**，这个模块向DRAM提供刷新行地址，并自动顺序计数到下一行的地址，刷新地址计数器提供刷新地址，而地址总线提供的是行列地址

（2）**地址多路选择器**，其在行地址，列地址，刷新地址三者选一送给DRAM

（3）**刷新定时器**，根据刷新方式控制刷新时间，当需要刷新的时候发出刷新请求信号，不过并不是请求刷新的时候一定会刷新，因为还有读写信号，所以就需要仲裁电路决定一种访存方式

（4）**仲裁电路**，在CPU的访存请求，刷新请求中决定一种访存方式

（5）**定时发生器**，仲裁电路决定好访存方式之后由定时发生器产生一系列DRAM工作需要的信号，行列选通信号，读写控制信号，刷新信号等等，这玩意儿还挺重要，其最直接决定了对DRAM是读还是写还是刷新以及决定了行列地址的选择还有刷新地址的开始

当然上述只是最简单的连接方式，我们仍然需要考虑时序配合，速度匹配，负载能力等等

## 3.2.9 两个例题

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240805181336213.png" alt="image-20240805181336213" style="zoom:67%;" />

（1）

因为计算机是16位的，而存储器芯片是4位的，由于上文中的连接关系，存储器的存储字长必须与数据总线位数保持一致，所以存储字长也是16位的，通过8K * 4位的DRAM芯片扩展而来

地址空间大小是$2^{20} = 1M$，所以最大主存空间就是$1M * 16$位

（2）

总的模板快，显然就是$\frac{1M * 16}{64K * 8} = 2^5 = 32$块

每个模板块内部，显然就是$\frac{64K*8}{8K*4} = 16$片RAM芯片

（3）

问的是CPU如何选择模板块，其实就是CPU的地址码如何编排

因为模板有32块，两两模块板组合一起位扩展扩展成16位，所以有16组模块板进行了字扩展，因此模块组的片选应该有16个，所以CPU最高位应该分配4位进行模板块组的选择

一个模板块组中，仍然是两两DRAM芯片组合进行位扩展，所以一个模块组应该有8组芯片进行字扩展，因此模块组中应该有8个片选取选择芯片，因此地址码应该再分配次高的3位进行模块组内部的片选

剩下的13位进行芯片内部地址的选择

**第二个例题**

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240805190738742.png" alt="image-20240805190738742" style="zoom:67%;" />

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240805190750745.png" alt="image-20240805190750745" style="zoom:67%;" />

首先CPU的地址线有16位，所以总的主存空间理论大小最大就是$2^{16}*8$位即64K * 8位

但是说了只将16383以内作为主存空间，所以总的主存空间应该是$16384 * 8 = 2^{14} * 8 = 16 K * 8$位

有$4K * 8$是作为系统的，这一部分需要使用ROM来扩展，当字扩展和位扩展都可以实现的时候采用位扩展，因为字扩展还需要进行片选译码，而位扩展只需要引出几条线即可，所以就采用两片4K * 4的ROM组成一个4K * 8的ROM

还剩下12K * 8的空闲需要用RAM扩展，肯定采用4K * 8最方便，所以就接着使用3片4K * 8的RAM

**然后是地址线的连接**

74138是一个3 - 8译码器，会输出8根片选信号，输入是3根

首先是上述采用芯片的内部选址，每一个都是4K（两片ROM由于是位扩展所以寻址也是4K），**因此需要12根地址线用作内部选址**

3-8译码器其实应该有8条线输出进行片选，不过我们可以不全用，其输入应该是3根地址线，**所以需要3根地址线作为3-8译码器的输入**

**3-8译码器的3就表示输入的三根译码器：_  _  _，组成了8个片选，也就是将内部的4K的地址空间分成了8段**

 对于ROM的4K空间，本来就是12根地址线作为内部选址，因此其只需要$4K / 2^{12} = 1$个片选信号，又由于是题中说的最小的4K地址，所以就连着最小的一段，即3-8译码器的0输出端

而RAM有12K的空间，4K作为一段，根据题意又是按顺序的，所以RAM占用3段4K空间，因此需要3-8译码器中的1， 2， 3输出端；而刚好就是3个4K*8的RAM，所以就是每个RAM芯片作为一个4K的地址端连着一个译码器的输出端

12根地址线作为内部选址，3根作为译码器的输入，分别将4K的内部地址划分了8端，但是只用到了前四段，还剩下一根地址线可以作为38译码器的控制端

**最后是数据线的连接**

两片ROM都是4K * 4，所以两片ROM的数据线应该串起来分别作为CPU数据线的高低4位，而剩下的RAM的8位直接并联作为8位即可

然后ROM没有读写控制信号，所以最终的连接方式如下所示：

<img src="https://typora-1310242472.cos.ap-nanjing.myqcloud.com/typora_img/image-20240805195120546.png" alt="image-20240805195120546" style="zoom:67%;" />
